==> chatgpt:  checklist of core java interview questions for senior developer

Here’s a **senior-level Core Java interview checklist** (use it to self-test; if you can explain each item with examples + tradeoffs, you’re solid).

## 1) Language fundamentals (must be crisp)

* `==` vs `equals()` vs `hashCode()` (contracts, pitfalls)
* `final` for variables/methods/classes (immutability vs “cannot override”)
* `static` (class loading, initialization order, static blocks)
* Pass-by-value in Java (object reference value copy)
* Autoboxing/unboxing pitfalls (`Integer` caching, NPE, performance)
* String intern pool: `String`, `StringBuilder`, `StringBuffer`
* `var` (Java 10+) type inference limitations and readability

## 2) OOP & design principles

* Inheritance vs composition (when to prefer which)
* Overloading vs overriding (resolution rules, covariant returns)
* Interfaces: default/static methods, diamond problem rules
* Abstract class vs interface (API evolution, state, contracts)
* SOLID principles with Java examples
* Common design patterns in Java (factory, strategy, builder, decorator, observer)

## 3) Exception handling (real-world depth)

* Checked vs unchecked exceptions (when to use each)
* `try-with-resources` and `AutoCloseable` nuances
* Exception chaining, suppressed exceptions
* Best practices for custom exceptions (fields, messages, causes)
* `finally` behavior with returns/exceptions

## 4) Collections framework (where seniors get tested)

* `HashMap` internals (hashing, bins/treeification, load factor, resize)
* `equals/hashCode` impact on `HashMap`/`HashSet`
* `ArrayList` vs `LinkedList` (realistic performance, not myths)
* `TreeMap`/`TreeSet` ordering (Comparator vs Comparable, consistency with equals)
* Fail-fast iterators and `ConcurrentModificationException`
* `Collections.unmodifiable*` vs truly immutable collections
* `ConcurrentHashMap` internals (locking model, atomic ops like `compute`)
* When to use `CopyOnWriteArrayList`, `BlockingQueue`

## 5) Generics (common senior filters)

* Type erasure: what it breaks (overloads, reflection, instanceof)
* Wildcards: `? extends` vs `? super` (PECS)
* Generic methods vs generic classes
* Why arrays + generics don’t mix (`List<String>[]` issues)
* Bridge methods and covariance/contravariance in practice

## 6) Concurrency & memory model (high-signal area)

* Thread lifecycle, interruption, cooperative cancellation
* `synchronized` vs `ReentrantLock` (fairness, tryLock, conditions)
* `volatile` meaning (visibility + ordering, not atomicity)
* Happens-before rules (core JMM concepts)
* Atomic classes (`AtomicInteger`, `LongAdder`) and when to use which
* Executors: thread pools, queue types, rejection policies
* `CompletableFuture` patterns (compose, combine, exception handling)
* Common bugs: deadlock, livelock, starvation, race conditions
* ThreadLocal (use cases + leaks in app servers)

## 7) JVM internals & performance basics

* Class loading (parent delegation, custom loaders, linkage)
* GC basics: young/old gen, stop-the-world, tuning signals (what you look at)
* Memory areas: heap, stack, metaspace
* Escape analysis, JIT compilation, warm-up effects
* Profiling approach (what you measure before optimizing)

## 8) Java I/O, NIO, serialization

* `InputStream/Reader` vs `ByteBuffer` / NIO channels
* Blocking vs non-blocking I/O concepts
* File operations, `Path`, `Files`, resource handling
* Java serialization risks and alternatives (Jackson, protobuf)
* `transient`, `serialVersionUID` meaning

## 9) Functional Java (Streams/Lambdas)

* Lambda capture rules (“effectively final”)
* Stream pipeline: intermediate vs terminal, lazy evaluation
* `map` vs `flatMap`, `collect`, `groupingBy`, `reducing`
* Parallel streams: when they hurt, fork-join pool implications
* Method references, Optional best practices (avoid Optional fields)

## 10) Date/Time API

* `Instant` vs `LocalDateTime` vs `ZonedDateTime`
* Time zones, DST pitfalls, parsing/formatting
* Why `java.util.Date/Calendar` is problematic (legacy)

## 11) Immutability & thread safety

* How to design immutable classes (defensive copies, final fields)
* Deep vs shallow immutability (collections fields)
* Safe publication (final fields, static init, volatile, synchronization)

## 12) Testing & maintainability (senior expectations)

* Unit vs integration tests (what to mock, what not to)
* Testability design: dependency injection, pure functions
* Common Mockito pitfalls (stubbing final methods, argument matchers)
* Refactoring discipline and backward compatibility

---

### Quick “senior screening” lightning questions

* Why can two equal objects have different hashCodes? (They **must not**.)
* Explain why `volatile` doesn’t make `i++` safe.
* How does `HashMap` behave when key’s `hashCode()` changes after insertion?
* Difference between `Collections.synchronizedMap()` and `ConcurrentHashMap`.
* Why can `StringBuilder` be unsafe across threads?
* What happens when you catch `Exception` broadly in a library method?

If you want, tell me your target stack (Java 8 vs 17/21, Spring, Kafka, etc.) and I’ll convert this into a **printable one-page checklist + 20 senior-level Q&A with expected “good answers.”**
