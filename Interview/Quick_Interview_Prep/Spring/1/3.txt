
==> Lazy-initialized Beans
https://docs.spring.io/spring-framework/reference/core/beans/dependencies/factory-lazy-init.html

By default, ApplicationContext implementations eagerly create and configure all singleton beans as part of the initialization process. Generally, this pre-instantiation is desirable, because errors in the configuration or surrounding environment are discovered immediately, as opposed to hours or even days later. When this behavior is not desirable, you can prevent pre-instantiation of a singleton bean by marking the bean definition as being lazy-initialized. A lazy-initialized bean tells the IoC container to create a bean instance when it is first requested, rather than at startup.

```
@Bean
@Lazy
ExpensiveToCreateBean lazy() {
	return new ExpensiveToCreateBean();
}

@Bean
AnotherBean notLazy() {
	return new AnotherBean();
}
```




## Why it can feel “undesirable”

Lazy init **pushes failures later**:

* bad config (missing URL/credentials)
* missing classes
* network failures on creating clients
* mis-wiring (bean creation exceptions)

So for **core infrastructure** (DataSource, Kafka clients, security config, etc.), **fail-fast at startup is usually better**.

---

## Real-world use cases where lazy init is genuinely useful

### 1) Faster startup / lower memory (especially large apps)

If your app has dozens/hundreds of beans, some heavy (mappers, caches, clients, big object graphs), lazy init can:

* reduce cold-start time (useful for local dev, tests, serverless-ish workloads)
* reduce memory upfront

**Common in dev/test**: `spring.main.lazy-initialization=true` helps iteration speed.

### 2) Optional integrations / “only used in some flows”

Example: you have code paths that are rarely hit:

* “export to PDF” module
* an admin-only feature
* integration with a third-party API used only sometimes

Lazy init avoids paying startup cost if that feature isn’t used.

### 3) Break or mitigate circular dependencies (sometimes)

`@Lazy` can be a practical workaround to break cycles by injecting a proxy.
Not the “best design”, but it can help when refactoring is expensive.

### 4) Avoid doing expensive I/O at startup

Some beans do network calls on creation (bad idea, but common):

* secrets manager calls
* service discovery lookups
* building large caches by calling remote services

Lazy init can avoid **blocking startup** and let you control when that initialization happens (or warm it up explicitly later).

### 5) Multi-tenant / per-tenant heavy objects

If some tenants rarely use a feature, lazy construction prevents building all tenant-specific heavy beans at startup.

---

## Tradeoffs and pitfalls (important)

* **First request latency spike**: the first call that triggers the bean pays the init cost.
* **Deferred failures**: your main concern—misconfig may show up later.
* **Proxy surprises**: `@Lazy` at injection often injects a proxy; edge cases with final classes/methods, equals/hashCode, etc.
* **Concurrency**: first-use initialization is synchronized internally, but you can still get “thundering herd” latency if many requests hit at once.

---

## Best practice: “Fail fast for core, lazy for edge”

A good senior answer pattern is:

✅ **Eager init** (fail-fast) for:

* DB/DataSource, migrations
* Kafka producers/consumers if required for core
* security/authn/authz
* anything required for readiness

✅ **Lazy init** for:

* optional/rare flows
* heavy but non-critical components
* dev/test speed improvements

---
---
____________________________________________________________________________________________
