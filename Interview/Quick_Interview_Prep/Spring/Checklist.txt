
==> chatgpt:  Here are **25 senior-level Spring + Spring Boot interview Q&A** with the kind of answers that usually score well (clear, practical, with pitfalls).

---

## Core Spring (DI, Beans, AOP)

### 1) What problem does Spring DI actually solve?

**Good answer:** It externalizes object creation/wiring so components depend on **interfaces/contracts**, not constructors or factories scattered everywhere. It improves **testability** (swap beans), **modularity**, and enables cross-cutting features (AOP, transactions) because Spring can wrap beans in proxies.

### 2) `@Component` vs `@Service` vs `@Repository` — any real difference?

**Good answer:** Functionally they’re all stereotypes of `@Component`. But:

* `@Repository` adds **exception translation** for persistence exceptions.
* `@Service`/`@Component` are mostly semantic for readability and tooling.

### 3) How does Spring resolve which bean to inject when multiple exist?

**Good answer:** By type first; if multiple candidates:

* `@Primary` wins (default choice)
* `@Qualifier` is explicit
* bean name matches parameter name (in some cases)
  If still ambiguous → `NoUniqueBeanDefinitionException`.

### 4) What is a Spring proxy and why does it matter?

**Good answer:** Many features (AOP, `@Transactional`, `@Async`, `@Cacheable`) work by wrapping beans with **proxies** that intercept method calls. It matters because:

* **Self-invocation** (calling another method inside same class) bypasses proxy → annotation won’t apply.
* Final classes/methods and private methods can limit proxying (depending on proxy type).

### 5) JDK dynamic proxies vs CGLIB proxies?

**Good answer:**

* JDK proxy: interfaces only
* CGLIB: subclass-based, works without interface (but can’t proxy final classes/methods)
  Boot usually picks sensible defaults, but understanding helps debug weird AOP/transaction issues.

### 6) Bean lifecycle hooks you’d use in real systems?

**Good answer:** `@PostConstruct` for initialization after injection, `@PreDestroy` for cleanup; or implement `InitializingBean/DisposableBean` (less preferred). For more control: `BeanPostProcessor`.

### 7) Common bean scopes and where they make sense?

**Good answer:** Default is singleton. Others: `prototype`, `request`, `session`.

* Use `request/session` in web apps for request-scoped data (often with proxies).
* Avoid `prototype` unless you manage lifecycle yourself.

---

## Transactions (critical senior area)

### 8) How does `@Transactional` work?

**Good answer:** Through AOP proxy interception. It starts/joins a transaction before method execution and commits/rolls back after. Works only when calling through the proxy (so self-invocation is a common pitfall).

### 9) Default rollback rules?

**Good answer:** Rolls back on **unchecked** exceptions (`RuntimeException`, `Error`) by default, not on checked exceptions unless configured (`rollbackFor=...`).

### 10) Propagation types you should know (and real use)?

**Good answer:**

* `REQUIRED` default: join existing or create new
* `REQUIRES_NEW`: suspend current, start new (use for audit logging that must commit independently)
* `NESTED`: savepoint-based (depends on DB/support)

### 11) Isolation levels—how would you explain them simply?

**Good answer:** They control read phenomena:

* `READ_COMMITTED` avoids dirty reads
* `REPEATABLE_READ` avoids non-repeatable reads
* `SERIALIZABLE` strongest, most locking
  In practice, choose the DB default unless there’s a proven anomaly.

### 12) Biggest `@Transactional` gotchas?

**Good answer:** self-invocation, non-public methods, catching exceptions and swallowing them (no rollback), doing long-running network calls inside a TX, lazy-loading outside a TX, and mixing reactive with blocking transactions incorrectly.

---

## Spring Boot (Auto-config, Properties, Actuator)

### 13) What is Spring Boot auto-configuration?

**Good answer:** Boot conditionally creates beans based on classpath, properties, and existing beans. It’s “convention over configuration” but still overrideable via `@Bean`, properties, or exclusions.

### 14) How do you debug “why is this bean created / not created”?

**Good answer:** Use:

* `--debug` (auto-config report)
* Actuator `/actuator/conditions` (if enabled)
* Check `@Conditional*` and classpath dependencies

### 15) `@ConfigurationProperties` vs `@Value`?

**Good answer:** `@ConfigurationProperties` is better for groups of related config, type-safe binding, validation, IDE metadata. `@Value` is okay for one-offs but becomes brittle and harder to test.

### 16) Profiles and config precedence—how do you reason about it?

**Good answer:** Boot reads properties from multiple sources; overrides come from higher precedence (e.g., command-line/env often override files). Profiles layer config (`application-prod.yml`) on top. Knowing precedence prevents “works locally, not in prod” issues.

### 17) Why use Actuator in production?

**Good answer:** Health checks, metrics, tracing info, env/config insights, thread dumps, logs level changes (if enabled). It’s essential for observability and platform readiness (K8s liveness/readiness).

---

## Web / REST

### 18) `@Controller` vs `@RestController`?

**Good answer:** `@RestController = @Controller + @ResponseBody` for JSON responses by default. `@Controller` is typically for views/templating.

### 19) How do you handle errors consistently in REST APIs?

**Good answer:** `@ControllerAdvice` + `@ExceptionHandler` returning a standard error body (problem details, code, message, correlationId). Avoid leaking stack traces; map validation errors cleanly.

### 20) Validation: `@Valid` vs `@Validated`?

**Good answer:** `@Valid` triggers Bean Validation; `@Validated` also supports **validation groups** and is commonly used at service layer. Handle `MethodArgumentNotValidException` (body) and `ConstraintViolationException` (params).

---

## Data (JPA/Hibernate + Mongo, etc.)

### 21) Explain N+1 and how you fix it.

**Good answer:** N+1 happens when loading a list triggers lazy loads per row. Fix via fetch joins, entity graphs, batch fetching, or DTO projections. Measure with SQL logs and verify query counts.

### 22) Lazy loading vs transactional boundaries?

**Good answer:** Lazy fields require an open persistence context (usually within a transaction). Accessing lazies outside → `LazyInitializationException`. Better: design DTOs and fetch exactly what you need in the service layer.

### 23) Repository pattern in Spring Data—what’s “free” and what isn’t?

**Good answer:** CRUD and query derivation are “free”, but you still need to manage domain boundaries, transaction semantics, custom queries, paging/sorting, and performance. For complex cases use `@Query`, Specifications, Querydsl, or `EntityManager`/Template APIs.

---

## Security (Spring Security / OAuth2)

### 24) How does Spring Security flow through the app?

**Good answer:** A chain of servlet filters processes requests (authentication, authorization, CSRF, etc.). Authentication sets a `SecurityContext`. Authorization checks happen later via config or method security. Debugging often means inspecting the filter chain order and the active `Authentication`.

### 25) Common pitfalls in OAuth2/JWT resource servers?

**Good answer:** Wrong issuer/audience, clock skew, missing JWKS config, confusing “scope” vs “role/authority” mapping, and forgetting that authorities often come as `SCOPE_xxx`. Also: don’t treat JWT as “session”; verify signature and claims every request.

---

If you want, tell me your focus (e.g., **Spring MVC + JPA**, **Kafka**, **OAuth2 with Entra/Okta**, **microservices + Resilience4j**, **reactive WebFlux**) and I’ll generate a **targeted set of 30 questions** in that area with deeper follow-ups and code-level gotchas.
