==> Here are practical examples demonstrating `Objects::nonNull`:

```
import java.util.Arrays;
import java.util.List;
import java.util.Objects;

public class ObjectsNonNullDemo {
    public static void main(String[] args) {

        // Example 1: Filter out null values from a stream
        List<String> names = Arrays.asList("Alice", null, "Bob", null, "Charlie", "");

        List<String> nonNullNames = names.stream()
                .filter(Objects::nonNull)  // Remove nulls
                .toList();

        System.out.println("Original: " + names);
        System.out.println("Non-null: " + nonNullNames);
        // Output: [Alice, Bob, Charlie, ]


        // Example 2: Count non-null elements
        long nonNullCount = names.stream()
                .filter(Objects::nonNull)
                .count();

        System.out.println("\nNon-null count: " + nonNullCount); // 4


        // Example 3: Process only non-null values
        System.out.println("\nProcessing non-null names:");
        names.stream()
                .filter(Objects::nonNull)
                .map(String::toUpperCase)
                .forEach(System.out::println);


        // Example 4: Clean up a list of optional data
        List<Integer> numbers = Arrays.asList(1, null, 2, null, 3, 4, null, 5);

        int sum = numbers.stream()
                .filter(Objects::nonNull)
                .mapToInt(Integer::intValue)
                .sum();

        System.out.println("\nNumbers: " + numbers);
        System.out.println("Sum of non-null: " + sum); // 15


        // Example 5: Combine with other predicates
        List<String> filtered = names.stream()
                .filter(Objects::nonNull)           // First remove nulls
                .filter(s -> !s.isEmpty())          // Then remove empty strings
                .filter(s -> s.startsWith("A") || s.startsWith("B"))
                .toList();

        System.out.println("\nFiltered (A or B): " + filtered); // [Alice, Bob]


        // Example 6: Real-world use case - processing user input
        List<String> userInputs = Arrays.asList(
                "john@example.com",
                null,  // User skipped
                "invalid-email",
                null,
                "jane@example.com"
        );

        List<String> validEmails = userInputs.stream()
                .filter(Objects::nonNull)
                .filter(email -> email.contains("@"))
                .toList();

        System.out.println("\nValid emails: " + validEmails);
    }
}
```

#### Output:
```
Original: [Alice, null, Bob, null, Charlie, ]
Non-null: [Alice, Bob, Charlie, ]

Non-null count: 4

Processing non-null names:
ALICE
BOB
CHARLIE


Numbers: [1, null, 2, null, 3, 4, null, 5]
Sum of non-null: 15

Filtered (A or B): [Alice, Bob]

Valid emails: [john@example.com, jane@example.com]
```

**Why use `Objects::nonNull` instead of a lambda?**

```java
// These are equivalent, but the method reference is cleaner:
.filter(Objects::nonNull)
.filter(x -> x != null)

// The method reference is:
// - More concise and readable
// - Shows intent clearly
// - Follows functional programming style
```

`Objects::nonNull` is particularly useful in stream pipelines where you want to defensively remove null values before further processing!

---
---
______________________________________________________________________________________________________________

==> demonstrate replacing traditional null-checks with `Objects::nonNull` and `Objects::isNull` methods from Java's `java.util.Objects` class.

## Traditional Null-Checks vs Objects Methods

### Example 1: Filtering with `Objects::nonNull`

**Before (traditional null-check):**
```
import java.util.Arrays;
import java.util.List;

public class NullCheckExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Alice", null, "Bob", null, "Charlie");

        // Traditional approach
        List<String> nonNullNames = names.stream()
                .filter(name -> name != null)
                .toList();

        System.out.println(nonNullNames); // [Alice, Bob, Charlie]
    }
}
```

**After (using Objects::nonNull):**
```
import java.util.Arrays;
import java.util.List;
import java.util.Objects;

public class NullCheckExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Alice", null, "Bob", null, "Charlie");
        
        // Using Objects::nonNull method reference
        List<String> nonNullNames = names.stream()
            .filter(Objects::nonNull)
            .toList();
        
        System.out.println(nonNullNames); // [Alice, Bob, Charlie]
    }
}
```

### Example 2: Finding null values with `Objects::isNull`

**Before (traditional null-check):**
```
import java.util.Arrays;
import java.util.List;

public class FindNullExample {
    public static void main(String[] args) {
        List<String> items = Arrays.asList("Apple", null, "Banana", null, "Cherry");
        
        // Traditional approach
        long nullCount = items.stream()
            .filter(item -> item == null)
            .count();
        
        System.out.println("Null count: " + nullCount); // Null count: 2
    }
}
```

**After (using Objects::isNull):**
```
import java.util.Arrays;
import java.util.List;
import java.util.Objects;

public class FindNullExample {
    public static void main(String[] args) {
        List<String> items = Arrays.asList("Apple", null, "Banana", null, "Cherry");
        
        // Using Objects::isNull method reference
        long nullCount = items.stream()
            .filter(Objects::isNull)
            .count();
        
        System.out.println("Null count: " + nullCount); // Null count: 2
    }
}
```

### Example 3: Comprehensive Example

```
public record Person(String name, Integer age) {

    @Override
    public String toString() {
        return "Person{name='" + name + "', age=" + age + "}";
    }
}

import java.util.Arrays;
import java.util.List;
import java.util.Objects;

public class ComprehensiveExample {

    public static void main(String[] args) {
        List<Person> people = Arrays.asList(
                new Person("Alice", 30),
                null,
                new Person("Bob", null),
                new Person("Charlie", 25),
                null,
                new Person("Diana", 28)
        );

        System.out.println("=== Filter out null Person objects ===");
        List<Person> validPeople = people.stream()
                .filter(Objects::nonNull)  // Instead of: .filter(p -> p != null)
                .toList();
        validPeople.forEach(System.out::println);

        System.out.println("\n=== Count null Person objects ===");
        long nullPersonCount = people.stream()
                .filter(Objects::isNull)  // Instead of: .filter(p -> p == null)
                .count();
        System.out.println("Null persons: " + nullPersonCount);

        System.out.println("\n=== Filter people with non-null ages ===");
        List<Person> peopleWithAge = people.stream()
                .filter(Objects::nonNull)
                .filter(p -> Objects.nonNull(p.age()))
                .toList();
        peopleWithAge.forEach(System.out::println);

        System.out.println("\n=== Find people with null ages ===");
        List<Person> peopleWithoutAge = people.stream()
                .filter(Objects::nonNull)
                .filter(p -> Objects.isNull(p.age()))
                .toList();
        peopleWithoutAge.forEach(System.out::println);
    }
}
```

**Output:**
```
=== Filter out null Person objects ===
Person{name='Alice', age=30}
Person{name='Bob', age=null}
Person{name='Charlie', age=25}
Person{name='Diana', age=28}

=== Count null Person objects ===
Null persons: 2

=== Filter people with non-null ages ===
Person{name='Alice', age=30}
Person{name='Charlie', age=25}
Person{name='Diana', age=28}

=== Find people with null ages ===
Person{name='Bob', age=null}
```

## Benefits

1. **More concise**: Method references are shorter than lambda expressions
2. **More readable**: Intent is clearer with `Objects::nonNull` vs `x -> x != null`
3. **Type-safe**: Works with any reference type
4. **Consistent**: Part of the standard library, familiar to Java developers
5. **Better for streams**: Perfect for functional-style programming with streams

## When to Use

- ✅ Use in **stream operations** (filter, map, etc.)
- ✅ Use when passing **predicates as arguments**
- ✅ Use in **functional interfaces** and lambda contexts
- ⚠️ For simple if-statements, traditional null-checks (`if (x == null)`) are often more readable

---
---
______________________________________________________________________________________________________________




