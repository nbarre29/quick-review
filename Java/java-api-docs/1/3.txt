==> * `Collections.sort(List)` → sorts using **natural ordering** (`Comparable`)
* `Collections.sort(List, Comparator)` → sorts using a **custom rule** (`Comparator`)

https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/Collections.html#sort(java.util.List)
https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/Collections.html#sort(java.util.List,java.util.Comparator)

---

## Example 1: Integers (natural vs custom)

```
import java.util.*;

public class SortDemo1 {
    public static void main(String[] args) {
        List<Integer> nums = new ArrayList<>(Arrays.asList(40, 10, 30, 20));

        // 1) sort(List) -> natural order (ascending for Integer)
        Collections.sort(nums);
        System.out.println("Natural (ascending): " + nums);  // Natural (ascending): [10, 20, 30, 40]

        // 2) sort(List, Comparator) -> custom order (descending here)
        Collections.sort(nums, Comparator.reverseOrder());
        System.out.println("Custom (descending): " + nums);  // Custom (descending): [40, 30, 20, 10]
    }
}


#### MyNotes
a) `Collections.sort(nums, Comparator.reverseOrder());`  can be replaced with `nums.sort(Comparator.reverseOrder());`

---

## Example 2: Custom objects (Comparator is required unless you implement Comparable)

```
public record Student(String name, int marks) {

}


import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public class SortDemo2 {
    public static void main(String[] args) {
        List<Student> students = new ArrayList<>();
        students.add(new Student("Zara", 85));
        students.add(new Student("Amit", 92));
        students.add(new Student("Bob", 85));

        // Collections.sort(students) // won't work here because Student is not Comparable

        // sort(List, Comparator) -> sort by marks ascending, then name ascending
        Collections.sort(students,
                Comparator.comparingInt((Student s) -> s.marks())
                        .thenComparing(s -> s.name())
        );

        System.out.println(students);
    }
}

```

#### Output:
```
[Student[name=Bob, marks=85], Student[name=Zara, marks=85], Student[name=Amit, marks=92]]
```

#### MyNotes:
a) The code does sort by marks ascending, then name ascending.

Looking at your data:
- Zara: 85
- Amit: 92
- Bob: 85

After sorting:
1. Bob: 85 (marks ascending)
2. Zara: 85 (marks ascending, same as Bob)
3. Amit: 92

For Bob and Zara (both have 85 marks), it then sorts by name ascending: "Bob" comes before "Zara" alphabetically.

The output shows names in **ascending** order when marks are equal, not descending. If you want descending order by name, you would need:

```
Collections.sort(students,
        Comparator.comparingInt((Student s) -> s.marks())
                .thenComparing(Comparator.comparing(Student::name).reversed())
);
```


b) 
```
Collections.sort(students,
                Comparator.comparingInt((Student s) -> s.marks())
                        .thenComparing(s -> s.name())
        );
```

Above code can be simplified to below:
```
students.sort(Comparator.comparingInt(Student::marks)
                .thenComparing(Student::name));
```
---

### Quick rule

* Use `sort(list)` when elements already have a natural order (`Integer`, `String`, or your class implements `Comparable`)
* Use `sort(list, comparator)` when you want **a different ordering** (descending, by a field, multiple fields, etc.)

---
---
______________________________________________________________________________________________________________

==> getOrDefault:  https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/Map.html#getOrDefault(java.lang.Object,V)

```
public record Person(String name, int age) {
}


import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class PeopleByCityExample {
    public static void main(String[] args) {
        Map<String, List<Person>> peopleByCity = new HashMap<>();

        // Populate map
        peopleByCity.put("NYC", Arrays.asList(
                new Person("Alice", 17),
                new Person("Bob", 19),
                new Person("Charlie", 25)
        ));

        peopleByCity.put("LA", Arrays.asList(
                new Person("Dave", 18),
                new Person("Eve", 30)
        ));

        // safely get list for NYC, filter age > 18, collect to a new list
        List<Person> adultsInNYC = peopleByCity
                .getOrDefault("NYC", List.of())
                .stream()
                .filter(person -> person.age() > 18)
                .toList();

        System.out.println("Adults in NYC (>18): " + adultsInNYC);

        // Demonstrate getOrDefault when city doesn't exist (no NPE, returns empty list)
        List<Person> adultsInChicago = peopleByCity
                .getOrDefault("Chicago", List.of())
                .stream()
                .filter(person -> person.age() > 18)
                .toList();

        System.out.println("Adults in Chicago (>18): " + adultsInChicago);


    }
}
```

#### Output:
```
Adults in NYC (>18): [Person[name=Bob, age=19], Person[name=Charlie, age=25]]
Adults in Chicago (>18): []
```


The `getOrDefault` method provides several advantages:

**1. Null Safety**
- Eliminates `NullPointerException` when a key doesn't exist
- No need for explicit null checks before processing

**2. Cleaner Code**
- Avoids verbose `if-else` or ternary operators
- Reduces boilerplate code

**3. Method Chaining**
- Allows direct streaming/processing without intermediate checks
- Maintains fluent API style

**Without getOrDefault:**
```java
List<Person> adults = peopleByCity.get("Chicago");
if (adults != null) {
    adults = adults.stream()
        .filter(person -> person.age() > 18)
        .toList();
} else {
    adults = new ArrayList<>();
}
```

**With getOrDefault:**
```java
List<Person> adults = peopleByCity
    .getOrDefault("Chicago", List.of())
    .stream()
    .filter(person -> person.age() > 18)
    .toList();
```

**4. Immutable Defaults**
- `List.of()` returns an immutable empty list, preventing accidental modifications
- More memory-efficient than creating new `ArrayList()` instances

**5. Type Safety**
- Default value matches the expected type, avoiding casting issues


#### MyNotes:
a) Suggest some better variable names for `peopleByCity`

Based on the context of your code, here are some better variable names for `peopleByCity`:

- **`personsByCity`** - more grammatically correct (singular noun for the type)
- **`cityResidents`** - concise and descriptive
- **`cityPopulation`** - emphasizes the demographic aspect
- **`residents`** - simpler, if the city context is obvious

I'd recommend **`personsByCity`** since it follows Java naming conventions better (the map contains `Person` objects, so the singular form is preferred):

```java
Map<String, List<Person>> personsByCity = new HashMap<>();
```

This aligns with common Java collection naming patterns where you use the singular form of the element type followed by the grouping criterion (e.g., `employeesByDepartment`, `ordersByCustomer`).

---
---
--------------------------------------------------------------------------------------------------------------

==> getOrDefault: Building a result map with defaults

```
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class ResultMapWithDefaultsExample {

    public static void main(String[] args) {
        // Existing data (some keys may be missing)
        Map<String, List<String>> existingCategories = new HashMap<>();
        existingCategories.put("fruits", List.of("apple", "banana"));
        existingCategories.put("dairy", List.of("milk", "cheese"));
        // note: "vegetables" is intentionally missing

        // Keys we want in the result map no matter what
        List<String> keys = List.of("fruits", "vegetables", "dairy");

        // Build result map with defaults (empty list if missing)
        Map<String, List<String>> result = keys.stream()
                .collect(Collectors.toMap(
                        key -> key,
                        key -> existingCategories.getOrDefault(key, List.of())
                ));

        System.out.println("existingCategories = " + existingCategories);
        System.out.println("keys       = " + keys);
        System.out.println("result     = " + result);
    }
}
```

#### Output:
```
existingCategories = {fruits=[apple, banana], dairy=[milk, cheese]}
keys       = [fruits, vegetables, dairy]
result     = {fruits=[apple, banana], vegetables=[], dairy=[milk, cheese]}
```

---
---
--------------------------------------------------------------------------------------------------------------

==> getOrDefault:  Score tracking with defaults
```
import java.util.HashMap;
import java.util.Map;

public class ScoreTrackingWithDefaultsExample {

    public static void main(String[] args) {
        Map<String, Integer> playerScores = new HashMap<>();
        playerScores.put("Alice", 100);
        playerScores.put("Bob", 85);

        int aliceScore = playerScores.getOrDefault("Alice", 0);      // 100
        int charlieScore = playerScores.getOrDefault("Charlie", 0);  // 0 (new player)

        System.out.println("Alice score   : " + aliceScore);
        System.out.println("Charlie score : " + charlieScore);

        // Optional: show the map (Charlie is NOT added by getOrDefault)
        System.out.println("playerScores map: " + playerScores);
    }
}
```

#### Output:
```
Alice score   : 100
Charlie score : 0
playerScores map: {Bob=85, Alice=100}
```

---
---
--------------------------------------------------------------------------------------------------------------

==> getOrDefault:  With computeIfAbsent for mutable lists

```
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ComputeIfAbsentMutableListExample {

    public static void main(String[] args) {
        Map<String, List<String>> map = new HashMap<>();

        // Don't do this - List.of() is immutable (would throw UnsupportedOperationException)
        // map.getOrDefault("key", List.of()).add("value");

        // Do this instead: computeIfAbsent creates a mutable list when the key is missing
        map.computeIfAbsent("key", k -> new ArrayList<>()).add("value");
        map.computeIfAbsent("key", k -> new ArrayList<>()).add("value2"); // adds to same list

        // Another key
        map.computeIfAbsent("city", k -> new ArrayList<>()).add("NYC");

        System.out.println("map = " + map); // {key=[value, value2], city=[NYC]}

        // Show it really is mutable
        map.get("key").remove("value");
        System.out.println("after remove = " + map); // {key=[value2], city=[NYC]}
    }
}
```

#### Output:
```
map = {city=[NYC], key=[value, value2]}
after remove = {city=[NYC], key=[value2]}
```

#### MyNotes:

a) `List.of()` returns an immutable list, so calling `add()` on it would throw an `UnsupportedOperationException`.

**Better explanation:**

"`List.of()` returns an **immutable** list. If you need to add elements to the list, use `new ArrayList<>()` instead."

The key points:
- `List.of()` creates an immutable list (whether empty or not)
- Any modification attempt (add, remove, set) throws `UnsupportedOperationException`
- `new ArrayList<>()` creates a mutable list that supports modifications

Your example code correctly demonstrates this with `computeIfAbsent`, which creates a new mutable `ArrayList` only when the key is absent, allowing safe additions to the list.


**Important note:** `List.of()` returns an **immutable** empty list. If you need to add elements to the returned list, use `new ArrayList<>()`

---
---
--------------------------------------------------------------------------------------------------------------
==> getOrDefault: Grouping with default empty lists

```
public enum Department {
    ENGINEERING, HR, SALES, FINANCE
}


public record Employee(String name, Department department) {
}

import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class GroupingWithDefaultEmptyListsExample {
    public static void main(String[] args) {
        Map<Department, List<Employee>> employeesByDept = new HashMap<>();

        // Add some departments with employees
        employeesByDept.put(Department.ENGINEERING, List.of(
                new Employee("Alice", Department.ENGINEERING),
                new Employee("Bob", Department.ENGINEERING)
        ));

        employeesByDept.put(Department.HR, List.of(
                new Employee("Charlie", Department.HR)
        ));

        // Departments we want to report on (even if missing from map)
        List<Department> allDepartments = List.of(
                Department.ENGINEERING,
                Department.HR,
                Department.SALES,
                Department.FINANCE
        );

        for (Department dept : allDepartments) {
            List<Employee> employees = employeesByDept.getOrDefault(dept, List.of());
            System.out.println(dept + " has " + employees.size() + " employees: " + employees);
        }
    }
}
```

#### Output:
```
ENGINEERING has 2 employees: [Employee[name=Alice, department=ENGINEERING], Employee[name=Bob, department=ENGINEERING]]
HR has 1 employees: [Employee[name=Charlie, department=HR]]
SALES has 0 employees: []
FINANCE has 0 employees: []
```

---
---
--------------------------------------------------------------------------------------------------------------
==> getOrDefault: Safe navigation pattern

```
public record Employee(String name, int salary) {
}

import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class SafeNavigationPatternExample {

    // Example data source
    private Map<String, List<Employee>> getEmployeeMap() {
        Map<String, List<Employee>> empMap = new HashMap<>();
        empMap.put("Engineering", List.of(
                new Employee("Alice", 120000),
                new Employee("Bob", 130000)
        ));
        empMap.put("HR", List.of(
                new Employee("Charlie", 90000)
        ));
        // Note: "Sales" intentionally not present to show safe default behavior
        return empMap;
    }

    // safe navigation using getOrDefault + stream + sum
    public int getTotalSalary(String department) {
        Map<String, List<Employee>> empMap = getEmployeeMap();

        return empMap.getOrDefault(department, List.of())
                .stream()
                .mapToInt(Employee::salary)
                .sum();
    }

    public static void main(String[] args) {

        SafeNavigationPatternExample example = new SafeNavigationPatternExample();

        System.out.println("Engineering total salary: " + example.getTotalSalary("Engineering"));
        System.out.println("HR total salary         : " + example.getTotalSalary("HR"));
        System.out.println("Sales total salary      : " + example.getTotalSalary("Sales")); // 0 (missing dept)

    }
}
```

#### Output:
```
Engineering total salary: 250000
HR total salary         : 90000
Sales total salary      : 0
```

---
---
--------------------------------------------------------------------------------------------------------------
==> getOrDefault: Role-based permissions with defaults

```
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class RoleBasedPermissionsWithDefaultsExample {

    public static void main(String[] args) {
        Map<String, Set<String>> rolePermissions = new HashMap<>();
        rolePermissions.put("admin", Set.of("read", "write", "delete"));
        rolePermissions.put("user", Set.of("read"));

        // If the role exists, you get its permissions
        Set<String> adminPerms = rolePermissions.getOrDefault("admin", Set.of());

        // If the role does NOT exist, you get the default you provide
        Set<String> guestPerms = rolePermissions.getOrDefault("guest", Set.of("read"));

        System.out.println("Admin permissions: " + adminPerms);
        System.out.println("Guest permissions: " + guestPerms);

        // Optional: show that Set.of(...) is immutable (would throw UnsupportedOperationException)
        // guestPerms.add("write");
    }
}
```

#### Output:
```
Admin permissions: [delete, read, write]
Guest permissions: [read]
```

#### MyNotes:
a) Suggest a better for `rolePermissions`

Based on the context of your code, here are some better variable names for `rolePermissions`:

- **`permissionsByRole`** - follows the common "by" pattern, emphasizing the grouping
- **`roleToPermissions`** - explicitly shows the mapping relationship
- **`permissions`** - simpler, if the role context is clear
- **`accessRights`** - more domain-specific alternative

I'd recommend **`permissionsByRole`** since it follows Java naming conventions and makes the map's structure clearer:

```java
Map<String, Set<String>> permissionsByRole = new HashMap<>();
```

This aligns with the pattern used in your previous examples (`personsByCity`, `sourceCategories`) where the value type comes first, followed by the grouping key.


b) Refactoring: Extract string literals and permissions sets into constants, making the code more maintainable and reducing the risk of typos:

In IntelliJ, use the shortcut `Ctrl + Alt + C` or right click -> Refactor -> Introduce Constant


```
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class RoleBasedPermissionsWithDefaultsExample {

    // ---- Role constants (avoid typos like "admn") ----
    public static final String ADMIN = "admin";
    public static final String USER = "user";
    public static final String GUEST = "guest";

    // ---- Reusable permission sets ----
    public static final Set<String> ADMIN_PERMISSIONS = Set.of("read", "write", "delete");
    public static final Set<String> USER_PERMISSIONS = Set.of("read");
    public static final Set<String> GUEST_DEFAULT_PERMISSIONS = Set.of("read");

    public static void main(String[] args) {
        Map<String, Set<String>> rolePermissions = new HashMap<>();
        rolePermissions.put(ADMIN, ADMIN_PERMISSIONS);
        rolePermissions.put(USER, USER_PERMISSIONS);

        // If the role exists, you get its permissions
        Set<String> adminPerms = rolePermissions.getOrDefault(ADMIN, Set.of());

        // If the role does NOT exist, you get the default you provide
        Set<String> guestPerms = rolePermissions.getOrDefault(GUEST, GUEST_DEFAULT_PERMISSIONS);

        System.out.println("Admin permissions: " + adminPerms);
        System.out.println("Guest permissions: " + guestPerms);

        // Optional: show that Set.of(...) is immutable (would throw UnsupportedOperationException)
        // guestPerms.add("write");
    }
}
```

---
---
--------------------------------------------------------------------------------------------------------------
==> getOrDefault: demonstrate with EnumMap

```
public enum Day {
        MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
}

import java.util.EnumMap;

public class EnumMapExample {

    public static void main(String[] args) {

        EnumMap<Day, String> timetable = new EnumMap<>(Day.class);

        // Step 3: Put values into the map
        timetable.put(Day.MONDAY, "Workout");
        timetable.put(Day.TUESDAY, "Team Meeting");
        timetable.put(Day.WEDNESDAY, "Project Work");
        timetable.put(Day.THURSDAY, "Learning Session");
        timetable.put(Day.FRIDAY, "Code Review");

        // Print the timetable
        // we can use `getOrDefault` to simplify retrieval with a default value
        // eliminates the explicit null check by providing a default value when the key is not found in the map.
        for (Day day : Day.values()) {
            String activity = timetable.getOrDefault(day, "No activities planned");
            System.out.println(day + ": " + activity);
        }

    }
}
```

#### Output:
```
MONDAY: Workout
TUESDAY: Team Meeting
WEDNESDAY: Project Work
THURSDAY: Learning Session
FRIDAY: Code Review
SATURDAY: No activities planned
SUNDAY: No activities planned
```

#### MyNotes:
a) Without getOrDefault:
```
for (Day day : Day.values()) {
            String activity = timetable.get(day);
            if (activity != null) {
                System.out.println(day + ": " + activity);
            } else {
                System.out.println(day + ": No activities planned");
            }
        }
```

b) This method was introduced in Java 8 to help avoid explicit null checks.

Key Points:

• Null Avoidance: It provides a clean way to handle missing keys without manually checking for null and risking a NullPointerException.
• No Map Modification: The  method only retrieves a value; it does not add the defaultValue to the map if the key is missing. 
• Alternative: If you need to compute a value and automatically insert it into the map if the key is absent, you should use computeIfAbsent() instead. 
• Availability: This method is available in Java 8 and later. 

---
---
--------------------------------------------------------------------------------------------------------------

==> getOrDefault: count word occurrences in a string

```
import java.util.HashMap;
import java.util.Map;

public class WordCountDemo {
    public static void main(String[] args) {
        Map<String, Integer> wordCounts = new HashMap<>();
        String text = "apple banana apple orange banana apple";
        String[] words = text.split(" ");

        for (String word : words) {
            // Get the current count for the word, or 0 if not present, then increment
            wordCounts.put(word, wordCounts.getOrDefault(word, 0) + 1);
        }

        System.out.println("Word counts: " + wordCounts);

    }
}
```

#### Output:
```
Word counts: {banana=2, orange=1, apple=3}
```

MyNotes: 
a)  You can iterate directly over `text.split(" ")` without storing it in a variable.

**Direct iteration:**
```
for (String word : text.split(" ")) {
            // Get the current count for the word, or 0 if not present, then increment
            wordCounts.put(word, wordCounts.getOrDefault(word, 0) + 1);
        }
```

**Performance Impact:**
- **No significant difference** for single use - the array is created once either way
- **Better readability** - eliminates an unnecessary variable when used only once
- **Worse if reused** - if you need to iterate multiple times, storing it in a variable avoids re-splitting

In your case, since the array is only used once, iterating directly is **fine and preferred** for cleaner code. The performance difference is negligible.

However, if you later need to access `words.length` or iterate multiple times, keep the variable to avoid redundant string splitting operations.


b) without getOrDefault
```
for (String word : text.split(" ")) {
            if (wordCounts.containsKey(word)) {
                wordCounts.put(word, wordCounts.get(word) + 1);
            } else {
                wordCounts.put(word, 1);
            }
        }
```
---
---
--------------------------------------------------------------------------------------------------------------

==> In the above code for counting word frequencies, `Map` is **not** overkill—it's the right tool. The `getOrDefault()` pattern is clean and efficient the standard, idiomatic approach in Java. However, there are a few alternatives depending on your needs:

## Why Map is Actually Good Here

The `HashMap` approach is:
- **Simple and readable** - clear what's happening
- **Efficient** - O(1) average lookups and insertions
- **Standard practice** - any Java developer will understand it immediately

## Other Alternatives 

**1. Use `merge()` - more concise:**
```
import java.util.HashMap;
import java.util.Map;

public class WordCountDemo {
    public static void main(String[] args) {
        Map<String, Integer> wordCounts = new HashMap<>();
        String text = "apple banana apple orange banana apple";

        // 1. Use merge() - more concise:
        for (String word : text.split(" ")) {
            wordCounts.merge(word, 1, Integer::sum);
        }

        System.out.println("Word counts: " + wordCounts);

    }
}
```
This is cleaner but does the same thing under the hood.


**2. Use `compute()` or `computeIfAbsent()`:**
```
import java.util.HashMap;
import java.util.Map;

public class WordCountDemo {
    public static void main(String[] args) {
        Map<String, Integer> wordCounts = new HashMap<>();
        String text = "apple banana apple orange banana apple";

        for (String word : text.split(" ")) {
            wordCounts.compute(word, (k, v) -> v == null ? 1 : v + 1);
        }

        System.out.println("Word counts: " + wordCounts);

    }
}
```


```
import java.util.HashMap;
import java.util.Map;

public class WordCountDemo {
    public static void main(String[] args) {
        Map<String, Integer> wordCounts = new HashMap<>();
        String text = "apple banana apple orange banana apple";

        for (String word : text.split(" ")) {
            wordCounts.computeIfAbsent(word, k -> 0);
            wordCounts.put(word, wordCounts.get(word) + 1);
        }


        System.out.println("Word counts: " + wordCounts);

    }
}
```

**3. Use streams (if you want functional style):**
```java
import java.util.Arrays;
import java.util.Map;
import java.util.stream.Collectors;

public class WordCountDemo {
    public static void main(String[] args) {

        String text = "apple banana apple orange banana apple";

        Map<String, Long> wordCounts = Arrays.stream(text.split(" "))
                .collect(Collectors.groupingBy(w -> w, Collectors.counting()));


        System.out.println("Word counts: " + wordCounts);

    }
}
```
This approach is more functional and concise. Note that the count type is now `Long` instead of `Integer` because `Collectors.counting()` returns `Long` values.


**4. For very simple cases, use an array (if words are limited):**
Only works if you know all possible words in advance—not practical for general text.

## The Verdict

For counting word frequencies, `Map` is **not** overkill—it's the right tool. The `getOrDefault()` pattern is clean and efficient. If anything, consider using `merge()` for slightly more elegance, but what you have is perfectly fine and actually the recommended approach!


---
---
______________________________________________________________________________________________________________
