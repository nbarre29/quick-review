==> * `Collections.sort(List)` → sorts using **natural ordering** (`Comparable`)
* `Collections.sort(List, Comparator)` → sorts using a **custom rule** (`Comparator`)

https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/Collections.html#sort(java.util.List)
https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/Collections.html#sort(java.util.List,java.util.Comparator)

---

## Example 1: Integers (natural vs custom)

```
import java.util.*;

public class SortDemo1 {
    public static void main(String[] args) {
        List<Integer> nums = new ArrayList<>(Arrays.asList(40, 10, 30, 20));

        // 1) sort(List) -> natural order (ascending for Integer)
        Collections.sort(nums);
        System.out.println("Natural (ascending): " + nums);  // Natural (ascending): [10, 20, 30, 40]

        // 2) sort(List, Comparator) -> custom order (descending here)
        Collections.sort(nums, Comparator.reverseOrder());
        System.out.println("Custom (descending): " + nums);  // Custom (descending): [40, 30, 20, 10]
    }
}


#### MyNotes
a) `Collections.sort(nums, Comparator.reverseOrder());`  can be replaced with `nums.sort(Comparator.reverseOrder());`

---

## Example 2: Custom objects (Comparator is required unless you implement Comparable)

```
public record Student(String name, int marks) {

}


import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public class SortDemo2 {
    public static void main(String[] args) {
        List<Student> students = new ArrayList<>();
        students.add(new Student("Zara", 85));
        students.add(new Student("Amit", 92));
        students.add(new Student("Bob", 85));

        // Collections.sort(students) // won't work here because Student is not Comparable

        // sort(List, Comparator) -> sort by marks ascending, then name ascending
        Collections.sort(students,
                Comparator.comparingInt((Student s) -> s.marks())
                        .thenComparing(s -> s.name())
        );

        System.out.println(students);
    }
}

```

#### Output:
```
[Student[name=Bob, marks=85], Student[name=Zara, marks=85], Student[name=Amit, marks=92]]
```

#### MyNotes:
a) The code does sort by marks ascending, then name ascending.

Looking at your data:
- Zara: 85
- Amit: 92
- Bob: 85

After sorting:
1. Bob: 85 (marks ascending)
2. Zara: 85 (marks ascending, same as Bob)
3. Amit: 92

For Bob and Zara (both have 85 marks), it then sorts by name ascending: "Bob" comes before "Zara" alphabetically.

The output shows names in **ascending** order when marks are equal, not descending. If you want descending order by name, you would need:

```
Collections.sort(students,
        Comparator.comparingInt((Student s) -> s.marks())
                .thenComparing(Comparator.comparing(Student::name).reversed())
);
```


b) 
```
Collections.sort(students,
                Comparator.comparingInt((Student s) -> s.marks())
                        .thenComparing(s -> s.name())
        );
```

Above code can be simplified to below:
```
students.sort(Comparator.comparingInt(Student::marks)
                .thenComparing(Student::name));
```
---

### Quick rule

* Use `sort(list)` when elements already have a natural order (`Integer`, `String`, or your class implements `Comparable`)
* Use `sort(list, comparator)` when you want **a different ordering** (descending, by a field, multiple fields, etc.)

---
---
______________________________________________________________________________________________________________

==> getOrDefault:  https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/Map.html#getOrDefault(java.lang.Object,V)

```
public record Person(String name, int age) {
}


import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class PeopleByCityExample {
    public static void main(String[] args) {
        // personsByCity is a better variable name
        Map<String, List<Person>> peopleByCity = new HashMap<>();

        // Populate map
        peopleByCity.put("NYC", Arrays.asList(
                new Person("Alice", 17),
                new Person("Bob", 19),
                new Person("Charlie", 25)
        ));

        peopleByCity.put("LA", Arrays.asList(
                new Person("Dave", 18),
                new Person("Eve", 30)
        ));

        // safely get list for NYC, filter age > 18, collect to a new list
        List<Person> adultsInNYC = peopleByCity
                .getOrDefault("NYC", List.of())
                .stream()
                .filter(person -> person.age() > 18)
                .toList();

        System.out.println("Adults in NYC (>18): " + adultsInNYC);

        // Demonstrate getOrDefault when city doesn't exist (no NPE, returns empty list)
        List<Person> adultsInChicago = peopleByCity
                .getOrDefault("Chicago", List.of())
                .stream()
                .filter(person -> person.age() > 18)
                .toList();

        System.out.println("Adults in Chicago (>18): " + adultsInChicago);


    }
}
```

#### Output:
```
Adults in NYC (>18): [Person[name=Bob, age=19], Person[name=Charlie, age=25]]
Adults in Chicago (>18): []
```


The `getOrDefault` method provides several advantages:

**1. Null Safety**
- Eliminates `NullPointerException` when a key doesn't exist
- No need for explicit null checks before processing

**2. Cleaner Code**
- Avoids verbose `if-else` or ternary operators
- Reduces boilerplate code

**3. Method Chaining**
- Allows direct streaming/processing without intermediate checks
- Maintains fluent API style

**Without getOrDefault:**
```java
List<Person> adults = peopleByCity.get("Chicago");
if (adults != null) {
    adults = adults.stream()
        .filter(person -> person.age() > 18)
        .toList();
} else {
    adults = new ArrayList<>();
}
```

**With getOrDefault:**
```java
List<Person> adults = peopleByCity
    .getOrDefault("Chicago", List.of())
    .stream()
    .filter(person -> person.age() > 18)
    .toList();
```

**4. Immutable Defaults**
- `List.of()` returns an immutable empty list, preventing accidental modifications
- More memory-efficient than creating new `ArrayList()` instances

**5. Type Safety**
- Default value matches the expected type, avoiding casting issues


#### MyNotes:
a) Suggest some better variable names for `peopleByCity`

Based on the context of your code, here are some better variable names for `peopleByCity`:

- **`personsByCity`** - more grammatically correct (singular noun for the type)
- **`cityResidents`** - concise and descriptive
- **`cityPopulation`** - emphasizes the demographic aspect
- **`residents`** - simpler, if the city context is obvious

I'd recommend **`personsByCity`** since it follows Java naming conventions better (the map contains `Person` objects, so the singular form is preferred):

```java
Map<String, List<Person>> personsByCity = new HashMap<>();
```

This aligns with common Java collection naming patterns where you use the singular form of the element type followed by the grouping criterion (e.g., `employeesByDepartment`, `ordersByCustomer`).

---
---
--------------------------------------------------------------------------------------------------------------

==> getOrDefault: Building a result map with defaults

```
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class ResultMapWithDefaultsExample {

    public static void main(String[] args) {
        // Existing data (some keys may be missing)
        Map<String, List<String>> existingCategories = new HashMap<>();
        existingCategories.put("fruits", List.of("apple", "banana"));
        existingCategories.put("dairy", List.of("milk", "cheese"));
        // note: "vegetables" is intentionally missing

        // Keys we want in the result map no matter what
        List<String> keys = List.of("fruits", "vegetables", "dairy");

        // Build result map with defaults (empty list if missing)
        Map<String, List<String>> result = keys.stream()
                .collect(Collectors.toMap(
                        key -> key,
                        key -> existingCategories.getOrDefault(key, List.of())
                ));

        System.out.println("existingCategories = " + existingCategories);
        System.out.println("keys       = " + keys);
        System.out.println("result     = " + result);
    }
}
```

#### Output:
```
existingCategories = {fruits=[apple, banana], dairy=[milk, cheese]}
keys       = [fruits, vegetables, dairy]
result     = {fruits=[apple, banana], vegetables=[], dairy=[milk, cheese]}
```

---
---
--------------------------------------------------------------------------------------------------------------

==> getOrDefault:  Score tracking with defaults
```
import java.util.HashMap;
import java.util.Map;

public class ScoreTrackingWithDefaultsExample {

    public static void main(String[] args) {
        Map<String, Integer> playerScores = new HashMap<>();
        playerScores.put("Alice", 100);
        playerScores.put("Bob", 85);

        int aliceScore = playerScores.getOrDefault("Alice", 0);      // 100
        int charlieScore = playerScores.getOrDefault("Charlie", 0);  // 0 (new player)

        System.out.println("Alice score   : " + aliceScore);
        System.out.println("Charlie score : " + charlieScore);

        // Optional: show the map (Charlie is NOT added by getOrDefault)
        System.out.println("playerScores map: " + playerScores);
    }
}
```

#### Output:
```
Alice score   : 100
Charlie score : 0
playerScores map: {Bob=85, Alice=100}
```

---
---
--------------------------------------------------------------------------------------------------------------

==> getOrDefault:  With computeIfAbsent for mutable lists

```
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ComputeIfAbsentMutableListExample {

    public static void main(String[] args) {
        Map<String, List<String>> map = new HashMap<>();

        // Don't do this - List.of() is immutable (would throw UnsupportedOperationException)
        // map.getOrDefault("key", List.of()).add("value");

        // Do this instead: computeIfAbsent creates a mutable list when the key is missing
        map.computeIfAbsent("key", k -> new ArrayList<>()).add("value");
        map.computeIfAbsent("key", k -> new ArrayList<>()).add("value2"); // adds to same list

        // Another key
        map.computeIfAbsent("city", k -> new ArrayList<>()).add("NYC");

        System.out.println("map = " + map); // {key=[value, value2], city=[NYC]}

        // Show it really is mutable
        map.get("key").remove("value");
        System.out.println("after remove = " + map); // {key=[value2], city=[NYC]}
    }
}
```

#### Output:
```
map = {city=[NYC], key=[value, value2]}
after remove = {city=[NYC], key=[value2]}
```

#### MyNotes:

a) `List.of()` returns an immutable list, so calling `add()` on it would throw an `UnsupportedOperationException`.

**Better explanation:**

"`List.of()` returns an **immutable** list. If you need to add elements to the list, use `new ArrayList<>()` instead."

The key points:
- `List.of()` creates an immutable list (whether empty or not)
- Any modification attempt (add, remove, set) throws `UnsupportedOperationException`
- `new ArrayList<>()` creates a mutable list that supports modifications

Your example code correctly demonstrates this with `computeIfAbsent`, which creates a new mutable `ArrayList` only when the key is absent, allowing safe additions to the list.


**Important note:** `List.of()` returns an **immutable** empty list. If you need to add elements to the returned list, use `new ArrayList<>()`

---
---
--------------------------------------------------------------------------------------------------------------
==> getOrDefault: Grouping with default empty lists

```
public enum Department {
    ENGINEERING, HR, SALES, FINANCE
}


public record Employee(String name, Department department) {
}

import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class GroupingWithDefaultEmptyListsExample {
    public static void main(String[] args) {
        Map<Department, List<Employee>> employeesByDept = new HashMap<>();

        // Add some departments with employees
        employeesByDept.put(Department.ENGINEERING, List.of(
                new Employee("Alice", Department.ENGINEERING),
                new Employee("Bob", Department.ENGINEERING)
        ));

        employeesByDept.put(Department.HR, List.of(
                new Employee("Charlie", Department.HR)
        ));

        // Departments we want to report on (even if missing from map)
        List<Department> allDepartments = List.of(
                Department.ENGINEERING,
                Department.HR,
                Department.SALES,
                Department.FINANCE
        );

        for (Department dept : allDepartments) {
            List<Employee> employees = employeesByDept.getOrDefault(dept, List.of());
            System.out.println(dept + " has " + employees.size() + " employees: " + employees);
        }
    }
}
```

#### Output:
```
ENGINEERING has 2 employees: [Employee[name=Alice, department=ENGINEERING], Employee[name=Bob, department=ENGINEERING]]
HR has 1 employees: [Employee[name=Charlie, department=HR]]
SALES has 0 employees: []
FINANCE has 0 employees: []
```

---
---
--------------------------------------------------------------------------------------------------------------
==> getOrDefault: Safe navigation pattern

```
public record Employee(String name, int salary) {
}

import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class SafeNavigationPatternExample {

    // Example data source
    private Map<String, List<Employee>> getEmployeeMap() {
        Map<String, List<Employee>> empMap = new HashMap<>();
        empMap.put("Engineering", List.of(
                new Employee("Alice", 120000),
                new Employee("Bob", 130000)
        ));
        empMap.put("HR", List.of(
                new Employee("Charlie", 90000)
        ));
        // Note: "Sales" intentionally not present to show safe default behavior
        return empMap;
    }

    // safe navigation using getOrDefault + stream + sum
    public int getTotalSalary(String department) {
        Map<String, List<Employee>> empMap = getEmployeeMap();

        return empMap.getOrDefault(department, List.of())
                .stream()
                .mapToInt(Employee::salary)
                .sum();
    }

    public static void main(String[] args) {

        SafeNavigationPatternExample example = new SafeNavigationPatternExample();

        System.out.println("Engineering total salary: " + example.getTotalSalary("Engineering"));
        System.out.println("HR total salary         : " + example.getTotalSalary("HR"));
        System.out.println("Sales total salary      : " + example.getTotalSalary("Sales")); // 0 (missing dept)

    }
}
```

#### Output:
```
Engineering total salary: 250000
HR total salary         : 90000
Sales total salary      : 0
```

---
---
--------------------------------------------------------------------------------------------------------------
==> getOrDefault: Role-based permissions with defaults

```
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class RoleBasedPermissionsWithDefaultsExample {

    public static void main(String[] args) {
        Map<String, Set<String>> rolePermissions = new HashMap<>();
        rolePermissions.put("admin", Set.of("read", "write", "delete"));
        rolePermissions.put("user", Set.of("read"));

        // If the role exists, you get its permissions
        Set<String> adminPerms = rolePermissions.getOrDefault("admin", Set.of());

        // If the role does NOT exist, you get the default you provide
        Set<String> guestPerms = rolePermissions.getOrDefault("guest", Set.of("read"));

        System.out.println("Admin permissions: " + adminPerms);
        System.out.println("Guest permissions: " + guestPerms);

        // Optional: show that Set.of(...) is immutable (would throw UnsupportedOperationException)
        // guestPerms.add("write");
    }
}
```

#### Output:
```
Admin permissions: [delete, read, write]
Guest permissions: [read]
```

#### MyNotes:
a) Suggest a better for `rolePermissions`

Based on the context of your code, here are some better variable names for `rolePermissions`:

- **`permissionsByRole`** - follows the common "by" pattern, emphasizing the grouping
- **`roleToPermissions`** - explicitly shows the mapping relationship
- **`permissions`** - simpler, if the role context is clear
- **`accessRights`** - more domain-specific alternative

I'd recommend **`permissionsByRole`** since it follows Java naming conventions and makes the map's structure clearer:

```java
Map<String, Set<String>> permissionsByRole = new HashMap<>();
```

This aligns with the pattern used in your previous examples (`personsByCity`, `sourceCategories`) where the value type comes first, followed by the grouping key.


b) Refactoring: Extract string literals and permissions sets into constants, making the code more maintainable and reducing the risk of typos:

In IntelliJ, use the shortcut `Ctrl + Alt + C` or right click -> Refactor -> Introduce Constant


```
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class RoleBasedPermissionsWithDefaultsExample {

    // ---- Role constants (avoid typos like "admn") ----
    public static final String ADMIN = "admin";
    public static final String USER = "user";
    public static final String GUEST = "guest";

    // ---- Reusable permission sets ----
    public static final Set<String> ADMIN_PERMISSIONS = Set.of("read", "write", "delete");
    public static final Set<String> USER_PERMISSIONS = Set.of("read");
    public static final Set<String> GUEST_DEFAULT_PERMISSIONS = Set.of("read");

    public static void main(String[] args) {
        Map<String, Set<String>> rolePermissions = new HashMap<>();
        rolePermissions.put(ADMIN, ADMIN_PERMISSIONS);
        rolePermissions.put(USER, USER_PERMISSIONS);

        // If the role exists, you get its permissions
        Set<String> adminPerms = rolePermissions.getOrDefault(ADMIN, Set.of());

        // If the role does NOT exist, you get the default you provide
        Set<String> guestPerms = rolePermissions.getOrDefault(GUEST, GUEST_DEFAULT_PERMISSIONS);

        System.out.println("Admin permissions: " + adminPerms);
        System.out.println("Guest permissions: " + guestPerms);

        // Optional: show that Set.of(...) is immutable (would throw UnsupportedOperationException)
        // guestPerms.add("write");
    }
}
```

---
---
--------------------------------------------------------------------------------------------------------------
==> getOrDefault: demonstrate with EnumMap

```
public enum Day {
        MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
}

import java.util.EnumMap;

public class EnumMapExample {

    public static void main(String[] args) {

        EnumMap<Day, String> timetable = new EnumMap<>(Day.class);

        // Step 3: Put values into the map
        timetable.put(Day.MONDAY, "Workout");
        timetable.put(Day.TUESDAY, "Team Meeting");
        timetable.put(Day.WEDNESDAY, "Project Work");
        timetable.put(Day.THURSDAY, "Learning Session");
        timetable.put(Day.FRIDAY, "Code Review");

        // Print the timetable
        // we can use `getOrDefault` to simplify retrieval with a default value
        // eliminates the explicit null check by providing a default value when the key is not found in the map.
        for (Day day : Day.values()) {
            String activity = timetable.getOrDefault(day, "No activities planned");
            System.out.println(day + ": " + activity);
        }

    }
}
```

#### Output:
```
MONDAY: Workout
TUESDAY: Team Meeting
WEDNESDAY: Project Work
THURSDAY: Learning Session
FRIDAY: Code Review
SATURDAY: No activities planned
SUNDAY: No activities planned
```

#### MyNotes:
a) Without getOrDefault:
```
for (Day day : Day.values()) {
            String activity = timetable.get(day);
            if (activity != null) {
                System.out.println(day + ": " + activity);
            } else {
                System.out.println(day + ": No activities planned");
            }
        }
```

b) This method was introduced in Java 8 to help avoid explicit null checks.

Key Points:

• Null Avoidance: It provides a clean way to handle missing keys without manually checking for null and risking a NullPointerException.
• No Map Modification: The  method only retrieves a value; it does not add the defaultValue to the map if the key is missing. 
• Alternative: If you need to compute a value and automatically insert it into the map if the key is absent, you should use computeIfAbsent() instead. 
• Availability: This method is available in Java 8 and later. 

---
---
--------------------------------------------------------------------------------------------------------------

==> getOrDefault: count word occurrences in a string

```
import java.util.HashMap;
import java.util.Map;

public class WordCountDemo {
    public static void main(String[] args) {
        Map<String, Integer> wordCounts = new HashMap<>();
        String text = "apple banana apple orange banana apple";
        String[] words = text.split(" ");

        for (String word : words) {
            // Get the current count for the word, or 0 if not present, then increment
            wordCounts.put(word, wordCounts.getOrDefault(word, 0) + 1);
        }

        System.out.println("Word counts: " + wordCounts);

    }
}
```

#### Output:
```
Word counts: {banana=2, orange=1, apple=3}
```

MyNotes: 
a)  You can iterate directly over `text.split(" ")` without storing it in a variable.

**Direct iteration:**
```
for (String word : text.split(" ")) {
            // Get the current count for the word, or 0 if not present, then increment
            wordCounts.put(word, wordCounts.getOrDefault(word, 0) + 1);
        }
```

**Performance Impact:**
- **No significant difference** for single use - the array is created once either way
- **Better readability** - eliminates an unnecessary variable when used only once
- **Worse if reused** - if you need to iterate multiple times, storing it in a variable avoids re-splitting

In your case, since the array is only used once, iterating directly is **fine and preferred** for cleaner code. The performance difference is negligible.

However, if you later need to access `words.length` or iterate multiple times, keep the variable to avoid redundant string splitting operations.


b) without getOrDefault
```
for (String word : text.split(" ")) {
            if (wordCounts.containsKey(word)) {
                wordCounts.put(word, wordCounts.get(word) + 1);
            } else {
                wordCounts.put(word, 1);
            }
        }
```

c) Here's a better regex-based solution:

```java
for(String word : text.toLowerCase().split("\\s+")) {
```

**Key improvements:**

1. **`\\s+`** - Matches one or more whitespace characters (spaces, tabs, newlines), not just single spaces
2. **`toLowerCase()`** - Ensures case-insensitive counting (e.g., "Apple" and "apple" are counted together)

**For production code with punctuation handling:**

```java
String[] words = text.toLowerCase().split("[\\s\\p{Punct}]+");
for(String word : words) {
    if (!word.isEmpty()) {
        wordCounts.compute(word, (k,v) -> v == null ? 1 : v + 1);
    }
}
```
This removes punctuation and handles edge cases like empty strings from consecutive delimiters.

The regex `[\\s\\p{Punct}]+` breaks down as follows:

**Pattern Components:**

1. **`[...]`** - Character class that matches any single character inside the brackets

2. **`\\s`** - Matches any whitespace character:
   - Space ` `
   - Tab `\t`
   - Newline `\n`
   - Carriage return `\r`
   - Form feed `\f`

3. **`\\p{Punct}`** - Unicode property that matches any punctuation character:
   - Period `.`
   - Comma `,`
   - Exclamation mark `!`
   - Question mark `?`
   - Semicolon `;`
   - Colon `:`
   - Apostrophe `'`
   - Quotation marks `"`
   - Hyphens `-`
   - Parentheses `()`, brackets `[]`, braces `{}`
   - And all other Unicode punctuation

4. **`+`** - Quantifier meaning "one or more" of the preceding pattern

**Combined Meaning:**

The regex matches **one or more consecutive whitespace or punctuation characters**.

**Examples:**

- `"apple, banana"` → splits on `", "` → `["apple", "banana"]`
- `"hello...world"` → splits on `"..."` → `["hello", "world"]`
- `"it's working!"` → splits on `"'", space, and `"!"` → `["it", "s", "working"]`

The `+` ensures multiple delimiters in a row are treated as one split point, preventing empty strings in the result array.


---
---
--------------------------------------------------------------------------------------------------------------

==> In the above code for counting word frequencies, `Map` is **not** overkill—it's the right tool. The `getOrDefault()` pattern is clean and efficient the standard, idiomatic approach in Java. However, there are a few alternatives depending on your needs:

## Why Map is Actually Good Here

The `HashMap` approach is:
- **Simple and readable** - clear what's happening
- **Efficient** - O(1) average lookups and insertions
- **Standard practice** - any Java developer will understand it immediately

## Other Alternatives 

**1. Use `merge()` - more concise:**
```
import java.util.HashMap;
import java.util.Map;

public class WordCountDemo {
    public static void main(String[] args) {
        Map<String, Integer> wordCounts = new HashMap<>();
        String text = "apple banana apple orange banana apple";

        // 1. Use merge() - more concise:
        for (String word : text.split(" ")) {
            wordCounts.merge(word, 1, Integer::sum);
        }

        System.out.println("Word counts: " + wordCounts);

    }
}
```
This is cleaner but does the same thing under the hood.


**2. Use `compute()` or `computeIfAbsent()`:**
```
import java.util.HashMap;
import java.util.Map;

public class WordCountDemo {
    public static void main(String[] args) {
        Map<String, Integer> wordCounts = new HashMap<>();
        String text = "apple banana apple orange banana apple";

        for (String word : text.split(" ")) {
            wordCounts.compute(word, (k, v) -> v == null ? 1 : v + 1);
        }

        System.out.println("Word counts: " + wordCounts);

    }
}
```


```
import java.util.HashMap;
import java.util.Map;

public class WordCountDemo {
    public static void main(String[] args) {
        Map<String, Integer> wordCounts = new HashMap<>();
        String text = "apple banana apple orange banana apple";

        for (String word : text.split(" ")) {
            wordCounts.computeIfAbsent(word, k -> 0);
            wordCounts.put(word, wordCounts.get(word) + 1);
        }


        System.out.println("Word counts: " + wordCounts);

    }
}
```

#### MyNotes:
a) 
```
wordCounts.computeIfAbsent(word, k -> 0);
wordCounts.put(word, wordCounts.get(word) + 1);
```
We can combine above two statements using `merge()` or `compute()`:

**Option 1: Using `merge()` (recommended)**

```java
wordCounts.merge(word, 1, Integer::sum);
```

**Option 2: Using `compute()`**

```java
wordCounts.compute(word, (k, v) -> v == null ? 1 : v + 1);
```

The `merge()` method is cleaner: it inserts the value `1` if the key doesn't exist, otherwise it applies the sum function to the existing value and the new value.


**3. Use streams (if you want functional style):**
```java
import java.util.Arrays;
import java.util.Map;
import java.util.stream.Collectors;

public class WordCountDemo {
    public static void main(String[] args) {

        String text = "apple banana apple orange banana apple";

        Map<String, Long> wordCounts = Arrays.stream(text.split(" "))
                .collect(Collectors.groupingBy(w -> w, Collectors.counting()));


        System.out.println("Word counts: " + wordCounts);

    }
}
```
This approach is more functional and concise. Note that the count type is now `Long` instead of `Integer` because `Collectors.counting()` returns `Long` values.

#### MyNotes:
1) `w -> w` can be replaced with `Function.identity()`

`Function.identity()` is a static method that returns a function which always returns its input argument. It's functionally equivalent to the lambda `w -> w`.

`Function.identity()` is generally preferred because:

- It's more explicit and readable
- It avoids creating a new lambda instance (though modern JVMs optimize this)
- It's a well-known idiom in Stream API code

Both will produce the same result when used as a key mapper in `groupingBy()`.


**4. For very simple cases, use an array (if words are limited):**
Only works if you know all possible words in advance—not practical for general text.

## The Verdict

For counting word frequencies, `Map` is **not** overkill—it's the right tool. The `getOrDefault()` pattern is clean and efficient. If anything, consider using `merge()` for slightly more elegance, but what you have is perfectly fine and actually the recommended approach!


---
---
______________________________________________________________________________________________________________

==> The key differences between `compute()` and `computeIfAbsent()`:

| Method | Behavior | Use Case |
|--------|----------|----------|
| **`compute()`** | Always executes the remapping function, regardless of whether the key exists | Use when you need to update values for both existing and new keys |
| **`computeIfAbsent()`** | Only executes the function if the key is **absent** (or mapped to `null`) | Use when you only want to initialize missing keys |

---
---
______________________________________________________________________________________________________________

==> `Map.getOrDefault(key, defaultValue)`  Vs  `Map.merge(key, value, remappingFunction)`

`Map.merge()` and `Map.getOrDefault()` serve different purposes in Java’s `Map` interface. The key difference is that `getOrDefault()` only retrieves a value, whereas `merge()` can update the map’s content. 

---

### `Map.getOrDefault(key, defaultValue)`

* **Purpose:** Returns the value for `key` if it exists; otherwise returns the provided `defaultValue`. 
* **Action:** Read-only with respect to the map (does **not** add/remove/modify entries). 
* **Use case:** When you want a safe default for *temporary use* without changing map state (e.g., display). 

**Example (count lookup without modifying map):** 

```
import java.util.HashMap;
import java.util.Map;

public class FruitCountDemo {
    public static void main(String[] args) {

        Map<String, Integer> fruitCounts = new HashMap<>();
        fruitCounts.put("apple", 3);
        fruitCounts.put("cherry", 2);

        // Get the count for "apple", return 0 if not present, but don't add to map
        int appleCount = fruitCounts.getOrDefault("apple", 0);
        System.out.println("Apple count (may not be in map): " + appleCount);

        // Get the count for "banana", return 0 if not present
        int bananaCount = fruitCounts.getOrDefault("banana", 0);
        System.out.println("Banana count (may not be in map): " + bananaCount);

    }
}
```

#### Output:
```
Apple count (may not be in map): 3
Banana count (may not be in map): 0
```

---

### `Map.merge(key, value, remappingFunction)`

**Behavior:**
* If `key` is **not present**, it inserts the given `value` directly (no remapping function is called).
* If `key` is **present**, it applies the `remappingFunction` to `(oldValue, newValue)` and:
  * If the result is **non-null**, replaces the old value with the computed result.
  * If the result is **null**, removes the key from the map.

* **Use case:** Great for accumulation patterns (like word-frequency counting) in a single concise operation. 

**Example (counting occurrences):** 

```
import java.util.HashMap;
import java.util.Map;

public class FruitCountDemo {
    public static void main(String[] args) {

        Map<String, Integer> fruitCounts = new HashMap<>();
        fruitCounts.put("apple", 3);
        fruitCounts.put("cherry", 2);

        String fruit = "apple";
        Integer count = fruitCounts.merge(fruit, 1, Integer::sum);
        System.out.println("Count for " + fruit + ": " + count);

        fruitCounts.merge("banana", 1, Integer::sum);
        System.out.println("Count for banana: " + fruitCounts.get("banana"));

    }
}
```

#### Output:
```
Count for apple: 4
Count for banana: 1
```

---

### Summary of differences 

| Feature                            | `getOrDefault()`              | `merge()`                                                |
| ---------------------------------- | ----------------------------- | -------------------------------------------------------- |
| Modifies map                       | No                            | Yes                                                      |
| Return value                       | Value for key, or default     | New value for key (or `null` if removed by the function) |
| Function use                       | None                          | Uses a remapping function                                |
| Synchronization / concurrency note | Depends on map implementation | Can be safer with concurrent map implementations         |


---
---
______________________________________________________________________________________________________________

==>  `Map.merge(key, value, remappingFunction)`:  Here's a complete example demonstrating the null-result behavior:
```
import java.util.HashMap;
import java.util.Map;

public class MapMergeExample {
    public static void main(String[] args) {
        Map<String, Integer> inventory = new HashMap<>();
        inventory.put("apples", 10);
        inventory.put("bananas", 5);
        inventory.put("oranges", 3);

        System.out.println("Initial inventory: " + inventory);
        // Output: {apples=10, bananas=5, oranges=3}

        // Example: Remove item if stock falls to zero or below
        // Key "apples" is PRESENT (value = 10)
        // We try to remove 10 items
        inventory.merge("apples", -10, (oldStock, change) -> {
            int newStock = oldStock + change;
            System.out.println("Old stock: " + oldStock + ", Change: " + change + ", New stock: " + newStock);
            // If stock reaches 0 or below, return null to remove the entry
            return newStock <= 0 ? null : newStock;
        });

        System.out.println("After removing 10 apples: " + inventory);
        // Output: {bananas=5, oranges=3}
        // "apples" key was REMOVED because the function returned null

        System.out.println("\n--- Another Example ---");

        // Remove bananas by intentionally returning null
        inventory.merge("bananas", 100, (oldVal, newVal) -> {
            System.out.println("Intentionally returning null to remove 'bananas'");
            return null;  // This removes the key
        });

        System.out.println("After merge with null result: " + inventory);
        // Output: {oranges=3}
        // "bananas" was removed
    }
}
```

#### Output:
```
Initial inventory: {oranges=3, bananas=5, apples=10}
Old stock: 10, Change: -10, New stock: 0
After removing 10 apples: {oranges=3, bananas=5}

--- Another Example ---
Intentionally returning null to remove 'bananas'
After merge with null result: {oranges=3}
```

**Key Points:**
- The key **must be present** for the remapping function to be called
- When the function returns `null`, the entry is **removed** from the map
- This is useful for conditional removal based on computed values

---
---
______________________________________________________________________________________________________________

==> Here are some practical real-world examples using `Map.merge()`:

## 1. **Inventory Management - Combining Stock from Multiple Warehouses**

```
import java.util.HashMap;
import java.util.Map;

public class InventoryManagementExample {
    public static void main(String[] args) {

        Map<String, Integer> warehouseA = new HashMap<>();
        warehouseA.put("Laptop", 50);
        warehouseA.put("Mouse", 200);

        Map<String, Integer> warehouseB = new HashMap<>();
        warehouseB.put("Laptop", 30);
        warehouseB.put("Keyboard", 150);

        // Merge inventory from warehouse B into A
        warehouseB.forEach((product, quantity) ->
                warehouseA.merge(product, quantity, Integer::sum)
        );

        System.out.println(warehouseA);  // {Laptop=80, Mouse=200, Keyboard=150}
    }
}
```

## 2. **Shopping Cart - Adding Items**

```
import java.util.HashMap;
import java.util.Map;

public class ShoppingCartMergeExample {
    public static void main(String[] args) {

        Map<String, Integer> cart = new HashMap<>();

        // Customer adds items multiple times
        cart.merge("iPhone", 1, Integer::sum);   // First iPhone
        cart.merge("AirPods", 2, Integer::sum);  // 2 AirPods
        cart.merge("iPhone", 1, Integer::sum);   // Another iPhone

        System.out.println(cart);
        // Expected: {iPhone=2, AirPods=2}
    }
}

```


## 3. **Sales Analytics - Aggregating Revenue by Region**

```
// Prefer the primitive `double` for better performance, no boxing.
// Use `Double` when you need nullability (nullable DB columns, JSON payloads that omit the field)the field)
public record Sale(String region, double amount) {
}

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class SalesAnalyticsMergeExample {
    public static void main(String[] args) {
        List<Sale> sales = Arrays.asList(
                new Sale("North", 1000.0),
                new Sale("South", 1500.0),
                new Sale("North", 2000.0),
                new Sale("East", 800.0)
        );

        Map<String, Double> revenueByRegion = new HashMap<>();
        for (Sale sale : sales) {
            revenueByRegion.merge(sale.region(), sale.amount(), Double::sum);
        }

        System.out.println(revenueByRegion);  //  {South=1500.0, North=3000.0, East=800.0}
    }
}
```

#### MyNotes:
a) Sale.java: should we have this double here?

Looking at the context, using `double` for the `amount` field is **not ideal** for financial data like sales amounts.

**Issues with `double`:**
- Floating-point precision errors can occur with monetary calculations
- Rounding errors accumulate, especially when summing multiple values
- Not suitable for financial applications requiring exact precision

**Recommendation:**

Use `BigDecimal` instead:

```
import java.math.BigDecimal;

public record Sale(String region, BigDecimal amount) {
}
```

You'll also need to update `SalesAnalyticsExample.java`:

```
import java.math.BigDecimal;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class SalesAnalyticsExample {
    public static void main(String[] args) {
        List<Sale> sales = Arrays.asList(
                new Sale("North", new BigDecimal("1000.0")),
                new Sale("South", new BigDecimal("1500.0")),
                new Sale("North", new BigDecimal("2000.0")),
                new Sale("East", new BigDecimal("800.0"))
        );

        Map<String, BigDecimal> revenueByRegion = new HashMap<>();

        for (Sale sale : sales) {
            revenueByRegion.merge(sale.region(), sale.amount(), BigDecimal::add);

        }

        System.out.println(revenueByRegion);
    }
}
```
`BigDecimal` provides exact decimal representation and is the standard for financial calculations in Java.

b) `BigDecimal::add` is functionally equivalent to `Double::sum` in this context.

**Comparison:**

- `Double::sum` - static method that adds two `Double` values
- `BigDecimal::add` - instance method that adds another `BigDecimal` to the current instance



## 4. **Scoring System - Combining Scores**

```
import java.util.HashMap;
import java.util.Map;

public class ScoringSystemMergeExample {
    public static void main(String[] args) {

        Map<String, Integer> playerScores = new HashMap<>();

        // Game events
        playerScores.merge("Alice", 10, Integer::sum); // Alice scores 10
        playerScores.merge("Bob", 15, Integer::sum);   // Bob scores 15
        playerScores.merge("Alice", 25, Integer::sum); // Alice scores 25 more
        playerScores.merge("Alice", 5, Integer::sum);  // Alice scores 5 more

        System.out.println(playerScores);  // Output: {Bob=15, Alice=40}

    }
}

```

## Key Takeaway

The `merge()` method shines when you need to:
- **Combine values** from multiple sources
- **Accumulate** counts, sums, or aggregations
- **Update** existing entries or insert new ones in one operation

The remapping function (`Integer::sum`, `Double::sum`, etc.) determines **how** to combine the old and new values when a key already exists.

---
---
______________________________________________________________________________________________________________

