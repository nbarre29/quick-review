==> https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/Set.html#of(E...)
why there are so many Set.of overloaded methods?  Using varargs `Set.of(E... elements)` is sufficient right ?

You're absolutely right to question this! Using varargs `Set.of(E... elements)` would be simpler, but Java chose this design for **performance reasons**. Here's why:

## The Problem with Varargs

When you call a varargs method, Java creates an array behind the scenes:

```java
Set.of(1, 2, 3)  // Creates: new Object[]{1, 2, 3}
```

This array allocation:
- Takes time and memory
- Creates garbage for the GC to clean up
- Happens on **every single call**

## The Solution: Fixed-Arity Overloads

By providing overloads for 0-10 arguments, Java avoids array creation for the most common cases:

```java
Set.of(1, 2, 3)  // Calls: Set.of(E, E, E) - no array!
```

These fixed-arity methods can pass arguments directly without any allocation overhead.

## The Design Choice

- **Set.of(E)** through **Set.of(E, E, E, E, E, E, E, E, E, E)** - cover 0-10 elements efficiently
- **Set.of(E...)** - handles 11+ elements (rare case where the cost is acceptable)

## Why It Matters

`Set.of()` is used extensively in performance-sensitive code. Since most sets created this way are small (1-5 elements), avoiding array allocation makes a measurable difference in real-world applications.

**Trade-off:** More verbose API for better performance in the common case. Java decided the performance gain was worth the API clutter.

---
---
______________________________________________________________________________________________________________

==> Stream.peek(...)

**per the Java SE  Stream Javadoc, `Stream.peek(...)` exists mainly to support debugging**. The Javadoc explicitly says:

> “This method exists mainly to support debugging…”

A couple of important implications (also from the docs):

* `peek` is an **intermediate operation** intended for **side-effects**, so it should be used carefully. (https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/stream/package-summary.html#SideEffects)
* In **parallel streams**, the action can run in **different threads / timing**, so using it for anything other than simple logging can be risky.

https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/stream/Stream.html


## **Java Stream `peek()` - Debugging Focus**

```
import java.util.List;

public class PeekExample {

    public static void main(String[] args) {
        List<String> list = List.of("Apple", "Banana", "Avocado", "Apricot", "berry");

        List<String> result = list.stream()
                .filter(s -> s.startsWith("A"))
                .peek(s -> System.out.println("Filtered: " + s))  // Debug (after filter)
                .map(String::toUpperCase)
                .peek(s -> System.out.println("Mapped:   " + s))  // Debug (after map)
                .toList();

        System.out.println("Final result: " + result);
    }
}
```

#### Output:
```
Filtered: Apple
Mapped:   APPLE
Filtered: Avocado
Mapped:   AVOCADO
Filtered: Apricot
Mapped:   APRICOT
Final result: [APPLE, AVOCADO, APRICOT]
```

---
---
______________________________________________________________________________________________________________

