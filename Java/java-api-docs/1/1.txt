
==> Here’s a **simple Java program** that demonstrates `DoubleStream.mapToObj()`.

### ✅ Example: Convert doubles → formatted Strings and custom objects

```
public record ProductPrice(String productId, double price) {

    @Override
    public String toString() {
        return "ProductPrice{productId='" + productId + "', price=" + price + "}";
    }
}

import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.DoubleStream;

public class DoubleStreamMapToObjDemo {

    public static void main(String[] args) {

        // DoubleStream -> Stream<String>
        List<String> priceLabels =
                DoubleStream.of(12.5, 99.99, 100.0, 7.25)
                        .mapToObj(price -> String.format("$%.2f", price))
                        .toList();

        System.out.println("Price labels: " + priceLabels);

        AtomicInteger counter = new AtomicInteger(1000);
        // DoubleStream -> Stream<ProductPrice> (custom objects)
        List<ProductPrice> products =
                DoubleStream.of(12.5, 99.99, 100.0, 7.25)
                        .mapToObj(price -> new ProductPrice("SKU-" + counter.getAndIncrement(), price))
                        .toList();

        System.out.println("Product objects:");
        products.forEach(System.out::println);
    }


}
```

#### Output:
```
Price labels: [$12.50, $99.99, $100.00, $7.25]
Product objects:
ProductPrice{productId='SKU-1000', price=12.5}
ProductPrice{productId='SKU-1001', price=99.99}
ProductPrice{productId='SKU-1002', price=100.0}
ProductPrice{productId='SKU-1003', price=7.25}
```



### What this demonstrates

* `DoubleStream` is a **primitive stream** (`double` values).
* `mapToObj(...)` converts each `double` into an **object** (`String`, POJO, etc.).
* Result becomes a normal `Stream<T>`.


#### MyNotes:
##### a)
```
// DoubleStream -> Stream<ProductPrice> (custom objects)
        List<ProductPrice> products =
                DoubleStream.of(12.5, 99.99, 100.0, 7.25)
                        .mapToObj(price -> new ProductPrice(UUID.randomUUID().toString(), price))
                        .toList();
```

##### b) 
The `%` is a **format specifier** in `String.format()` that marks where and how values should be inserted into the formatted string.

**Key points:**
- `%` indicates the start of a format placeholder
- `.2f` specifies the formatting rules:
  - `f` - format as floating-point (decimal) number
  - `.2` - use exactly 2 decimal places

**Examples:**
- `%.2f` → formats double with 2 decimals: `12.5` → `"12.50"`
- `%d` → formats integer: `42` → `"42"`
- `%s` → formats string: `"hello"` → `"hello"`
- `%n` → platform-specific newline

**In above code:**
```java
String.format("$%.2f", price)
```
The `%` tells Java "replace this with the `price` value formatted as a decimal with 2 decimal places."


##### c) In Java's `String.format()`, there is **no separate specifier for `double`**.

**Key point:**
- Both `float` and `double` use the **same** `f` specifier
- `f` stands for floating-point, which covers both types

**Why this works:**
```java
double price = 12.5;
String.format("%.2f", price)  // ✓ Works - double uses 'f'

float value = 12.5f;
String.format("%.2f", value)  // ✓ Works - float uses 'f'
```

**Common floating-point specifiers:**
- `%f` - standard floating-point (works for both `float` and `double`)

Even though `price` is a `double`, you use `f` because Java treats all floating-point numbers (both `float` and `double`) with the same format specifier.

---
---
______________________________________________________________________________________________________________

==> mapToObj vs boxed()

Both convert a **primitive stream** (like `IntStream`, `LongStream`, `DoubleStream`) into a **Stream of objects**, but they’re used for different goals.

---

## Core difference

### ✅ `boxed()`

> Converts primitives into their **wrapper types** only.

* `IntStream` → `Stream<Integer>`
* `DoubleStream` → `Stream<Double>`

```java
Stream<Double> s = DoubleStream.of(1.1, 2.2).boxed();
```

---

### ✅ `mapToObj(...)`

> Converts primitives into **any object type you want** (String, DTO, BigDecimal, etc.)

```java
Stream<String> s =
    DoubleStream.of(1.1, 2.2)
                .mapToObj(d -> "Value=" + d);
```

---

## Quick comparison table

| Feature       | `boxed()`                                                         | `mapToObj()`                                            |
| ------------- | ----------------------------------------------------------------- | ------------------------------------------------------- |
| Output type   | Wrapper only (`Integer`, `Long`, `Double`)                        | Any object type (`T`)                                   |
| Typical use   | You need wrapper objects (Collectors, APIs expecting `Stream<T>`) | You want to transform into a DTO/string/BigDecimal/etc. |
| Equivalent to | `mapToObj(x -> (Wrapper)x)`                                       | Custom mapping function                                 |
| Flexibility   | Low                                                               | High                                                    |

---

## Examples

### 1) When to use `boxed()`

You just want wrappers to collect into a List:

```java
List<Double> list =
    DoubleStream.of(1.1, 2.2, 3.3)
                .boxed()
                .toList();
```


---

### 2) When to use `mapToObj()`

You want objects other than wrappers:

```java
List<String> labels =
    DoubleStream.of(1.1, 2.2, 3.3)
                .mapToObj(d -> String.format("$%.2f", d))
                .collect(java.util.stream.Collectors.toList());
```

Or convert to `BigDecimal`:

```java
List<java.math.BigDecimal> amounts =
    DoubleStream.of(1.1, 2.2)
                .mapToObj(java.math.BigDecimal::valueOf)
                .collect(java.util.stream.Collectors.toList());
```

---

## Rule of thumb

* Use **`boxed()`** when you only need wrapper types (`Integer`, `Double`, `Long`)
* Use **`mapToObj()`** when you want **custom objects** or custom formatting


---
---
______________________________________________________________________________________________________________

==> https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/String.html#join(java.lang.CharSequence,java.lang.CharSequence...)

import java.util.Arrays;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        // Join with hyphen
        String message = String.join("-", "Java", "is", "cool");
        System.out.println(message); // Java-is-cool

        // different way to join with hyphen, passing an array
        String[] strArray = {"Java", "is", "cool"};
        System.out.println(String.join("-", strArray));

        // Join with comma and space
        String csv = String.join(", ", "apple", "banana", "orange");
        System.out.println(csv); // apple, banana, orange

        // Join elements from a List
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
        String nameList = String.join(" | ", names);
        System.out.println(nameList); // Alice | Bob | Charlie

        // Join with empty delimiter
        String noDelimiter = String.join("", "H", "e", "l", "l", "o");
        System.out.println(noDelimiter); // Hello

        // Join with newline character
        String lines = String.join("\n", "Line 1", "Line 2", "Line 3");
        System.out.println(lines);
        // Line 1
        // Line 2
        // Line 3
		

        // Join with tab character
        String tabbed = String.join("\t", "Column1", "Column2", "Column3");
        System.out.println(tabbed); // Column1	Column2	Column3

        // Join with custom delimiter
        String custom = String.join(" <-> ", "A", "B", "C");
        System.out.println(custom); // A <-> B <-> C

        // Join with space
        String spaced = String.join(" ", "This", "is", "a", "test");
        System.out.println(spaced); // This is a test

    }
}

---
---
______________________________________________________________________________________________________________

==> https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/String.html#join(java.lang.CharSequence,java.lang.Iterable)

```
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

public class Main {
    public static void main(String[] args) {
        List<String> wordList = List.of("Java", "is", "cool");
        String message = String.join(" ", wordList);
        System.out.println(message);  // Java is cool

        Set<String> uniqueWords =
                new LinkedHashSet<>(List.of("Java", "is", "very", "cool"));
        String message1 = String.join("-", uniqueWords);
        System.out.println(message1);    // Java-is-very-cool

    }
}
```

---
---
______________________________________________________________________________________________________________

==> `Stream.sorted()` is an **intermediate operation** that returns a new stream whose elements are **sorted**.

There are **two overloads**:

1. `sorted()` → sorts by **natural order** (elements must implement `Comparable`)
2. `sorted(Comparator)` → sorts using a **custom rule**

---

## 1) `sorted()` – Natural order example

```java
import java.util.Arrays;
import java.util.List;

public class SortedDemo1 {
    public static void main(String[] args) {
        List<Integer> nums = Arrays.asList(5, 1, 9, 3, 3);

        nums.stream()
            .sorted()                 // natural ascending order
            .forEach(System.out::println);

        // nums list is NOT modified (streams are non-mutating)
        System.out.println("Original: " + nums);
    }
}
```

---

## 2) `sorted(Comparator)` – Custom sorting example (descending)

```java
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;

public class SortedDemo2 {
    public static void main(String[] args) {
        List<Integer> nums = Arrays.asList(5, 1, 9, 3, 3);

        nums.stream()
            .sorted(Comparator.reverseOrder())   // custom: descending
            .forEach(System.out::println);
    }
}
```

---

## Example with objects (sort by a field)

```
public record User(String name, int age) {
}


import java.util.Comparator;
import java.util.List;

public class SortedObjectsDemo {

    public static void main(String[] args) {
        List<User> users = List.of(
                new User("Naveen", 35),
                new User("Alex", 25),
                new User("Bob", 30)
        );

        users.stream()
                .sorted(Comparator.comparingInt(User::age)) // sort by age ascending
                .forEach(System.out::println);
    }
}


```

---
---
______________________________________________________________________________________________________________

==> Here are clear examples of `sorted()` with **null handling** using `Comparator.nullsFirst()` / `nullsLast()`.

---

## 1) Sorting `String` list with nulls (nulls first / last)

```java
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;

public class NullSortingDemo {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Naveen", null, "Alex", "Bob", null);

        System.out.println("Nulls first:");
        names.stream()
                .sorted(Comparator.nullsFirst(Comparator.naturalOrder()))
                .forEach(System.out::println);

        System.out.println("\nNulls last:");
        names.stream()
                .sorted(Comparator.nullsLast(Comparator.naturalOrder()))
                .forEach(System.out::println);
    }
}
```

#### Output:
```
Nulls first:
null
null
Alex
Bob
Naveen

Nulls last:
Alex
Bob
Naveen
null
null
```

---

## 2) Sorting objects by a field, while handling null field values

Example: sort users by `email` where email can be null.

```java
public record User(String name, String email) {
}


import java.util.Comparator;
import java.util.List;

public class NullFieldSortingDemo {

    public static void main(String[] args) {
        List<User> users = List.of(
                new User("Naveen", "naveen@example.com"),
                new User("Alex", null),
                new User("Bob", "bob@example.com"),
                new User("Cara", null)
        );

        System.out.println("Sort by email (nulls last):");
        users.stream()
                .sorted(Comparator.comparing(
                        User::email,
                        Comparator.nullsLast(Comparator.naturalOrder())
                ))
                .forEach(System.out::println);
    }
}
```

#### Output:
```
Sort by email (nulls last):
User[name=Bob, email=bob@example.com]
User[name=Naveen, email=naveen@example.com]
User[name=Alex, email=null]
User[name=Cara, email=null]
```

---

### Quick rule

* `sorted()` alone **cannot handle nulls** (it will throw `NullPointerException` if the stream contains nulls).
* Use:

  * `sorted(Comparator.nullsFirst(...))`
  * `sorted(Comparator.nullsLast(...))`

---
---
______________________________________________________________________________________________________________
