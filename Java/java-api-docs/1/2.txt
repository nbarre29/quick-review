==> https://docs.oracle.com/javase/tutorial/java/data/numberformat.html
A new line character appropriate to the platform running the application. You should always use %n, rather than \n.

```
// ❌ BAD - hardcoded \n
System.out.printf("Name: %s\nAge: %d\n", "Alice", 30);

// ✅ GOOD - platform-specific %n
System.out.printf("Name: %s%nAge: %d%n", "Alice", 30);
```

## Alternative:
You can also use `System.lineSeparator()`:
```
public class Main {
    public static void main(String[] args) {
        // Using System.lineSeparator() for platform-independent new line
        System.out.printf("Line 1" + System.lineSeparator());
        System.out.printf("Line 2" + System.lineSeparator());

        // Alternatively, using %n for platform-independent new line
        System.out.printf("Line 1%n");
        System.out.printf("Line 2%n");
    }
}
```

## Summary:
- `%n` = "use whatever newline character this operating system expects"
- `\n` = "always use Unix-style newline, even on Windows"
- **Always prefer `%n`** in `printf()` and `format()` for cross-platform compatibility

---
---
--------------------------------------------------------------------------------------------------------------

==> Both `System.lineSeparator()` and `%n` give you platform-specific line separators, but there are some practical differences:

**`System.lineSeparator()` advantages:**

1. **Works everywhere** - You can use it in any string context (concatenation, StringBuilder, etc.), not just with formatted output methods
2. **More explicit** - It's clearer what you're doing when someone reads the code
3. **Reusable** - You can store it in a variable if you need it multiple times

```java
public class Test {
    public static void main(String[] args) {
        String separator = System.lineSeparator();
        String text = "Line 1" + separator + "Line 2" + separator + "Line 3";
        System.out.println(text);
    }
}

```

**`%n` advantages:**

1. **Cleaner in format strings** - Less verbose when you're already using `printf`, `String.format`, etc.
2. **Part of the format syntax** - Natural fit when building formatted output

```java
System.out.printf("Line 1%nLine 2%nLine 3");
```

**When to use which:**

- Use `System.lineSeparator()` for general string building, file writing, or when you need the separator outside of formatting contexts
- Use `%n` when you're already using format strings and want cleaner, more concise code

**Note:** Both are better than hardcoding `\n` if you want true cross-platform compatibility, since Windows uses `\r\n` while Unix-like systems use `\n`. However, for many modern applications (especially web or data exchange), using `\n` consistently is often fine and simpler.


### Practical rule

* **Data exchange / web payload / internal storage** → `\n` is totally fine.
* **User-visible text files on the local OS** → prefer `%n` or `System.lineSeparator()` (or `writer.newLine()`).

---
---
______________________________________________________________________________________________________________

==> https://dev.java/learn/api/streams/map-filter-reduce/

```
import java.time.LocalDate;
// For clarity, consider renaming amount to quantity,
// as it represents (number of items) rather than a monetary amount.
public record Sale(String product, LocalDate date, int amount) {
}


import java.time.LocalDate;
import java.time.Month;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<Sale> sales = List.of(
                new Sale("Orange", LocalDate.of(2022, Month.JANUARY, 2), 4),
                new Sale("Pumpkin", LocalDate.of(2022, Month.OCTOBER, 18), 12),
                new Sale("Butternut", LocalDate.of(2022, Month.OCTOBER, 03), 6),
                new Sale("Apple", LocalDate.of(2022, Month.AUGUST, 28), 3)
        );

        // Calculate the total amount sold in October
        int amountSoldInOctober = 0;
        for (Sale sale : sales) {
            if (sale.date().getMonth() == Month.OCTOBER) {
                amountSoldInOctober += sale.amount();
            }
        }

        System.out.println("Amount sold in October: " + amountSoldInOctober);  // Amount sold in October: 18

    }
}
```

#### MyNotes:
a) 
```
int amountSoldInOctober = 0;
        for (Sale sale : sales) {
            if (sale.date().getMonth() == Month.OCTOBER) {
                amountSoldInOctober += sale.amount();
            }
        }
```   

above code can be rewritten with Stream API:
```
int amountSoldInOctober = sales.stream()
                .filter(sale -> sale.date().getMonth() == Month.OCTOBER)
                .mapToInt(Sale::amount)
                .sum();
```

---
---
______________________________________________________________________________________________________________

==> 

```
public record Sale(String region, double amount) {
}


import java.util.Arrays;
import java.util.List;

public class Main {
    public static void main(String[] args) {

        List<Sale> sales = Arrays.asList(
                new Sale("North", 1500.0),
                new Sale("South", 2000.0),
                new Sale("East", 1750.0),
                new Sale("West", 2250.0),
                new Sale("North", 3000.0)
        );

        double totalNorthSales = sales.stream()
                .filter(sale -> "North".equals(sale.region()))
                .mapToDouble(Sale::amount)
                .sum();

        System.out.println("Total sales in North region: " + totalNorthSales);  // Total sales in North region: 4500.0

    }
}
```

---
---
-------------------------------------------------------------------------------------------------------------

==> Use BigDecimal in above program

```
import java.math.BigDecimal;

public record Sale(String region, BigDecimal amount) {
}


import java.util.Arrays;
import java.util.List;
import java.math.BigDecimal;

public class Main {
    public static void main(String[] args) {

        List<Sale> sales = Arrays.asList(
                new Sale("North", BigDecimal.valueOf(1500.0)),
                new Sale("South", BigDecimal.valueOf(2000.0)),
                new Sale("East", BigDecimal.valueOf(1750.0)),
                new Sale("West", BigDecimal.valueOf(2250.0)),
                new Sale("North", BigDecimal.valueOf(3000.0))
        );

        BigDecimal totalNorthSales = sales.stream()
                .filter(sale -> "North".equals(sale.region()))
                .map(Sale::amount)
                .reduce(BigDecimal.ZERO, BigDecimal::add);

        System.out.println("Total sales in North region: " + totalNorthSales);

    }
}
```

#### MyNotes:
a) 
```
Optional<BigDecimal> totalNorthSalesOpt = sales.stream()
                .filter(sale -> "North".equals(sale.region()))
                .map(Sale::amount)
                .reduce(BigDecimal::add);

        if (totalNorthSalesOpt.isPresent()) {
            BigDecimal totalNorthSales = totalNorthSalesOpt.get();
            System.out.println("Total sales in North region: " + totalNorthSales);
        } else {
            System.out.println("No sales in North region.");
        }
```

a.1) Use `Optional.ifPresentOrElse` (Java 9+) or `map(...).orElse(...)` (Java 8) to avoid `isPresent`/`get` boilerplate.

// Java 9+
```
totalNorthSalesOpt.ifPresentOrElse(
                total -> System.out.println("Total sales in North region: " + total),
                () -> System.out.println("No sales in North region.")
        );
```

// Java 8 alternative
```
System.out.println(
    totalNorthSalesOpt
        .map(total -> "Total sales in North region: " + total)
        .orElse("No sales in North region.")
);
```

b) 
```
sales.stream()
                .filter(sale -> "North".equals(sale.region()))
                .map(Sale::amount)
                .reduce(BigDecimal::add)
                .ifPresentOrElse(
                        totalNorthSales -> System.out.println("Total sales in North region: " + totalNorthSales),
                        () -> System.out.println("No sales in North region")
                );
```

---
---
______________________________________________________________________________________________________________


==> 
https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/time/LocalDate.html#of(int,java.time.Month,int)
https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/time/LocalDate.html#of(int,int,int)

Here’s a simple Java demo showing **both** overloads:

* `LocalDate.of(int year, int month, int dayOfMonth)`
* `LocalDate.of(int year, Month month, int dayOfMonth)`

```
import java.time.LocalDate;
import java.time.Month;

public class LocalDateOfDemo {

    public static void main(String[] args) {
        // 1) LocalDate.of(int year, int month, int dayOfMonth)
        LocalDate d1 = LocalDate.of(2026, 1, 22); // month=1 means January
        System.out.println("Using (int, int, int):      " + d1);

        // 2) LocalDate.of(int year, Month month, int dayOfMonth)
        LocalDate d2 = LocalDate.of(2026, Month.JANUARY, 22);
        System.out.println("Using (int, Month, int):    " + d2);

        // show the components are the same
        System.out.println("Same date? " + d1.equals(d2));

        // demonstrate invalid values -> DateTimeException
        try {
            LocalDate bad = LocalDate.of(2026, 13, 1); // invalid month
            System.out.println(bad);
        } catch (DateTimeException e) {
            System.out.println("Invalid (int month) example: " + e.getClass().getSimpleName()
                    + " - " + e.getMessage());
        }
    }
}
```

#### Output:
```
Using (int, int, int):      2026-01-22
Using (int, Month, int):    2026-01-22
Same date? true
Invalid (int month) example: DateTimeException - Invalid value for MonthOfYear (valid values 1 - 12): 13


#### MyNotes:
a) why should we use `.equals` and not `==`

When comparing `LocalDate` objects (or any objects in Java), you should use `.equals()` instead of `==` because:

- **`==` compares object references** (memory addresses). It checks if both variables point to the exact same object instance in memory.
- **`.equals()` compares object content** (values). For `LocalDate`, it checks if both dates represent the same year, month, and day.

In your code, `d1` and `d2` are two **separate objects** created by different `LocalDate.of()` calls, even though they represent the same date (2026-01-22). Using `==` would return `false` because they're different instances in memory, while `.equals()` correctly returns `true` because they have the same date values.

**Example:**
```
import java.time.LocalDate;

public class Main {
    public static void main(String[] args) {
        LocalDate d1 = LocalDate.of(2026, 1, 22);
        LocalDate d2 = LocalDate.of(2026, 1, 22);

        System.out.println(d1 == d2);        // false - different objects
        System.out.println(d1.equals(d2));   // true - same date values
    }
}

```

**Rule of thumb:** Always use `.equals()` for object comparisons in Java, and use `==` only for primitive types (int, boolean, etc.) or when you specifically need to check if two references point to the same object.

---
---
______________________________________________________________________________________________________________


==> https://dev.java/learn/api/streams/map-filter-reduce/

```
public record City(int population) {
}

import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<City> cities =
                List.of(
                        new City(100_000),
                        new City(200_000),
                        new City(500_000));

        int sum = 0;
        for (City city: cities) {
            int population = city.population();
            if (population > 100_000) {
                sum += population;
            }
        }

        System.out.println("Total population of cities with more than 100,000 inhabitants: " + sum);
    }
}
```

#### Output:
```
Total population of cities with more than 100,000 inhabitants: 700000
```

#### MyNotes:
a) 
```
int sum = 0;
        for (City city: cities) {
            int population = city.population();
            if (population > 100_000) {
                sum += population;
```				

above code can be rewritten with Stream API:
```
int sum = cities.stream()
                .mapToInt(City::population)
                .filter(population -> population > 100_000)
                .sum();
```

---
---
______________________________________________________________________________________________________________

==> Let us see the `flatMap` operation in an example.
https://dev.java/learn/api/streams/intermediate-operation/

```
public record City(String name, int population) {
}


import java.util.List;

public record Country(String name, List<City> cities) {
}


import java.util.List;

public class Main {
    public static void main(String[] args) {
        City newYork= new City("New York", 8_258);
        City losAngeles = new City("Los Angeles", 3_821);
        Country usa = new Country("USA", List.of(newYork, losAngeles));

        City london = new City("London", 8_866);
        City manchester = new City("Manchester", 568);
        Country uk = new Country("United Kindgom", List.of(london, manchester));

        City paris = new City("Paris", 2_103);
        City marseille = new City("Marseille", 877);
        Country france = new Country("France", List.of(paris, marseille));

        List<Country> countries = List.of(usa, uk, france);

        int totalPopulation = 0;
        for (Country country: countries) {
            for (City city: country.cities()) {
                totalPopulation += city.population();
            }
        }

        System.out.println("Total population across all countries: " + totalPopulation);

    }
}
```

#### Output:
```
Total population across all countries: 24493K
```

#### MyNotes:
a) 
```
int totalPopulation = 0;
        for (Country country: countries) {
            for (City city: country.cities()) {
                totalPopulation += city.population();
            }
        }
```				

above code can be rewritten with Stream API:
```
int totalPopulation =
                countries.stream()
                        .flatMap(country -> country.cities().stream())
                        .mapToInt(City::population)
                        .sum();
```


b) It's perfectly fine to use underscores (`_`) in numeric literals in Java. This feature was introduced in **Java 7** to improve readability of large numbers.

The underscores are ignored by the compiler and serve only as visual separators. You can place them between digits to make numbers easier to read:

```java
int largeNumber = 1_000_000;  // One million
int phoneNumber = 555_123_4567;
double pi = 3.141_592_653_589;
```

**Rules for using underscores:**
- Can only be placed between digits
- Cannot be at the beginning or end of a number
- Cannot be adjacent to a decimal point

In your code, `8_258` represents 8,258 (eight thousand two hundred fifty-eight), which is a common way to separate thousands for better readability.


c)  // Print the names of all cities with a population greater than 8000
        countries.stream()
                .flatMap(country -> country.cities().stream())
                .filter(city -> city.population() > 8_000)
                .forEach(city -> System.out.println(city.name() + ": " + city.population()));


d) // Find and print the city with the highest population
        countries.stream()
                .flatMap(country -> country.cities().stream())
                .max(Comparator.comparingInt(City::population))
                .ifPresent(city -> System.out.println("City with highest population: " + city.name() + " (" + city.population() + ")"));


d.1) 
```
// find and print the city with the highest population
        City mostPopulousCity = countries.stream()
                .flatMap(country -> country.cities().stream())
                .max((city1, city2) -> Integer.compare(city1.population(), city2.population()))
                .orElse(null);

        if (mostPopulousCity != null) {
            System.out.println("The most populous city is " + mostPopulousCity.name() + " with a population of " + mostPopulousCity.population());
        } else {
            System.out.println("No cities found.");
        }
```


e) // calculate and print the average population of cities in each country
        countries.forEach(country -> {
            double averagePopulation = country.cities().stream()
                    .mapToInt(City::population)
                    .average()
                    .orElse(0);
            System.out.println("Average population in " + country.name() + ": " + averagePopulation);
        });


f) 
- Combined all country declarations into a single `List.of()` call
- Inlined all `City` and `Country` object creation

```
List<Country> countries = List.of(
    new Country("USA", List.of(
        new City("New York", 8_258),
        new City("Los Angeles", 3_821)
    )),
    new Country("United Kingdom", List.of(
        new City("London", 8_866),
        new City("Manchester", 568)
    )),
    new Country("France", List.of(
        new City("Paris", 2_103),
        new City("Marseille", 877)
    ))
);
```

---
---
______________________________________________________________________________________________________________

==> Example program to calculate age in years, months, days, and total days
https://dev.java/learn/date-time/period-duration/

```
import java.time.LocalDate;
import java.time.Month;
import java.time.Period;
import java.time.temporal.ChronoUnit;

public class Main {
    public static void main(String[] args) {
        LocalDate today = LocalDate.now();
        LocalDate birthday = LocalDate.of(1980, Month.DECEMBER, 29);

        Period p = Period.between(birthday, today);
        long p2 = ChronoUnit.DAYS.between(birthday, today);
        System.out.println("You are " + p.getYears() + " years, " + p.getMonths() +
                " months, and " + p.getDays() +
                " days old. (" + p2 + " days total)");

    }

}
```

#### Output:
```
You are 44 years, 11 months, and 28 days old. (16434 days total)
```

---
---
______________________________________________________________________________________________________________

==> To calculate how long it is until your next birthday
https://dev.java/learn/date-time/period-duration/

```
import java.time.LocalDate;
import java.time.Month;
import java.time.Period;
import java.time.temporal.ChronoUnit;

/**
 * This program calculates the time remaining until the user's next birthday.
 * It uses the `LocalDate` class to handle dates, the `Period` class to calculate
 * the difference in months and days, and the `ChronoUnit` class to calculate
 * the total number of days.
 */
public class Main {
    public static void main(String[] args) {

        // Get the current date
        LocalDate today = LocalDate.now();

        // Define the user's birthday (year is arbitrary, only month and day are relevant)
        LocalDate birthday = LocalDate.of(1960, Month.JANUARY, 1);

        // Adjust the birthday to the current year
        LocalDate nextBDay = birthday.withYear(today.getYear());

        // If the birthday has already occurred this year, move it to the next year
        if (nextBDay.isBefore(today) || nextBDay.isEqual(today)) {
            nextBDay = nextBDay.plusYears(1);
        }

        // Calculate the period (months and days) between today and the next birthday
        Period p = Period.between(today, nextBDay);

        // Calculate the total number of days between today and the next birthday
        long p2 = ChronoUnit.DAYS.between(today, nextBDay);

        System.out.println("There are " + p.getMonths() + " months, and " +
                p.getDays() + " days until your next birthday. (" +
                p2 + " total)");
    }
}
```

#### Output:
```
There are 0 months, and 5 days until your next birthday. (5 total)
```

---
---
______________________________________________________________________________________________________________

==> 

Above program is updated, that accounts for time zone differences using `Period` with `ZonedDateTime`:

```
import java.time.*;
import java.time.temporal.ChronoUnit;

/**
 * This program calculates the time remaining until the user's next birthday.
 * It uses the `ZonedDateTime` class to handle dates with time zone information,
 * the `Period` class to calculate the difference in months and days, and the
 * `ChronoUnit` class to calculate the total number of days.
 */
public class Main {
    public static void main(String[] args) {

        // Get the current date and time in the system's default time zone
        ZonedDateTime today = ZonedDateTime.now();

        // Define the user's birthday with time zone (year is arbitrary, only month and day are relevant)
        ZonedDateTime birthday = ZonedDateTime.of(1960, Month.JANUARY.getValue(), 1, 0, 0, 0, 0, ZoneId.systemDefault());

        // Adjust the birthday to the current year
        ZonedDateTime nextBDay = birthday.withYear(today.getYear());

        // If the birthday has already occurred this year, move it to the next year
        if (nextBDay.isBefore(today) || nextBDay.isEqual(today)) {
            nextBDay = nextBDay.plusYears(1);
        }

        // Calculate the period (months and days) between today and the next birthday
        Period p = Period.between(today.toLocalDate(), nextBDay.toLocalDate());

        // Calculate the total number of days between today and the next birthday
        long p2 = ChronoUnit.DAYS.between(today, nextBDay);

        // Print the results with time zone information
        System.out.println("There are " + p.getMonths() + " months, and " +
                p.getDays() + " days until your next birthday. (" +
                p2 + " total)");
        System.out.println("Time zone: " + today.getZone());
    }
}

```

The key changes:
- Replaced `LocalDate` with `ZonedDateTime` to include time zone information
- Used `ZoneId.systemDefault()` to get the system's time zone
- Converted `ZonedDateTime` to `LocalDate` when calculating the `Period`
- Added output showing the time zone being used

---
---
______________________________________________________________________________________________________________

==> Above program is updated with Japan's time zone:

```java
import java.time.*;
import java.time.temporal.ChronoUnit;

/**
 * This program calculates the time remaining until the user's next birthday.
 * It uses the `ZonedDateTime` class to handle dates with time zone information,
 * the `Period` class to calculate the difference in months and days, and the
 * `ChronoUnit` class to calculate the total number of days.
 */
public class Main {
    public static void main(String[] args) {

        // Get the current date and time in Japan's time zone
        ZonedDateTime today = ZonedDateTime.now(ZoneId.of("Asia/Tokyo"));

        // Define the user's birthday with Japan's time zone (year is arbitrary, only month and day are relevant)
        ZonedDateTime birthday = ZonedDateTime.of(1960, Month.JANUARY.getValue(), 1, 0, 0, 0, 0, ZoneId.of("Asia/Tokyo"));

        // Adjust the birthday to the current year
        ZonedDateTime nextBDay = birthday.withYear(today.getYear());

        // If the birthday has already occurred this year, move it to the next year
        if (nextBDay.isBefore(today) || nextBDay.isEqual(today)) {
            nextBDay = nextBDay.plusYears(1);
        }

        // Calculate the period (months and days) between today and the next birthday
        Period p = Period.between(today.toLocalDate(), nextBDay.toLocalDate());

        // Calculate the total number of days between today and the next birthday
        long p2 = ChronoUnit.DAYS.between(today, nextBDay);

        // Print the results with time zone information
        System.out.println("There are " + p.getMonths() + " months, and " +
                p.getDays() + " days until your next birthday. (" +
                p2 + " total)");
        System.out.println("Time zone: " + today.getZone());
    }
}
```

The key changes:
- Replaced `ZoneId.systemDefault()` with `ZoneId.of("Asia/Tokyo")` for Japan's time zone
- Applied the change to both the `today` and `birthday` variables

---
---
______________________________________________________________________________________________________________

==> few examples to demonstrate https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/math/BigDecimal.html#add(java.math.BigDecimal)

Here are a few quick examples that specifically use `BigDecimal#add(BigDecimal)`.

```
import java.math.BigDecimal;

public class BigDecimalAddExamples {
    public static void main(String[] args) {

        // 1) Basic money-style addition (use String constructors for exact decimals)
        BigDecimal price = new BigDecimal("10.25");
        BigDecimal tax = new BigDecimal("3.40");
        BigDecimal total = price.add(tax);
        System.out.println("1) total = " + total);          // 13.65

        // 2) Scale behavior: result scale is the max(scale(left), scale(right))
        BigDecimal a = new BigDecimal("1.20"); // scale 2
        BigDecimal b = new BigDecimal("3");    // scale 0
        BigDecimal s = a.add(b);
        System.out.println("\n2) 1.20 + 3 = " + s);         // 4.20
        System.out.println("   scale = " + s.scale());      // 2

        // 3) Why NOT to use new BigDecimal(double): binary floating point surprises
        BigDecimal bad = new BigDecimal(0.1).add(new BigDecimal(0.2));
        BigDecimal good = BigDecimal.valueOf(0.1).add(BigDecimal.valueOf(0.2));
        BigDecimal best = new BigDecimal("0.1").add(new BigDecimal("0.2"));
        System.out.println("\n3) new BigDecimal(0.1)+new BigDecimal(0.2) = " + bad);
        System.out.println("   BigDecimal.valueOf(0.1)+valueOf(0.2)       = " + good);
        System.out.println("   new BigDecimal(\"0.1\")+\"0.2\"             = " + best);

        // 4) Simple accumulator (BigDecimal is immutable, so re-assign).
        // It means BigDecimal instances cannot be changed after they're created.
        // Operations like `add()` return a new `BigDecimal` rather than modifying the original,
        // so you must store the returned value (re-assign) if you want to keep the result.
        BigDecimal sum = BigDecimal.ZERO;
        BigDecimal[] amounts = {
                new BigDecimal("19.99"),
                new BigDecimal("5.00"),
                new BigDecimal("-2.50")
        };
        for (BigDecimal amt : amounts) {
            sum = sum.add(amt);
        }
        System.out.println("\n4) accumulated sum = " + sum); // 22.49
    }
}
```

#### Output:
```
1) total = 13.65

2) 1.20 + 3 = 4.20
   scale = 2

3) new BigDecimal(0.1)+new BigDecimal(0.2) = 0.3000000000000000166533453693773481063544750213623046875
   BigDecimal.valueOf(0.1)+valueOf(0.2)       = 0.3
   new BigDecimal("0.1")+"0.2"             = 0.3

4) accumulated sum = 22.49
```

Key takeaways:

* `add()` **doesn’t modify** either operand (immutable) → always use the returned value.
* Prefer `new BigDecimal("...")` (or `BigDecimal.valueOf(double)`) for decimal literals, especially money.


---
---
______________________________________________________________________________________________________________

==> BigDecimal instances cannot be changed after they're created. Operations like `add()` return a new `BigDecimal` rather than modifying the original, so you must store the returned value (re-assign) if you want to keep the result.

Example showing incorrect vs correct usage:

```
import java.math.BigDecimal;

public class Main {
    public static void main(String[] args) {
        BigDecimal sum = BigDecimal.ZERO;
        BigDecimal amt = new BigDecimal("5.00");

        // Incorrect: result is ignored, sum remains ZERO
        sum.add(amt);
        System.out.println(sum); // prints 0

        // Correct: re-assign the returned BigDecimal
        sum = sum.add(amt);
        System.out.println(sum); // prints 5.00
    }
}
```

---
---
--------------------------------------------------------------------------------------------------------------

==> Here's a list of few **immutable classes in Java** where you need to **re-assign** the result of operations:

## Common Immutable Classes:

**1. `java.math.BigDecimal`** (as you mentioned)
```java
BigDecimal price = new BigDecimal("100.50");
price = price.add(new BigDecimal("10.00")); // Must re-assign
```

**2. `java.math.BigInteger`**
```java
BigInteger num = new BigInteger("1000");
num = num.add(new BigInteger("500")); // Must re-assign
num = num.multiply(new BigInteger("2")); // Must re-assign
```

**3. `java.lang.String`**
```java
String name = "John";
name = name.concat(" Doe"); // Must re-assign
name = name.toUpperCase(); // Must re-assign
name = name.replace("JOHN", "Jane"); // Must re-assign
```

**4. `java.time` package classes (Java 8+)**
```java
// LocalDate
LocalDate date = LocalDate.now();
date = date.plusDays(5); // Must re-assign
date = date.minusMonths(2); // Must re-assign

// LocalTime
LocalTime time = LocalTime.now();
time = time.plusHours(3); // Must re-assign

// LocalDateTime
LocalDateTime dateTime = LocalDateTime.now();
dateTime = dateTime.plusWeeks(1); // Must re-assign

// ZonedDateTime, Instant, Duration, Period - all immutable
```

**5. Wrapper Classes** (when using certain methods)
```java
Integer num = 10;
// Note: Autoboxing creates new objects, but arithmetic operators handle it
// Methods like Integer.sum() return new values
```

**6. `java.util.regex.Pattern` and `Matcher`**
```java
Pattern pattern = Pattern.compile("[a-z]+");
// Pattern is immutable, but Matcher is stateful
```

**7. `java.util.Optional` (Java 8+)**
```java
Optional<String> opt = Optional.of("value");
opt = opt.map(String::toUpperCase); // Must re-assign for transformations
```

**8. Records (Java 14+)**
```java
record Point(int x, int y) {
    Point moveRight() {
        return new Point(x + 1, y); // Returns new instance
    }
}

Point p = new Point(0, 0);
p = p.moveRight(); // Must re-assign
```

## Key Pattern:
All these classes follow the **immutability principle**: operations return **new instances** rather than modifying the original object. This is why you must re-assign the returned value if you want to use the updated result.

---
---
--------------------------------------------------------------------------------------------------------------

==> Demonstrates LocalDateTime.plusWeeks() and immutability

```
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class LocalDateTimePlusWeeksDemo {

    public static void main(String[] args) {
        // LocalDateTime (immutable)
        LocalDateTime dateTime = LocalDateTime.now();
        System.out.println("Now           : " + format(dateTime));

        // plusWeeks() returns a NEW LocalDateTime, so you must re-assign (or use a new variable)
        dateTime = dateTime.plusWeeks(1);
        System.out.println("After +1 week  : " + format(dateTime));

        // Proof: original value doesn't change unless you store the returned value
        LocalDateTime original = LocalDateTime.now();
        original.plusWeeks(1); // ignored result
        System.out.println("Original (unchanged) : " + format(original));

        LocalDateTime updated = original.plusWeeks(1); // stored result
        System.out.println("Updated (new object) : " + format(updated));
    }

    // Helper to format LocalDateTime for display
    private static String format(LocalDateTime dt) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        return dt.format(formatter);
    }
}
```

#### Output:
```
Now           : 2026-01-24 16:38:06
After +1 week  : 2026-01-31 16:38:06
Original (unchanged) : 2026-01-24 16:38:06
Updated (new object) : 2026-01-31 16:38:06
```

---
---
______________________________________________________________________________________________________________


==> Below are **quick Java examples** for few `reduce(...)` overloads  (Stream + primitive streams). 

https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/stream/Stream.html#reduce(java.util.function.BinaryOperator)
https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/stream/Stream.html#reduce(T,java.util.function.BinaryOperator)
https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/stream/IntStream.html#reduce(java.util.function.IntBinaryOperator)
https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/stream/IntStream.html#reduce(int,java.util.function.IntBinaryOperator)


```
import java.util.*;
import java.util.stream.*;

public class ReduceOverloadsDemo {

    public static void main(String[] args) {

        // ----------------------------
        // 1) Stream.reduce(BinaryOperator<T>) -> Optional<T>
        // ----------------------------
        Optional<Integer> sumOpt =
                Stream.of(1, 2, 3, 4).reduce(Integer::sum);
        System.out.println("1) Optional sum = " + sumOpt.orElse(null)); // 10

        Optional<Integer> emptyOpt =
                Stream.<Integer>empty().reduce(Integer::sum);
        System.out.println("1) Empty stream -> " + emptyOpt); // Optional.empty


        // ----------------------------
        // 2) Stream.reduce(T identity, BinaryOperator<T>) -> T
        //    (No Optional; identity returned for empty stream)
        // ----------------------------
        int sumWithIdentity =
                Stream.of(1, 2, 3, 4).reduce(0, Integer::sum);
        System.out.println("2) Sum with identity = " + sumWithIdentity); // 10

        int emptyWithIdentity =
                Stream.<Integer>empty().reduce(0, Integer::sum);
        System.out.println("2) Empty stream -> " + emptyWithIdentity); // 0


        // ============================
        // Primitive streams overloads
        // ============================

        // ----------------------------
        // 4) IntStream.reduce(IntBinaryOperator) -> OptionalInt
        // ----------------------------
        OptionalInt maxInt = IntStream.of(5, 2, 9, 1).reduce(Integer::max);
        System.out.println("4) OptionalInt max = " + (maxInt.isPresent() ? maxInt.getAsInt() : null)); // 9

        // 5) IntStream.reduce(int identity, IntBinaryOperator) -> int
        int product = IntStream.of(2, 3, 4).reduce(1, (a, b) -> a * b);
        System.out.println("5) int product = " + product); // 24


        // ----------------------------
        // 6) DoubleStream.reduce(DoubleBinaryOperator) -> OptionalDouble
        // ----------------------------
        OptionalDouble minD = DoubleStream.of(2.5, 1.2, 9.0).reduce(Double::min);
        System.out.println("6) OptionalDouble min = " + (minD.isPresent() ? minD.getAsDouble() : null)); // 1.2

        // 7) DoubleStream.reduce(double identity, DoubleBinaryOperator) -> double
        double sumD = DoubleStream.of(1.1, 2.2, 3.3).reduce(0.0, Double::sum);
        System.out.println("7) double sum = " + sumD); // 6.6


        // 9) LongStream.reduce(long identity, LongBinaryOperator) -> long
        long maxL = LongStream.of(10L, 5L, 99L).reduce(Long.MIN_VALUE, Math::max);
        System.out.println("9) long max = " + maxL); // 99
    }

}
```

#### Output:
```
1) Optional sum = 10
1) Empty stream -> Optional.empty
2) Sum with identity = 10
2) Empty stream -> 0
4) OptionalInt max = 9
5) int product = 24
6) OptionalDouble min = 1.2
7) double sum = 6.6
9) long max = 99
```

### Tiny mental model

* **No identity** (`reduce(op)`): returns **Optional** because stream might be empty.
* **With identity** (`reduce(identity, op)`): returns **a value always** (identity for empty).


---
---
--------------------------------------------------------------------------------------------------------------

==> do we really give the identity as 1 or 2 ? as in below program:

No — the identity must be the neutral element for the accumulator. For integer addition the identity is 0. Supplying 1 or 2 is allowed syntactically but they are not identities: they just shift the result (and can break correctness for parallel reductions).

```
import java.util.stream.Stream;

public class Main {

    public static void main(String[] args) {

        System.out.println(Stream.of(1, 2, 3, 4).reduce(Integer::sum));     // Optional[10]
        System.out.println(Stream.of(1, 2, 3, 4).reduce(0, Integer::sum));      // 10
        System.out.println(Stream.of(1, 2, 3, 4).reduce(1, Integer::sum));      // 11
        System.out.println(Stream.of(1, 2, 3, 4).reduce(2, Integer::sum));      // 12

    }

}
```

---
---
--------------------------------------------------------------------------------------------------------------

==> "they just shift the result (and can break correctness for parallel reductions)."  what do you mean by this statement in your above explanation ?

It means two things:

- "Shift the result": using a non-neutral identity (e.g., 1 for addition) adds that value once to the final sum, so result = sum(elements) + identity.
- "Can break correctness for parallel reductions": in a parallel stream the reduction runs on multiple sub-partitions. The identity is applied in each partition, so a wrong identity gets added once per partition — producing a different result depending on how the stream is split.

Brief example showing sequential vs parallel behavior:

Explanation: sequential reduce with identity 1 yields sum + 1; parallel reduce may add the identity multiple times (once per partition), producing a larger offset.

```
import java.util.stream.Stream;

public class Main {

    public static void main(String[] args) {

        // sequential: identity 1 shifts result by +1
        System.out.println(Stream.of(1, 2, 3, 4).reduce(1, Integer::sum)); // 11

        // parallel: identity 1 can be applied per partition => extra shifts
        System.out.println(Stream.of(1, 2, 3, 4).parallel().reduce(1, Integer::sum)); // often 12 or a different value (depends on splitting)

    }

}

```

---
---
______________________________________________________________________________________________________________

==> explain why BigDecimal.TWO was added in java 19 compared to ONE, TWO, TEN added in 1.5 ?
 https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/math/BigDecimal.html#ZERO
https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/math/BigDecimal.html#ONE
https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/math/BigDecimal.html#TWO
https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/math/BigDecimal.html#TEN

Based on the documentation you've shared, `BigDecimal.TWO` was added in Java 19, while `ZERO`, `ONE`, and `TEN` were all added much earlier in version 1.5.

The most likely reason for this late addition is that **it wasn't previously needed enough to justify inclusion**, but eventually became useful for common operations. Here are some probable factors:

**Why it was finally added:**
- **Consistency and completeness** - Having constants for 0, 1, and 10 but not 2 created an asymmetry in the API
- **Common use cases** - The value 2 appears frequently in calculations (division by 2, doubling, etc.)
- **Performance optimization** - Creating `new BigDecimal(2)` repeatedly is wasteful when a reusable constant could serve the same purpose
- **Developer convenience** - Reduces boilerplate code for a commonly used value

**Why it took until Java 19:**
- The Java team is generally conservative about API additions to maintain backward compatibility and avoid bloat
- Since developers could easily create `new BigDecimal(2)` or `BigDecimal.ONE.add(BigDecimal.ONE)`, it wasn't urgent
- The cost/benefit ratio probably didn't justify it until there was enough developer demand or internal use cases

It's worth noting that `TEN` was likely included early on because it's particularly useful for scaling operations (moving decimal points), which is a fundamental BigDecimal use case. The value 2, while common, didn't have such a unique role.

---
---
--------------------------------------------------------------------------------------------------------------

==> a small example to demonstrate scaling operations (moving decimal points) with BigDecimal.TEN
```
import java.math.BigDecimal;

public class Main {
    public static void main(String[] args) {
        BigDecimal price = new BigDecimal("123.456");

        System.out.println("Original: " + price);

        // Move decimal point 1 place right (multiply by 10)
        BigDecimal timesOne = price.multiply(BigDecimal.TEN);
        System.out.println("× 10¹:    " + timesOne);  // 1234.56

        // Move decimal point 2 places right (multiply by 100)
        BigDecimal timesTwo = price.multiply(BigDecimal.TEN).multiply(BigDecimal.TEN);
        System.out.println("× 10²:    " + timesTwo);  // 12345.6

        // Move decimal point 1 place left (divide by 10)
        BigDecimal divideOne = price.divide(BigDecimal.TEN);
        System.out.println("÷ 10¹:    " + divideOne); // 12.3456

        // Converting cents to dollars
        BigDecimal cents = new BigDecimal("12599"); // $125.99 in cents
        BigDecimal dollars = cents.divide(new BigDecimal("100"));
        System.out.println("\nCents to dollars: " + cents + " → $" + dollars);

        // Using TEN.pow(n) for larger scale changes
        BigDecimal kilometers = new BigDecimal("5.2");
        BigDecimal millimeters = kilometers.multiply(BigDecimal.TEN.pow(6));
        System.out.println("\n5.2 km = " + millimeters + " mm");
    }
}
```

#### Output:
```
Original: 123.456
× 10¹:    1234.560
× 10²:    12345.600
÷ 10¹:    12.3456

Cents to dollars: 12599 → $125.99

5.2 km = 5200000.0 mm
```

---
---
______________________________________________________________________________________________________________







