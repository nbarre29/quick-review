
# ðŸ”¹ Decorator Design Pattern

## 1. Concept

* **Category:** Structural design pattern.
* **Intent:** Attach **additional behavior** or responsibilities to objects **dynamically** without altering their class.
* **Key idea:** Wrap the original object inside a *decorator object* that implements the same interface.
* **Real-world analogy:** Think of a **coffee** â†’ you can decorate it with **milk, sugar, whipped cream** etc. Each decoration adds new behavior but the base coffee stays the same.

---

## 2. Example: Coffee Shop

### Component (interface)

// Component
public interface Coffee {
    String getDescription();
    double getCost();
}

---

### Concrete Component (base object)

// Concrete Component
public class SimpleCoffee implements Coffee {
    @Override
    public String getDescription() {
        return "Simple Coffee";
    }

    @Override
    public double getCost() {
        return 5.0;
    }
}

---

### Base Decorator

// Decorator (implements same interface and wraps another Coffee)
public abstract class CoffeeDecorator implements Coffee {
    protected Coffee decoratedCoffee;

    public CoffeeDecorator(Coffee decoratedCoffee) {
        this.decoratedCoffee = decoratedCoffee;
    }

    @Override
    public String getDescription() {
        return decoratedCoffee.getDescription();
    }

    @Override
    public double getCost() {
        return decoratedCoffee.getCost();
    }
}

MyNotes: 
1) The class is marked as `abstract` because it is intended to serve as a base for other decorators and should not be instantiated directly. While it does not declare any abstract methods, marking it as `abstract` prevents direct instantiation and signals its role in the design pattern. This is a common practice in the Decorator pattern to enforce proper usage.

2) `protected` allows subclasses to access `decoratedCoffee`, which is useful in the Decorator pattern since concrete decorators often need to interact with the wrapped object.  
`private final` would restrict access to only the `CoffeeDecorator` class and prevent reassignment, which may limit flexibility for subclasses.  
In this pattern, `protected` is preferred to support extension and customization by subclasses.

---

### Concrete Decorators

// Add Milk
public class MilkDecorator extends CoffeeDecorator {
    public MilkDecorator(Coffee decoratedCoffee) {
        super(decoratedCoffee);
    }

    @Override
    public String getDescription() {
        return super.getDescription() + ", Milk";
    }

    @Override
    public double getCost() {
        return super.getCost() + 1.5;
    }
}

MyNotes: 
1)
public MilkDecorator(Coffee decoratedCoffee) {
        super(decoratedCoffee);
    }

The selected code is the constructor for the `MilkDecorator` class. It takes a `Coffee` object as a parameter:  
`public MilkDecorator(Coffee decoratedCoffee)`

Inside the constructor, it calls the superclass constructor using `super(decoratedCoffee);`. This means that the `MilkDecorator` is passing the `decoratedCoffee` object up to its parent class, `CoffeeDecorator`, which likely stores this reference for later use. This pattern is typical in the Decorator design pattern, where each decorator wraps another object to add new behavior.

By accepting a `Coffee` object and forwarding it to the superclass, `MilkDecorator` can extend or modify the behavior of the original coffee instance, such as adding milk to its description or cost. This approach allows decorators to be chained, each adding its own functionality while maintaining a reference to the wrapped object.


// Add Sugar
public class SugarDecorator extends CoffeeDecorator {
    public SugarDecorator(Coffee decoratedCoffee) {
        super(decoratedCoffee);
    }

    @Override
    public String getDescription() {
        return super.getDescription() + ", Sugar";
    }

    @Override
    public double getCost() {
        return super.getCost() + 0.5;
    }
}

---

### Client

public class Client {
    public static void main(String[] args) {
        Coffee coffee = new SimpleCoffee();
        System.out.println(coffee.getDescription() + " $" + coffee.getCost());

        // Add milk
        coffee = new MilkDecorator(coffee);
        System.out.println(coffee.getDescription() + " $" + coffee.getCost());

        // Add sugar
        coffee = new SugarDecorator(coffee);
        System.out.println(coffee.getDescription() + " $" + coffee.getCost());
    }
}

---

### Output

Simple Coffee $5.0
Simple Coffee, Milk $6.5
Simple Coffee, Milk, Sugar $7.0

---

## 3. Why is this Decorator?

* Both **component** and **decorator** implement the same interface (`Coffee`).
* Decorators **wrap** the base object and **add behavior dynamically**.
* You can add **any number of decorators** in any order â€” itâ€™s flexible and extensible.
* This avoids subclass explosion (e.g., `MilkCoffee`, `SugarCoffee`, `MilkSugarCoffee` â€¦).

---

âœ… So the **Decorator pattern** = *wrapping objects with additional behavior, transparently to the client*.

---


