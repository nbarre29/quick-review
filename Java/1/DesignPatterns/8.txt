The Composite design pattern is a structural design pattern that allows you to compose objects into tree structures and then work with these structures as if they were individual objects. It is particularly useful when dealing with part-whole hierarchies, where both individual objects (leaves) and compositions of objects (composites) need to be treated uniformly. 

 
Key Components of the Composite Pattern: 

• Component: This is the common interface or abstract class that defines the operations that both leaf and composite objects will implement. This allows clients to interact with all objects in the hierarchy uniformly. 
• Leaf: Represents the individual, atomic objects in the composition. Leaves do not have children and implement the operations defined in the Component interface directly. 
• Composite: Represents the complex objects that can contain children (either other composites or leaves). The Composite class also implements the Component interface and typically delegates operations to its children, often recursively. It also provides methods for adding and removing children. 


How it works in Java: 
Consider a file system as an example. You have File (leaf) and Directory (composite) objects. Both can be treated as FileSystemComponent (component) and can have operations like display(). 

// Component Interface
public interface FileSystemComponent {
    void display();
}

// Leaf Class
public class File implements FileSystemComponent {
    private final String name;

    public File(String name) {
        this.name = name;
    }

    @Override
    public void display() {
        System.out.println("File: " + name);
    }
}


import java.util.ArrayList;
import java.util.List;

// Composite Class
public class Directory implements FileSystemComponent {
    private final String name;
    private final List<FileSystemComponent> children = new ArrayList<>();

    public Directory(String name) {
        this.name = name;
    }

    public void add(FileSystemComponent component) {
        children.add(component);
    }

    public void remove(FileSystemComponent component) {
        children.remove(component);
    }

    @Override
    public void display() {
        System.out.println("Directory: " + name);
        for (FileSystemComponent component : children) {
            component.display();
        }
    }
}

// Client Usage
public class Client {
    public static void main(String[] args) {
        File file1 = new File("document.txt");
        File file2 = new File("image.jpg");

        Directory subDirectory = new Directory("SubFolder");
        subDirectory.add(new File("report.pdf"));

        Directory rootDirectory = new Directory("Root");
        rootDirectory.add(file1);
        rootDirectory.add(file2);
        rootDirectory.add(subDirectory);

        rootDirectory.display();
    }
}

Output:
Directory: Root
File: document.txt
File: image.jpg
Directory: SubFolder
File: report.pdf

Benefits: 

• Uniformity: Clients can treat individual objects and compositions of objects uniformly through the common Component interface. 
• Flexibility: Easily add new types of components (leaves or composites) without modifying existing client code. 
• Hierarchical Structure: Effectively represents part-whole hierarchies and tree-like structures. 

_______________________________________________________________________________________________

