**Flyweight Design Pattern** is a **structural design pattern** used to **reduce memory usage** by **sharing objects** that are similar instead of creating new ones every time.

Let‚Äôs go step-by-step üëá

---

## üß© **Concept**

**Problem it solves:**
When you have **many objects with identical or similar data**, memory consumption increases unnecessarily.

**Solution:**
Separate the object‚Äôs **intrinsic (shared)** state from its **extrinsic (unique)** state and **reuse** objects that share the same intrinsic data.

---

## üß† **Key Idea**

* **Intrinsic State:** Immutable data that can be shared (e.g., color, shape).
* **Extrinsic State:** Data that varies per use (e.g., position, size).
* A **Flyweight Factory** manages the pool of shared objects.


## ‚öôÔ∏è **When to Use Flyweight**

Use when:

* You have **a large number of similar objects**.
* Object creation is **memory expensive**.
* The shared (intrinsic) state can be **decoupled** from unique (extrinsic) data.

Common examples:

* Text editors (character glyphs)
* Game maps (trees, tiles, bullets)
* UI rendering (icons, shapes)
____________________________________________________________________________________________________


This implementation demonstrates the **Flyweight design pattern** in Java, which is used to minimize memory usage by sharing as much data as possible with similar objects.

**Detailed Explanation:**

1. **Flyweight Interface (`Bullet`)**  
   - Defines the common operations for all bullet types.
   - Method: `fire(double x, double y, String direction)` ‚Äî takes extrinsic state (position and direction).

2. **Concrete Flyweight (`ConcreteBullet`)**  
   - Implements the `Bullet` interface.
   - Stores **intrinsic state**: `bulletType`, `speed`, `damage` (shared, does not change per use).
   - The `fire` method uses both intrinsic (type, speed, damage) and extrinsic (position, direction) state.

3. **Flyweight Factory (`BulletFactory`)**  
   - Maintains a cache (`bulletCache`) of bullet types.
   - `getBullet(String bulletType)` returns a shared instance if it exists, or creates and caches a new one.
   - Ensures that only one instance per bullet type is created and reused.

4. **Client Code (`FlyweightGameDemo`)**  
   - Requests bullets from the factory.
   - Fires bullets at different positions and directions.
   - Demonstrates reuse: requesting "Pistol" twice returns the same instance.

**Key Points:**
- **Intrinsic state** (shared): bullet type, speed, damage.
- **Extrinsic state** (unique per use): position (`x`, `y`), direction.
- **Memory efficiency**: Only one object per bullet type is created, reused for all firings.

This pattern is useful when many similar objects are needed, but their shared state can be centralized to reduce memory footprint.


// Step 1: Flyweight Interface
public interface Bullet {
    void fire(double x, double y, String direction);
}


// Step 2: Concrete Flyweight (shared bullet type)
public class ConcreteBullet implements Bullet {
    private final String bulletType;  // intrinsic state
    private final double speed;
    private final int damage;

    public ConcreteBullet(String bulletType, double speed, int damage) {
        this.bulletType = bulletType;
        this.speed = speed;
        this.damage = damage;
    }

    @Override
    public void fire(double x, double y, String direction) {
        System.out.println("Firing " + bulletType + " bullet at (" + x + ", " + y + 
            ") direction: " + direction + ", speed: " + speed + ", damage: " + damage);
    }
}

MyNotes:
use formatted arguments for type safety and clearer output:
System.out.printf(
                "Firing %s bullet at (%.2f, %.2f) direction: %s, speed: %.2f, damage: %d%n",
                bulletType, x, y, direction, speed, damage
        );


// Step 3: Flyweight Factory
import java.util.HashMap;
import java.util.Map;

public class BulletFactory {
    private static final Map<String, Bullet> bulletCache = new HashMap<>();

    public static Bullet getBullet(String bulletType) {
        Bullet bullet = bulletCache.get(bulletType);
        if (bullet == null) {
            switch (bulletType) {
                case "Pistol":
                    bullet = new ConcreteBullet("Pistol", 10.0, 20);
                    break;
                case "Rifle":
                    bullet = new ConcreteBullet("Rifle", 20.0, 40);
                    break;
                case "Sniper":
                    bullet = new ConcreteBullet("Sniper", 30.0, 80);
                    break;
                default:
                    throw new IllegalArgumentException("Unknown bullet type: " + bulletType);
            }
            bulletCache.put(bulletType, bullet);
            System.out.println("Creating new bullet type: " + bulletType);
        }
        return bullet;
    }
}

MyNotes:

1) The `bullet == null` check in `BulletFactory.getBullet` is not to prevent a `NullPointerException`. It is used to determine if a bullet of the requested type already exists in the cache. If it does not exist (`null`), a new bullet is created and cached. This is part of the Flyweight pattern to ensure object reuse.

2) To avoid a `NullPointerException` when using an object, you should check `bullet != null` before accessing its methods or fields. However, in the context of your factory method, `if (bullet == null)` is correct because you want to create a new bullet only if it does not already exist in the cache. Both checks are valid, but their usage depends on the intent:  
- `bullet != null` is used before accessing an object to ensure it's not null.
- `bullet == null` is used to check if an object needs to be created or initialized.


// Step 4: Client Code
public class FlyweightGameDemo {
    public static void main(String[] args) {
        Bullet pistolBullet = BulletFactory.getBullet("Pistol");
        pistolBullet.fire(10, 20, "North");

        Bullet rifleBullet = BulletFactory.getBullet("Rifle");
        rifleBullet.fire(15, 25, "East");

        Bullet pistolBullet2 = BulletFactory.getBullet("Pistol"); // reused
        pistolBullet2.fire(30, 40, "West");

        Bullet sniperBullet = BulletFactory.getBullet("Sniper");
        sniperBullet.fire(50, 60, "South");
    }
}

Output:
Creating new bullet type: Pistol
Firing Pistol bullet at (10.0, 20.0) direction: North, speed: 10.0, damage: 20
Creating new bullet type: Rifle
Firing Rifle bullet at (15.0, 25.0) direction: East, speed: 20.0, damage: 40
Firing Pistol bullet at (30.0, 40.0) direction: West, speed: 10.0, damage: 20
Creating new bullet type: Sniper
Firing Sniper bullet at (50.0, 60.0) direction: South, speed: 30.0, damage: 80

---------------------------------------------------------------------------------------------------

-> Optimize above code

1) Switch statement can be replace with enhanced switch expression in BulletFactory.java
2) Used `Map.computeIfAbsent` for cleaner caching logic.

import java.util.HashMap;
import java.util.Map;

public class BulletFactory {
    private static final Map<String, Bullet> bulletCache = new HashMap<>();

    public static Bullet getBullet(final String bulletType) {
        return bulletCache.computeIfAbsent(bulletType, type -> {
            Bullet bullet = switch (type) {
                case "Pistol" -> new ConcreteBullet("Pistol", 10.0, 20);
                case "Rifle" -> new ConcreteBullet("Rifle", 20.0, 40);
                case "Sniper" -> new ConcreteBullet("Sniper", 30.0, 80);
                default -> throw new IllegalArgumentException("Unknown bullet type: " + type);
            };
            System.out.println("Creating new bullet type: " + type);
            return bullet;
        });
    }

}

MyNotes:
Using the `final` keyword for the `bulletType` parameter in the `getBullet` method ensures that its value cannot be changed within the method body. This improves code safety by preventing accidental reassignment, clarifies intent for other developers, and can help avoid bugs related to parameter modification. It is a best practice for immutability and readability, but not strictly required for functionality.
____________________________________________________________________________________________________


