-> Factory Method: Define an interface for creating objects, but let subclasses decide which class to instantiate.Â  



Weâ€™ll build a Shape factory example.

a) Define a Shape interface.
b) Have Circle and Rectangle as concrete products.
c) Define an abstract ShapeFactory with the factory method.
d) Concrete factories (CircleFactory, RectangleFactory) decide which shape to instantiate.


1. Product interface


public interface Shape {
    void draw();
}


2. Concrete Products


public class Circle implements Shape {
    @Override
    public void draw() {
        System.out.println("Drawing a Circle");
    }
}



public class Rectangle implements Shape {
    @Override
    public void draw() {
        System.out.println("Drawing a Rectangle");
    }
}


3. Creator (Factory) with Factory Method



public abstract class ShapeFactory {
    // Factory Method
    public abstract Shape createShape();
}


4. Concrete Factories


public class CircleFactory extends ShapeFactory {
    @Override
    public Shape createShape() {
        return new Circle();
    }
}



public class RectangleFactory extends ShapeFactory {
    @Override
    public Shape createShape() {
        return new Rectangle();
    }
}


5. Client Demo

public class Main {
    public static void main(String[] args) {
        // Decide at runtime which factory to use
        ShapeFactory circleFactory = new CircleFactory();
        Shape circle = circleFactory.createShape();
        circle.draw(); // Output: Drawing a Circle

        ShapeFactory rectangleFactory = new RectangleFactory();
        Shape rectangle = rectangleFactory.createShape();
        rectangle.draw(); // Output: Drawing a Rectangle
    }
}


Output:
Drawing a Circle
Drawing a Rectangle



ðŸ”¹ Why this is Factory Method

1) The client (Main) never directly instantiates new Circle() or new Rectangle().
2) It asks a factory to createShape().
3) Subclasses (CircleFactory, RectangleFactory) decide which concrete class to return.


âœ… Benefit: You can add a new TriangleFactory later without touching client code â€” it just works with the factory abstraction.

--------------------------------------------------------------------------------------------------

-> In the above program, `ShapeFactory` can be modeled as an interface instead of an abstract class since it only defines a single abstract method (`createShape`) without any implemented methods or state. Using an interface would be more appropriate in this case to emphasize that it is purely a contract for creating shapes.

Hereâ€™s how you can refactor `ShapeFactory` as an interface:

### Updated `ShapeFactory`:
```java

public interface ShapeFactory {
    // Factory Method
    Shape createShape();
}
```

### Changes to `CircleFactory` and `RectangleFactory`:
Since `ShapeFactory` is now an interface, the `extends` keyword should be replaced with `implements` in the concrete factory classes.

#### Updated `CircleFactory`:
```java

public class CircleFactory implements ShapeFactory {
    @Override
    public Shape createShape() {
        return new Circle();
    }
}
```

#### Updated `RectangleFactory`:
```java

public class RectangleFactory implements ShapeFactory {
    @Override
    public Shape createShape() {
        return new Rectangle();
    }
}
```

This change does not affect the functionality of the program, and the `Main` class will work as before.
--------------------------------------------------------------------------------------------------

-> `ShapeFactory` can be modeled as a functional interface since it has a single abstract method. To do this, you can annotate the `ShapeFactory` interface with `@FunctionalInterface`. Additionally, you can use lambda expressions in the `Main` class to simplify the creation of `ShapeFactory` instances.

Here are the required changes:

### Updated `ShapeFactory.java`
```java
package demo;

@FunctionalInterface
public interface ShapeFactory {
    // Factory Method
    Shape createShape();
}
```

### Updated `Main.java`
```java
package demo;

public class Main {
    public static void main(String[] args) {
        // Using lambda expressions for ShapeFactory
        ShapeFactory circleFactory = () -> new Circle();  
		// ShapeFactory circleFactory = Circle::new;	//above lambda can be replaced with method reference
        Shape circle = circleFactory.createShape();
        circle.draw(); // Output: Drawing a Circle

        ShapeFactory rectangleFactory = () -> new Rectangle();
		// ShapeFactory rectangleFactory = Rectangle::new;	//above lambda can be replaced with method reference
        Shape rectangle = rectangleFactory.createShape();
        rectangle.draw(); // Output: Drawing a Rectangle
    }
}
``` 

These changes simplify the code by leveraging the functional interface and lambda expressions.
This eliminates the need for CircleFactory and RectangleFactory classes.

_____________________________________________________________________________________________


-> Enhance the above implementation 

1. **Parameterized Shape Creation**: Allow the `ShapeFactory` to create shapes with specific parameters (e.g., radius for `Circle`, width and height for `Rectangle`).
2. **Shape Properties**: Add properties to the `Shape` interface and implement them in the concrete classes.
3. **Dynamic Factory Selection**: Use a factory registry or a factory provider to dynamically select the appropriate factory at runtime.

Hereâ€™s the enhanced implementation:

### Updated `Shape` Interface
Add properties and a method to calculate the area of the shape.

public interface Shape {
    void draw();
    double calculateArea();
}

### Updated `Circle` Class
Add a `radius` property and implement `calculateArea`.

public class Circle implements Shape {
    private final double radius;

    public Circle(double radius) {
        this.radius = radius;
    }

    @Override
    public void draw() {
        System.out.println("Drawing a Circle with radius: " + radius);
    }

    @Override
    public double calculateArea() {
        return Math.PI * radius * radius;
    }
}

### Updated `Rectangle` Class
Add `width` and `height` properties and implement `calculateArea`.

public class Rectangle implements Shape {
    private final double width;
    private final double height;

    public Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
    }

    @Override
    public void draw() {
        System.out.println("Drawing a Rectangle with width: " + width + " and height: " + height);
    }

    @Override
    public double calculateArea() {
        return width * height;
    }
}

### Updated `ShapeFactory` Abstract Class
Add a method to create shapes with parameters.

public abstract class ShapeFactory {
    public abstract Shape createShape(double... parameters);
}

### Updated `CircleFactory` Class
Create a `Circle` with a specific radius.

public class CircleFactory extends ShapeFactory {
    @Override
    public Shape createShape(double... parameters) {
        if (parameters.length != 1) {
            throw new IllegalArgumentException("Circle requires exactly 1 parameter: radius");
        }
        return new Circle(parameters[0]);
    }
}

### Updated `RectangleFactory` Class
Create a `Rectangle` with specific width and height.

public class RectangleFactory extends ShapeFactory {
    @Override
    public Shape createShape(double... parameters) {
        if (parameters.length != 2) {
            throw new IllegalArgumentException("Rectangle requires exactly 2 parameters: width and height");
        }
        return new Rectangle(parameters[0], parameters[1]);
    }
}

### Factory Provider
Add a factory provider to dynamically select the factory.

import java.util.HashMap;
import java.util.Map;

public class ShapeFactoryProvider {
    private static final Map<String, ShapeFactory> factories = new HashMap<>();

    static {
        factories.put("circle", new CircleFactory());
        factories.put("rectangle", new RectangleFactory());
    }

    public static ShapeFactory getFactory(String shapeType) {
        ShapeFactory factory = factories.get(shapeType.toLowerCase());
        if (factory == null) {
            throw new IllegalArgumentException("No factory found for shape type: " + shapeType);
        }
        return factory;
    }
}

### Updated `Main` Class
Demonstrate dynamic factory selection and parameterized shape creation.

public class Main {
    public static void main(String[] args) {
        // Create a Circle with radius 5
        ShapeFactory circleFactory = ShapeFactoryProvider.getFactory("circle");
        Shape circle = circleFactory.createShape(5);
        circle.draw();
        System.out.println("Area: " +
                circle.calculateArea());

        // Create a Rectangle with width 4 and height 6
        ShapeFactory rectangleFactory = ShapeFactoryProvider.getFactory("rectangle");
        Shape rectangle = rectangleFactory.createShape(4, 6);
        rectangle.draw();
        System.out.println("Area: " + rectangle.calculateArea());
    }
}

Output:
Drawing a Circle with radius: 5.0
Area: 78.53981633974483
Drawing a Rectangle with width: 4.0 and height: 6.0
Area: 24.0

### Summary of Enhancements
1. Added parameters to shape creation.
2. Introduced `calculateArea` in the `Shape` interface.
3. Implemented dynamic factory selection using a `ShapeFactoryProvider`.
_____________________________________________________________________________________________

-> 

// 1. Product Interface
// This is the common interface for the objects that the factory method will create.
public interface Document {
    void open();
    void save();
}



// 2. Concrete Product Classes
// These are the specific objects that the factory method will instantiate.
public class WordDocument implements Document {
    @Override
    public void open() {
        System.out.println("Opening a Word document.");
    }

    @Override
    public void save() {
        System.out.println("Saving a Word document.");
    }
}




public class PdfDocument implements Document {
    @Override
    public void open() {
        System.out.println("Opening a PDF document.");
    }

    @Override
    public void save() {
        System.out.println("Saving a PDF document.");
    }
}




// 3. Creator Abstract Class
// This abstract class declares the factory method. It can also contain other
// methods that use the factory method, but leaves its implementation to subclasses.
public abstract class Application {
    // The Factory Method
    // This method is abstract, so subclasses MUST provide an implementation.
    public abstract Document createDocument();

    // A method that uses the factory method.
    public void newDocument() {
        // We use the factory method to create a document without knowing its concrete class.
        Document doc = createDocument();
        doc.open();
        System.out.println("Editing a new document...");
        doc.save();
    }
}




// 4. Concrete Creator Classes
// Each of these classes overrides the factory method to return a specific concrete product.
public class WordApplication extends Application {
    @Override
    public Document createDocument() {
        return new WordDocument();
    }
}



public class PdfApplication extends Application {
    @Override
    public Document createDocument() {
        return new PdfDocument();
    }
}



public class Main {
    public static void main(String[] args) {
        Application wordApp = new WordApplication();
        wordApp.newDocument();

        Application pdfApp = new PdfApplication();
        pdfApp.newDocument();
    }
}


Output:
Opening a Word document.
Editing a new document...
Saving a Word document.
Opening a PDF document.
Editing a new document...
Saving a PDF document.
_____________________________________________________________________________________________

->  A factory is a Java class that is used to encapsulate object creation code. A factory class instantiates and returns a particular type of object based on data passed to the factory. The different types of objects that are returned from a factory typically are subclasses of a common parent class.


The implementation provided below aligns with the Simple Factory Pattern, not the Factory Method Pattern as defined by the Gang of Four (GoF). 

### Key Differences:
1. **Simple Factory Pattern**:
   - The `AnimalFactory` class is a standalone class responsible for creating objects based on input parameters.
   - The factory logic is centralized in one place, and the client (`Demo` class) depends on this factory to create objects.
   - This is not a GoF design pattern but a common programming idiom.

2. **Factory Method Pattern (GoF)**:
   - In the Factory Method Pattern, the responsibility of object creation is delegated to subclasses of a common abstract factory.
   - Each subclass implements the factory method to create specific types of objects.
   - The client code interacts with the abstract factory and does not know which concrete factory is used.



public abstract class Animal {
	public abstract String makeSound();
}



public class Cat extends Animal {

	@Override
	public String makeSound() {
		return "Meow";
	}

}



public class Dog extends Animal {

	@Override
	public String makeSound() {
		return "Woof";
	}

}



public class AnimalFactory {

	public Animal getAnimal(String type) {
		if ("canine".equals(type)) {
			return new Dog();
		} else {
			return new Cat();
		}
	}

}



public class Demo {

	public static void main(String[] args) {
		AnimalFactory animalFactory = new AnimalFactory();

		Animal a1 = animalFactory.getAnimal("feline");
		System.out.println("a1 sound: " + a1.makeSound());

		Animal a2 = animalFactory.getAnimal("canine");
		System.out.println("a2 sound: " + a2.makeSound());
	}

}

Output:
a1 sound: Meow
a2 sound: Woof
--------------------------------------------------------------------------------------------

### Improvements:
1. Using an `enum` for `Animal` types instead of hardcoding strings like `"canine"` and `"feline"`. This avoids potential errors due to typos.
2. Adding validation for unsupported `Animal` types in the `AnimalFactory`.


And the `AnimalType` enum:

public enum AnimalType {
    CANINE,
    FELINE
}

Hereâ€™s an improved version of the `AnimalFactory`:

public class AnimalFactory {

    public Animal getAnimal(AnimalType type) {
        switch (type) {     // you can use the modern switch expression here instead of classic approach
            case CANINE:
                return new Dog();
            case FELINE:
                return new Cat();
            default:
                throw new IllegalArgumentException("Unsupported animal type: " + type);
        }
    }
}


Finally, update the `Demo` class to use the `AnimalType` enum:


public class Demo {

    public static void main(String[] args) {
        AnimalFactory animalFactory = new AnimalFactory();

        Animal a1 = animalFactory.getAnimal(AnimalType.FELINE);
        System.out.println("a1 sound: " + a1.makeSound());

        Animal a2 = animalFactory.getAnimal(AnimalType.CANINE);
        System.out.println("a2 sound: " + a2.makeSound());
    }
}


This makes the implementation more robust and type-safe.

--------------------------------------------------------------------------------------------

### Refactor to Factory Method Pattern:
To implement the Factory Method Pattern, you would:
1. Define an abstract factory class with a factory method.
2. Create concrete factory classes for each type of `Animal`.
3. The client code interacts with the abstract factory.

Hereâ€™s an example of the Factory Method Pattern:

#### Abstract Factory
```java


public abstract class AnimalFactory {
    public abstract Animal createAnimal();
}
```

#### Concrete Factories
```java


public class DogFactory extends AnimalFactory {
    @Override
    public Animal createAnimal() {
        return new Dog();
    }
}
```

```java


public class CatFactory extends AnimalFactory {
    @Override
    public Animal createAnimal() {
        return new Cat();
    }
}
```

#### Client Code
```java


public class Demo {
    public static void main(String[] args) {
        AnimalFactory dogFactory = new DogFactory();
        Animal dog = dogFactory.createAnimal();
        System.out.println("Dog sound: " + dog.makeSound());

        AnimalFactory catFactory = new CatFactory();
        Animal cat = catFactory.createAnimal();
        System.out.println("Cat sound: " + cat.makeSound());
    }
}
```

This implementation adheres to the GoF Factory Method Pattern, where the creation logic is encapsulated in concrete factory classes.

Output:
Dog sound: Woof
Cat sound: Meow


_____________________________________________________________________________________________


