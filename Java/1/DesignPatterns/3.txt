-> Builder Pattern

The Builder Design Pattern is a creational design pattern used to construct complex objects step by step. It allows you to create different types and representations of an object using the same construction code.
Key Concepts

    Separation of Construction and Representation:
        The Builder pattern separates the logic of building an object from its representation.
    Step-by-Step Construction:
        You can build an object step by step, and the process can vary depending on the requirements.
    Fluent Interface:
        The Builder pattern often uses a fluent interface (method chaining) for better readability.

When to Use the Builder Pattern

    When creating an object with many optional parameters or configurations.
    When the object construction process is complex and needs to be separated for clarity and reusability.
    When you want the same construction process to create different representations of an object.

Example Scenario

Let’s create an example of a "Car" object using the Builder pattern. The car will have several optional and required attributes (e.g., engine, seats, color, GPS).
Implementation
1. Define the Car Class

The Car class is the object we want to build.

public class Car {
    // Required attributes
    private final String engine;
    private final int seats;

    // Optional attributes
    private final String color;
    private final boolean hasGPS;

    // Private constructor
    private Car(CarBuilder builder) {
        this.engine = builder.engine;
        this.seats = builder.seats;
        this.color = builder.color;
        this.hasGPS = builder.hasGPS;
    }

    // Getters
    public String getEngine() {
        return engine;
    }

    public int getSeats() {
        return seats;
    }

    public String getColor() {
        return color;
    }

    public boolean hasGPS() {
        return hasGPS;
    }

    // Builder Class
    public static class CarBuilder {
        // Required attributes
        private final String engine;
        private final int seats;

        // Optional attributes
        private String color;
        private boolean hasGPS;

        // Constructor for required attributes
        public CarBuilder(String engine, int seats) {
            this.engine = engine;
            this.seats = seats;
        }

        // Methods to set optional attributes
        public CarBuilder setColor(String color) {
            this.color = color;
            return this;
        }

        public CarBuilder setGPS(boolean hasGPS) {
            this.hasGPS = hasGPS;
            return this;
        }

        // Build method to create the Car object
        public Car build() {
            return new Car(this);
        }
    }
}


2. Use the Builder to Create a Car

Here’s how to use the CarBuilder to create Car objects with different configurations.


public class Main {
    public static void main(String[] args) {
        // Create a Car with all attributes
        Car sportsCar = new Car.CarBuilder("V8 Engine", 2)
                .setColor("Red")
                .setGPS(true)
                .build();

        // Create a simple Car with required attributes only
        Car basicCar = new Car.CarBuilder("V4 Engine", 4)
                .build();

        // Print car details
        System.out.println("Sports Car: Engine = " + sportsCar.getEngine() + 
                           ", Seats = " + sportsCar.getSeats() + 
                           ", Color = " + sportsCar.getColor() + 
                           ", GPS = " + sportsCar.hasGPS());

        System.out.println("Basic Car: Engine = " + basicCar.getEngine() + 
                           ", Seats = " + basicCar.getSeats() + 
                           ", Color = " + basicCar.getColor() + 
                           ", GPS = " + basicCar.hasGPS());
    }
}


Advantages of Builder Pattern

    Readability:
        The construction process is clear and readable due to method chaining.
    Immutability:
        Once the object is built, it is immutable (if designed as such).
    Flexibility:
        Allows different configurations of the same object.
    Separation of Concerns:
        Construction logic is separated from the representation.

Disadvantages

    More Boilerplate Code:
        The builder class can add extra complexity for simple objects.
    Complexity:
        Overhead of maintaining the builder if the object has too many attributes.

The Builder design pattern is especially useful for creating objects with many optional parameters or for objects requiring detailed construction logic. 
______________________________________________________________________________________________________

-> We use a builder pattern when there are too many optional parameters.


Why Builder Pattern is used

a) In Java, constructors can get messy if a class has many parameters, especially optional ones.

b) You might end up with telescoping constructors:
new User("John", 25, "New York", "Engineer", true, "john@example.com", "1234567890");

This is hard to read and error-prone.

c) The Builder pattern solves this by letting you build objects step by step, specifying only the parameters you care about (optional ones can be skipped).


public class User {
    private final String name;
    private final int age;
    private final String city;
    private final String profession;
    private final boolean active;
    private final String email;

    // Private constructor to enforce the use of the builder
    private User(UserBuilder builder) {
        this.name = builder.name;
        this.age = builder.age;
        this.city = builder.city;
        this.profession = builder.profession;
        this.active = builder.active;
        this.email = builder.email;
    }

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", city='" + city + '\'' +
                ", profession='" + profession + '\'' +
                ", active=" + active +
                ", email='" + email + '\'' +
                '}';
    }

    // Static inner UserBuilder class
    public static class UserBuilder {
        private String name;
        private int age;
        private String city;
        private String profession;
        private boolean active;
        private String email;

        public UserBuilder setName(String name) {
            this.name = name;
            return this;
        }

        public UserBuilder setAge(int age) {
            this.age = age;
            return this;
        }

        public UserBuilder setCity(String city) {
            this.city = city;
            return this;
        }

        public UserBuilder setProfession(String profession) {
            this.profession = profession;
            return this;
        }

        public UserBuilder setActive(boolean active) {
            this.active = active;
            return this;
        }

        public UserBuilder setEmail(String email) {
            this.email = email;
            return this;
        }

        public User build() {
            return new User(this);
        }
    }

}


public class Main {
    public static void main(String[] args) {
        // Using the builder to create a User object
        User user = new User.UserBuilder()
                .setName("John Doe")
                .setAge(30)
                .setEmail("john@example.com")
                .build();

        System.out.println("User created: " + user);

    }
}

Output:
User created: User{name='John Doe', age=30, city='null', profession='null', active=false, email='john@example.com'}
______________________________________________________________________________________________________

-> here’s how to replace the Builder above with telescoping constructors (a cascade of overloaded constructors that supply defaults and chain to the “full” constructor).


// User (telescoping constructors)
public final class User {
    private final String name;       // required
    private final int age;           // optional
    private final String city;       // optional
    private final String profession; // optional
    private final boolean active;    // optional
    private final String email;      // optional

    // 1) Minimal (required only)
    public User(String name) {
        this(name, 0);
    }

    // 2)
    public User(String name, int age) {
        this(name, age, null);
    }

    // 3)
    public User(String name, int age, String city) {
        this(name, age, city, null);
    }

    // 4)
    public User(String name, int age, String city, String profession) {
        this(name, age, city, profession, false);
    }

    // 5)
    public User(String name, int age, String city, String profession, boolean active) {
        this(name, age, city, profession, active, null);
    }

    // 6) Full constructor
    public User(String name, int age, String city, String profession, boolean active, String email) {
        if (name == null || name.isBlank()) throw new IllegalArgumentException("name required");
        this.name = name;
        this.age = age;
        this.city = city;
        this.profession = profession;
        this.active = active;
        this.email = email;
    }

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", city='" + city + '\'' +
                ", profession='" + profession + '\'' +
                ", active=" + active +
                ", email='" + email + '\'' +
                '}';
    }
}


public class Main {
    public static void main(String[] args) {

        User user1 = new User("John"); // only required
        User user2 = new User("Jane", 25, "New York");  // required + 2 optional
        User user3 = new User("John", 25, "New York", "Engineer", true, "john@example.com"); // all


        System.out.println("User created: " + user1);
        System.out.println("User created: " + user2);
        System.out.println("User created: " + user3);

    }
}

Output:
User created: User{name='John', age=0, city='null', profession='null', active=false, email='null'}
User created: User{name='Jane', age=25, city='New York', profession='null', active=false, email='null'}
User created: User{name='John', age=25, city='New York', profession='Engineer', active=true, email='john@example.com'}


Notes

a) This pattern works, but it scales poorly: as optionals grow, you get many constructors and it’s easy to mis-order arguments. Builders stay clearer and safer for many optionals.
b) builder remains the most readable for lots of optional params.
______________________________________________________________________________________________________

-> The telescoping constructor pattern involves creating a series of constructors, each one calling the next with more parameters. It's like a telescope that extends—each constructor "extends" the functionality by adding another parameter.

A sandwich can have different ingredients, but you might not want to force a user to provide all of them every time they create a new sandwich object.

Why Is It an "Anti-Pattern"?
a) While this pattern works, it has a significant drawback: as the number of parameters increases, the constructors become difficult to manage and prone to errors.

b) Readability Issues: It becomes hard to tell what each boolean parameter represents without looking at the constructor definition. For example, new Sandwich("Rye", true, false) is not intuitive. Is the first true for lettuce or tomato? You have to remember the order.

c) Maintenance Headaches: If you need to add a new parameter, such as hasOnion, you have to modify every single constructor in the chain. This is tedious and can easily introduce bugs.

Due to these problems, the telescoping constructor pattern is often replaced by the Builder pattern. The Builder pattern uses a separate, dedicated builder class to construct the object step by step, which makes the process much more readable and maintainable.


public class Sandwich {
    private final String bread;
    private final boolean hasLettuce;
    private final boolean hasTomato;
    private final String meat;
    private final String cheese;

    public Sandwich(String bread) {
        this(bread, false);
    }

    public Sandwich(String bread, boolean hasLettuce) {
        this(bread, hasLettuce, false);
    }

    public Sandwich(String bread, boolean hasLettuce, boolean hasTomato) {
        this(bread, hasLettuce, hasTomato, null);
    }

    public Sandwich(String bread, boolean hasLettuce, boolean hasTomato, String meat) {
        this(bread, hasLettuce, hasTomato, meat, null);
    }

    // The main constructor with all parameters
    public Sandwich(String bread, boolean hasLettuce, boolean hasTomato, String meat, String cheese) {
        this.bread = bread;
        this.hasLettuce = hasLettuce;
        this.hasTomato = hasTomato;
        this.meat = meat;
        this.cheese = cheese;
    }

    public void display() {
        System.out.println("--- Your Sandwich ---");
        System.out.println("Bread: " + bread);
        System.out.println("Lettuce: " + (hasLettuce ? "Yes" : "No"));
        System.out.println("Tomato: " + (hasTomato ? "Yes" : "No"));
        System.out.println("Meat: " + (meat != null ? meat : "None"));
        System.out.println("Cheese: " + (cheese != null ? cheese : "None"));
    }
}



public class Main {

    public static void main(String[] args) {
        Sandwich sandwich1 = new Sandwich("Wheat");
        sandwich1.display();

        Sandwich sandwich2 = new Sandwich("White", true);
        sandwich2.display();

        Sandwich sandwich3 = new Sandwich("Rye", true, true);
        sandwich3.display();

        Sandwich sandwich4 = new Sandwich("Sourdough", true, true, "Turkey");
        sandwich4.display();

        Sandwich sandwich5 = new Sandwich("Multigrain", true, true, "Ham", "Cheddar");
        sandwich5.display();
    }
}

Output:
--- Your Sandwich ---
Bread: Wheat
Lettuce: No
Tomato: No
Meat: None
Cheese: None
--- Your Sandwich ---
Bread: White
Lettuce: Yes
Tomato: No
Meat: None
Cheese: None
--- Your Sandwich ---
Bread: Rye
Lettuce: Yes
Tomato: Yes
Meat: None
Cheese: None
--- Your Sandwich ---
Bread: Sourdough
Lettuce: Yes
Tomato: Yes
Meat: Turkey
Cheese: None
--- Your Sandwich ---
Bread: Multigrain
Lettuce: Yes
Tomato: Yes
Meat: Ham
Cheese: Cheddar

______________________________________________________________________________________________________

-> Here are updated versions of the above Sandwich.java and Main.java files, rewritten to use the Builder pattern.

This new code replaces the telescoping constructor pattern above with the Builder pattern. The Builder class makes it much clearer what each parameter is for and allows you to create sandwiches with any combination of ingredients without having to create an unwieldy number of constructors. It also makes the code more readable and easier to maintain.



public class Sandwich {
    private final String bread;
    private final boolean hasLettuce;
    private final boolean hasTomato;
    private final String meat;
    private final String cheese;

    // Private constructor, accessible only by the Builder
    private Sandwich(Builder builder) {
        this.bread = builder.bread;
        this.hasLettuce = builder.hasLettuce;
        this.hasTomato = builder.hasTomato;
        this.meat = builder.meat;
        this.cheese = builder.cheese;
    }

    public void display() {
        System.out.println("--- Your Sandwich ---");
        System.out.println("Bread: " + bread);
        System.out.println("Lettuce: " + (hasLettuce ? "Yes" : "No"));
        System.out.println("Tomato: " + (hasTomato ? "Yes" : "No"));
        System.out.println("Meat: " + (meat != null ? meat : "None"));
        System.out.println("Cheese: " + (cheese != null ? cheese : "None"));
    }

    // Static nested Builder class
    public static class Builder {
        // Required parameter
        private final String bread;

        // Optional parameters, initialized to default values
        private boolean hasLettuce = false;
        private boolean hasTomato = false;
        private String meat = null;
        private String cheese = null;

        // Builder constructor with required parameters
        public Builder(String bread) {
            this.bread = bread;
        }

        // Methods for setting optional parameters, return the Builder itself for chaining
        public Builder withLettuce() {
            this.hasLettuce = true;
            return this;
        }

        public Builder withTomato() {
            this.hasTomato = true;
            return this;
        }

        public Builder withMeat(String meat) {
            this.meat = meat;
            return this;
        }

        public Builder withCheese(String cheese) {
            this.cheese = cheese;
            return this;
        }

        // The final build method that creates the Sandwich object
        public Sandwich build() {
            return new Sandwich(this);
        }
    }
}


public class Main {

    public static void main(String[] args) {

        // Using the Builder to create a Sandwich instance
        Sandwich mySandwich = new Sandwich.Builder("Whole Wheat")
                .withLettuce()
                .withTomato()
                .withMeat("Turkey")
                .withCheese("Swiss")
                .build();

        // Display the sandwich details
        mySandwich.display();

    }
}

Output:
--- Your Sandwich ---
Bread: Whole Wheat
Lettuce: Yes
Tomato: Yes
Meat: Turkey
Cheese: Swiss

______________________________________________________________________________________________________

->  little refactoring to above code:
a) rename Builder to SandwichBuilder


public class Sandwich {

    private final String bread;
    private final boolean hasLettuce;
    private final boolean hasTomato;
    private final String meat;
    private final String cheese;

    // Private constructor, accessible only by the Builder
    private Sandwich(SandwichBuilder builder) {
        this.bread = builder.bread;
        this.hasLettuce = builder.hasLettuce;
        this.hasTomato = builder.hasTomato;
        this.meat = builder.meat;
        this.cheese = builder.cheese;
    }

    public void display() {
        System.out.println("--- Your Sandwich ---");
        System.out.println("Bread: " + bread);
        System.out.println("Lettuce: " + (hasLettuce ? "Yes" : "No"));
        System.out.println("Tomato: " + (hasTomato ? "Yes" : "No"));
        System.out.println("Meat: " + (meat != null ? meat : "None"));
        System.out.println("Cheese: " + (cheese != null ? cheese : "None"));
    }

    // Static nested SandwichBuilder class
    public static class SandwichBuilder {
        private final String bread; // Required
        private boolean hasLettuce = false; // Optional
        private boolean hasTomato = false; // Optional
        private String meat = null; // Optional
        private String cheese = null; // Optional

        // Constructor with required parameters
        public SandwichBuilder(String bread) {
            this.bread = bread;
        }

        // Methods for optional parameters
        public SandwichBuilder addLettuce() {
            this.hasLettuce = true;
            return this;
        }

        // Method chaining for optional parameters
        public SandwichBuilder addTomato() {
            this.hasTomato = true;
            return this;
        }

        // Method chaining for optional parameters
        public SandwichBuilder addMeat(String meat) {
            this.meat = meat;
            return this;
        }

        // Method chaining for optional parameters
        public SandwichBuilder addCheese(String cheese) {
            this.cheese = cheese;
            return this;
        }

        // Build method to create the Sandwich instance
        public Sandwich build() {
            return new Sandwich(this);
        }
    }
}



public class Main {
    public static void main(String[] args) {
        // Using the Builder to create a Sandwich
        Sandwich mySandwich = new Sandwich.SandwichBuilder("Whole Wheat")
                .addLettuce()
                .addTomato()
                .addMeat("Turkey")
                .addCheese("Swiss")
                .build();

        mySandwich.display();
    }
}

Output:
--- Your Sandwich ---
Bread: Whole Wheat
Lettuce: Yes
Tomato: Yes
Meat: Turkey
Cheese: Swiss

______________________________________________________________________________________________________

