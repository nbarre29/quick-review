
## ðŸ“ What is the Proxy Pattern?

* **Category**: Structural Design Pattern
* **Intent**: Provide a **surrogate or placeholder object** that controls access to another object.
* The proxy can perform:

  * **Access control** (check permissions before calling the real object).
  * **Lazy initialization** (load the real object only when needed).
  * **Logging, caching, or security checks**.

---

## ðŸŽ¯ Real-life Analogy

Think of a **bank account**:

* You donâ€™t directly access the money in the bank vault.
* You use an **ATM card (proxy)** to interact with the bank system.
* The ATM (proxy) controls access, adds authentication, and eventually lets you interact with your real account.

---

## âœ… Java Example: Image Proxy

### 1. Subject Interface


public interface Image {
    void display();
}


### 2. Real Subject (expensive to create)


public class RealImage implements Image {
    private final String filename;

    public RealImage(String filename) {
        this.filename = filename;
        loadFromDisk();
    }

    private void loadFromDisk() {
        System.out.println("Loading image from disk: " + filename);
    }

    @Override
    public void display() {
        System.out.println("Displaying image: " + filename);
    }
}


### 3. Proxy Class

public class ProxyImage implements Image {
    private RealImage realImage;
    private final String filename;

    public ProxyImage(String filename) {
        this.filename = filename;
    }

    @Override
    public void display() {
        if (realImage == null) {
            realImage = new RealImage(filename);  // Lazy loading
        }
        realImage.display();
    }
}


### 4. Client

public class ProxyPatternDemo {
    public static void main(String[] args) {
        Image image1 = new ProxyImage("photo1.jpg");
        Image image2 = new ProxyImage("photo2.jpg");

        // First call -> loads from disk
        image1.display();
        System.out.println("");

        // Second call -> uses cached RealImage
        image1.display();

        // Loads another image
        image2.display();
    }
}

---

## ðŸ–¥ï¸ Output

Loading image from disk: photo1.jpg
Displaying image: photo1.jpg

Displaying image: photo1.jpg
Loading image from disk: photo2.jpg
Displaying image: photo2.jpg

---

## ðŸ“Œ When to Use Proxy

1. **Lazy initialization** (expensive object creation).
2. **Access control** (security proxy, restricting access).
3. **Remote proxy** (e.g., RMI, accessing objects on another machine).
4. **Logging / monitoring proxy**.
5. **Smart references** (counting references, caching).

---

âš¡ Quick Recap:

* **Proxy** = placeholder controlling access to a real object.

---
_____________________________________________________________________________________________________

-> A **real-world banking example** (ATM proxy to account) 

Perfect ðŸ‘ Letâ€™s build a **Bank Account with ATM Proxy** example in Java so you can clearly see how Proxy fits into a real-world scenario.

---

## ðŸ¦ Scenario

* You have a **BankAccount** (real subject) that contains the actual money.
* You canâ€™t directly access it.
* You must go through an **ATM (proxy)** which checks your PIN before giving access.

---

## âœ… Java Example: ATM Proxy

### 1. Subject Interface

public interface Account {
    void withdraw(String pin, double amount);
}

### 2. Real Subject

public class BankAccount implements Account {
    private final String correctPin;
    private double balance;

    public BankAccount(String pin, double initialBalance) {
        this.correctPin = pin;
        this.balance = initialBalance;
    }

    @Override
    public void withdraw(String pin, double amount) {
        if (!pin.equals(correctPin)) {  // this can cause NullPointerException if the pin argumennt is null, because calling equals on null will throw an exception. 
            System.out.println("Access Denied: Invalid PIN");
            return;
        }
        if (amount > balance) {
            System.out.println("Insufficient funds. Balance: $" + balance);
            return;
        }
        balance -= amount;
        System.out.println("Withdrawn: $" + amount + " | Remaining Balance: $" + balance);
    }
}

#### MyNotes:
1) The return; statement immediately exists the current method without executing any further code in that method. In this context, it stops the withdraw method if the PIN is invalid or if there are insufficient funds.
2) To avoid NullPointerException above reverse the comparison:
   if(!correctPin.equals(pin)) {
   This way , if pin is null, equals will safely return false without throwing an exception.

### 3. Proxy (ATM)

public class ATMProxy implements Account {
    private final BankAccount realAccount;

    //  creates a new BankAccount from the given pin and initialBalance.
    public ATMProxy(String pin, double initialBalance) {
        this.realAccount = new BankAccount(pin, initialBalance);
    }

    @Override
    public void withdraw(String pin, double amount) {
        System.out.println("ATM Proxy: Verifying access...");
        realAccount.withdraw(pin, amount);
    }
}

#### MyNotes:
"private final Account realAccount;" would be better to have instead of "private final BankAccount realAccount;" above  if we want ATMProxy to work with any implementation of the Account interface. This allows us to substitute Account implementations without changing ATMProxy

### 4. Client

public class ProxyBankDemo {
    public static void main(String[] args) {
        Account myAccount = new ATMProxy("1234", 500.0);

        // Wrong PIN
        myAccount.withdraw("0000", 100);

        // Correct PIN, valid withdrawal
        myAccount.withdraw("1234", 200);

        // Correct PIN, but insufficient balance
        myAccount.withdraw("1234", 400);
    }
}

---

## ðŸ–¥ï¸ Output

ATM Proxy: Verifying access...
Access Denied: Invalid PIN
ATM Proxy: Verifying access...
Withdrawn: $200.0 | Remaining Balance: $300.0
ATM Proxy: Verifying access...
Insufficient funds. Balance: $300.0

---

## ðŸ“Œ Key Points

* **BankAccount** = Real subject (actual money operations).
* **ATMProxy** = Proxy that controls access and adds authentication.
* **Client** = User interacts only with the proxy, not the real object.

---
-----------------------------------------------------------------------------------------------------
-> Refactor the above:

Introduced a simple exception-based API and basic logging for clearer separation of concerns. Added `AccountException`, `InvalidPinException`, and `InsufficientFundsException`. `Account.withdraw` now declares throwing `AccountException`. `BankAccount` throws exceptions instead of printing; `ATMProxy` verifies PIN then delegates; `ProxyBankDemo` handles exceptions and prints messages.

`src/main/java/demo/AccountException.java`
```java
package demo;

public class AccountException extends Exception {
    public AccountException(String message) {
        super(message);
    }

    public AccountException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

`src/main/java/demo/InvalidPinException.java`
```java
package demo;

public class InvalidPinException extends AccountException {
    public InvalidPinException(String message) {
        super(message);
    }
}
```

`src/main/java/demo/InsufficientFundsException.java`
```java
package demo;

public class InsufficientFundsException extends AccountException {
    public InsufficientFundsException(String message) {
        super(message);
    }
}
```

`src/main/java/demo/Account.java`
```java
package demo;

public interface Account {
    void withdraw(String pin, double amount) throws AccountException;
}
```

`src/main/java/demo/BankAccount.java`
```java
package demo;

import java.util.logging.Logger;

public class BankAccount implements Account {
    private static final Logger LOGGER = Logger.getLogger(BankAccount.class.getName());
    private final String correctPin;
    private double balance;

    public BankAccount(String pin, double initialBalance) {
        this.correctPin = pin;
        this.balance = initialBalance;
    }

    @Override
    public synchronized void withdraw(String pin, double amount) throws AccountException {
        if (!correctPin.equals(pin)) {
            throw new InvalidPinException("Access Denied: Invalid PIN");
        }
        if (amount > balance) {
            throw new InsufficientFundsException("Insufficient funds. Balance: $" + balance);
        }
        balance -= amount;
        LOGGER.info(() -> "Withdrawn: $" + amount + " | Remaining Balance: $" + balance);
    }

    public synchronized double getBalance() {
        return balance;
    }
}
```

`src/main/java/demo/ATMProxy.java`
```java
package demo;

import java.util.logging.Logger;

public class ATMProxy implements Account {
    private static final Logger LOGGER = Logger.getLogger(ATMProxy.class.getName());
    private final Account realAccount;
    private final String proxyPin;

    public ATMProxy(String pin, double initialBalance) {
        this.proxyPin = pin;
        this.realAccount = new BankAccount(pin, initialBalance);
    }

    @Override
    public void withdraw(String pin, double amount) throws AccountException {
        LOGGER.info("ATM Proxy: Verifying access...");
        if (!proxyPin.equals(pin)) {
            throw new InvalidPinException("Access Denied: Invalid PIN");
        }
        realAccount.withdraw(pin, amount);
    }
}
```

`src/main/java/demo/ProxyBankDemo.java`
```java
package demo;

public class ProxyBankDemo {
    public static void main(String[] args) {
        Account myAccount = new ATMProxy("1234", 500.0);

        // Wrong PIN
        try {
            myAccount.withdraw("0000", 100);
        } catch (AccountException e) {
            System.out.println(e.getMessage());
        }

        // Correct PIN, valid withdrawal
        try {
            myAccount.withdraw("1234", 200);
        } catch (AccountException e) {
            System.out.println(e.getMessage());
        }

        // Correct PIN, but insufficient balance
        try {
            myAccount.withdraw("1234", 400);
        } catch (AccountException e) {
            System.out.println(e.getMessage());
        }
    }
}
```

Output:
Oct 04, 2025 1:35:07 AM demo.ATMProxy withdraw
INFO: ATM Proxy: Verifying access...
Oct 04, 2025 1:35:07 AM demo.ATMProxy withdraw
INFO: ATM Proxy: Verifying access...
Oct 04, 2025 1:35:07 AM demo.ATMProxy withdraw
INFO: ATM Proxy: Verifying access...
Access Denied: Invalid PIN
Withdrawn: $200.0 | Remaining Balance: $300.0
Insufficient funds. Balance: $300.0

-----------------------------------------------------------------------------------------------------

-> When switching to SLF4J in above code, you must replace the import and initialization:

- `java.util.logging.Logger` uses `Logger.getLogger(Class.getName())`
- `org.slf4j.Logger` uses `LoggerFactory.getLogger(Class.class)`


**initialization from java.util.logging**
private static final Logger LOGGER = Logger.getLogger(BankAccount.class.getName());

** initialization from slf4j**
private static final Logger LOGGER = LoggerFactory.getLogger(BankAccount.class);


**import from java.util.logging**
import java.util.logging.Logger;

**import from slf4j**
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

-----------------------------------------------------------------------------------------------------

-> To enhance the above application with a 3-attempt limit and reset the counter on a correct PIN, add an `attempts` counter to `ATMProxy`. Reset it on success, and throw an exception after 3 failed attempts.

**Explanation:**  
- Track incorrect attempts in `ATMProxy`.
- Reset attempts on correct PIN.
- Block further withdrawals after 3 failed attempts.


import java.util.logging.Logger;

public class ATMProxy implements Account {
    private static final Logger LOGGER = Logger.getLogger(ATMProxy.class.getName());
    private final Account realAccount;
    private final String proxyPin;
    private int attempts = 0;
    private static final int MAX_ATTEMPTS = 3;

    public ATMProxy(String pin, double initialBalance) {
        this.proxyPin = pin;
        this.realAccount = new BankAccount(pin, initialBalance);
    }

    @Override
    public synchronized void withdraw(String pin, double amount) throws AccountException {
        LOGGER.info("ATM Proxy: Verifying access...");
        if (attempts >= MAX_ATTEMPTS) {
            throw new AccountLockedException("Account locked: Too many incorrect PIN attempts");
        }
        if (!proxyPin.equals(pin)) {
            attempts++;
            throw new InvalidPinException("Access Denied: Invalid PIN (" + attempts + "/" + MAX_ATTEMPTS + ")");
        }
        // Correct PIN, reset attempts
        attempts = 0;
        LOGGER.info("Access Granted: Processing withdrawal...");
        realAccount.withdraw(pin, amount);
    }
}




public class AccountLockedException extends AccountException {
    public AccountLockedException(String message) {
        super(message);
    }
}

No changes needed in other files. This will enforce the 3-attempt rule and reset on success.

_____________________________________________________________________________________________________


