-> 
The template method pattern is a technique that defines the steps required for some action, implementing the boilerplate steps, and leaving the customizable steps as abstract. Subclasses can then implement this abstract class and provide a concrete implementation for the missing steps.

It makes it easier to implement complex algorithms by encapsulating logic in a single method.

ComputerBuilder.java:
the algorithm's structure will be defined in a base class that defines the template buildComputer() method.
The ComputerBuilder class is responsible for outlining the steps required to build a computer by declaring methods for adding and setting up different components, such as a motherboard and a processor.
Here, the buildComputer() method is the template method, which defines steps of the algorithm for assembling the computer parts and returns fully-initialized Computer instances. Notice that it's declared as final to prevent it from being overridden.

StandardComputerBuilder.java, HighEndComputerBuilder.java : 
With the base class already set, these two subclasses, one which builds a “standard” computer, and the other that builds a “high-end” computer.
As we can see, we didn't need to worry about the whole assembly process but only for providing implementations for separate methods.


1. **Base Class (`ComputerBuilder`)**

   * Defines the **template method** `buildComputer()`, which is `final` so subclasses cannot override it.
   * Inside this method, you lay out the *fixed steps* of the algorithm (add motherboard, add processor, etc.).
   * Declares abstract (or hook) methods like `addMotherboard()` and `addProcessor()` that subclasses must implement.

2. **Concrete Subclasses**

   * `StandardComputerBuilder` and `HighEndComputerBuilder` extend `ComputerBuilder`.
   * They only focus on implementing the abstract steps (e.g., which type of motherboard, which processor, etc.).
   * They don’t need to worry about the entire process because the **template method orchestrates the sequence**.

3. **Concrete Products**

   * `StandardComputer` and `HighEndComputer` represent the actual `Computer` objects being assembled.
   * The builders return these concrete objects fully initialized.

4. **Client (`Main.java`)**

   * The client code simply calls `builder.buildComputer()` and gets a ready-to-use `Computer` without knowing the details of the steps.



import java.util.HashMap;
import java.util.Map;

public class Computer {
    
    private Map<String, String> computerParts = new HashMap<>();
    
    public Computer(Map<String, String> computerParts) {
        this.computerParts = computerParts;
    }
    
    public Map<String, String> getComputerParts() {
        return computerParts;
    }
}


import java.util.Map;

public class HighEndComputer extends Computer {
    
    public HighEndComputer(Map<String, String> computerParts) {
        super(computerParts);
    }
}


import java.util.Map;

public class StandardComputer extends Computer {
    
    public StandardComputer(Map<String, String> computerParts) {
        super(computerParts);
    }
}


import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public abstract class ComputerBuilder {

    protected Map<String, String> computerParts = new HashMap<>();
    protected List<String> motherboardSetupStatus = new ArrayList<>();
    
    public final Computer buildComputer() {
        addMotherboard();
        setupMotherboard();
        addProcessor();
        return getComputer();
    }
    
    public abstract void addMotherboard();

    public abstract void setupMotherboard();
    
    public abstract void addProcessor();

    public List<String> getMotherboardSetupStatus() {
        return motherboardSetupStatus;
    }
    
    public Map<String, String> getComputerParts() {
        return computerParts;
    }
    
    private Computer getComputer() {
        return new Computer(computerParts);
    }
}


public class HighEndComputerBuilder extends ComputerBuilder {

    @Override
    public void addMotherboard() {
        computerParts.put("Motherboard", "High-end Motherboard");
    }
    
    @Override
    public void setupMotherboard() {
        motherboardSetupStatus.add("Screwing the high-end motherboard to the case.");
        motherboardSetupStatus.add("Plugging in the power supply connectors.");
        motherboardSetupStatus.forEach(step -> System.out.println(step));
    }
    
    @Override
    public void addProcessor() {
        computerParts.put("Processor", "High-end Processor");
    }
}


public class StandardComputerBuilder extends ComputerBuilder {

    @Override
    public void addMotherboard() {
        computerParts.put("Motherboard", "Standard Motherboard");
    }
    
    @Override
    public void setupMotherboard() {
        motherboardSetupStatus.add("Screwing the standard motherboard to the case.");
        motherboardSetupStatus.add("Plugging in the power supply connectors.");
        motherboardSetupStatus.forEach(step -> System.out.println(step));
    }
    
    @Override
    public void addProcessor() {
        computerParts.put("Processor", "Standard Processor");
    }
}



public class Main {

    public static void main(String[] args) {
        ComputerBuilder standardComputerBuilder = new StandardComputerBuilder();
        Computer standardComputer = standardComputerBuilder.buildComputer();
        standardComputer.getComputerParts().forEach((k, v) -> System.out.println("Part : " + k + " Value : " + v));

        ComputerBuilder highEndComputerBuilder = new HighEndComputerBuilder();
        Computer highEndComputer = highEndComputerBuilder.buildComputer();
        highEndComputer.getComputerParts().forEach((k, v) -> System.out.println("Part : " + k + " Value : " + v));
    }
}

Output:
Screwing the standard motherboard to the case.
Plugging in the power supply connectors.
Part : Processor Value : Standard Processor
Part : Motherboard Value : Standard Motherboard
Screwing the high-end motherboard to the case.
Plugging in the power supply connectors.
Part : Processor Value : High-end Processor
Part : Motherboard Value : High-end Motherboard
------------------------------------------------------------------------------------------------

-> One issue: the current `getComputer()` always returns the base `Computer`, so your concrete builders don't produce `StandardComputer` / `HighEndComputer` instances. To fix that, make creation of the product an abstract step (e.g., `createComputer()`) and have each builder return its specific product.

Modified below:
ComputerBuilder.java
StandardComputerBuilder.java
HighEndComputerBuilder.java



import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public abstract class ComputerBuilder {

    protected Map<String, String> computerParts = new HashMap<>();
    protected List<String> motherboardSetupStatus = new ArrayList<>();
    
    public final Computer buildComputer() {
        addMotherboard();
        setupMotherboard();
        addProcessor();
        return getComputer();
    }
    
    public abstract void addMotherboard();

    public abstract void setupMotherboard();
    
    public abstract void addProcessor();

    public List<String> getMotherboardSetupStatus() {
        return motherboardSetupStatus;
    }
    
    public Map<String, String> getComputerParts() {
        return computerParts;
    }

    protected Computer getComputer() {
        return createComputer();
    }

    // New abstract factory method so concrete builders can return specific product types
    protected abstract Computer createComputer();
}



public class StandardComputerBuilder extends ComputerBuilder {

    @Override
    public void addMotherboard() {
        computerParts.put("Motherboard", "Standard Motherboard");
    }

    @Override
    public void setupMotherboard() {
        motherboardSetupStatus.add("Screwing the standard motherboard to the case.");
        motherboardSetupStatus.add("Plugging in the power supply connectors.");
        motherboardSetupStatus.forEach(step -> System.out.println(step));
    }

    @Override
    public void addProcessor() {
        computerParts.put("Processor", "Standard Processor");
    }

    @Override
    protected Computer createComputer() {
        return new StandardComputer(computerParts);
    }
}



public class HighEndComputerBuilder extends ComputerBuilder {

    @Override
    public void addMotherboard() {
        computerParts.put("Motherboard", "High-end Motherboard");
    }

    @Override
    public void setupMotherboard() {
        motherboardSetupStatus.add("Screwing the high-end motherboard to the case.");
        motherboardSetupStatus.add("Plugging in the power supply connectors.");
        motherboardSetupStatus.forEach(step -> System.out.println(step));
    }

    @Override
    public void addProcessor() {
        computerParts.put("Processor", "High-end Processor");
    }

    @Override
    protected Computer createComputer() {
        return new HighEndComputer(computerParts);
    }
}
------------------------------------------------------------------------------------------------
-> 
## What’s good in above code

* `buildComputer()` is `final` and orchestrates the algorithm.
* Abstract step methods (`addMotherboard`, `setupMotherboard`, `addProcessor`) are present in `ComputerBuilder` and implemented in both concrete builders.
* The product choice is now the variable step via `createComputer()` in each builder. Nice separation of concerns.


## Small polish suggestions (optional)

1. **Make the product immutable (safer):**
   Right now `Computer` stores the incoming `Map` by reference. Consider a defensive copy so callers can’t mutate internals after build.

   ```java
   public class Computer {
       private final Map<String, String> computerParts;
       public Computer(Map<String, String> computerParts) {
           this.computerParts = Map.copyOf(computerParts); // Java 10+
       }
       public Map<String, String> getComputerParts() { return computerParts; }
   }
   ```

2. **Tighten field mutability in the builder:**
   The fields themselves can be `final` (you still mutate their contents, which is fine):

   ```java
   protected final Map<String,String> computerParts = new HashMap<>();
   protected final List<String> motherboardSetupStatus = new ArrayList<>();
   ```

3. **Consider builder reuse semantics:**
   If a single builder instance might be used to build multiple computers, add a `reset()` or clear the maps/lists at the start of `buildComputer()`:

   ```java
   public final Computer buildComputer() {
       computerParts.clear();
       motherboardSetupStatus.clear();
       addMotherboard();
       setupMotherboard();
       addProcessor();
       return createComputer();
   }
   ```

4. **Remove the extra hop if you like:**
   You currently call `return getComputer();` then `getComputer()` calls `createComputer()`. You can inline and drop `getComputer()` unless you want it as a named hook.

   ```java
   public final Computer buildComputer() {
       addMotherboard();
       setupMotherboard();
       addProcessor();
       return createComputer();
   }
   ```


Modified classes:
Computer.java
ComputerBuilder.java
StandardComputerBuilder.java
HighEndComputerBuilder.java




import java.util.HashMap;
import java.util.Map;

/**
 * Immutable product. Internally stores an unmodifiable copy of the parts map.
 */
public class Computer {
    
    private Map<String, String> computerParts = new HashMap<>();
    
    public Computer(Map<String, String> computerParts) {
        // Defensive copy; Map.copyOf returns an unmodifiable map (Java 10+).
        this.computerParts = Map.copyOf(computerParts);
    }

    /**
     * Returns an unmodifiable view of the parts.
     */
    public Map<String, String> getComputerParts() {
        return computerParts;
    }
}


import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Template Method base class.
 * - buildComputer() is the template method (final) that orchestrates the steps.
 * - addMotherboard, setupMotherboard, addProcessor are abstract variable steps.
 * - createComputer(...) is an abstract factory step to choose the concrete product type.
 */
public abstract class ComputerBuilder {

    protected final Map<String, String> computerParts = new HashMap<>();
    protected final List<String> motherboardSetupStatus = new ArrayList<>();

    /**
     * Template method: fixed sequence, final to prevent override.
     * Also, safe for reuse: clears internal state at the start of each build.
     */
    public final Computer buildComputer() {
        computerParts.clear();
        motherboardSetupStatus.clear();
        addMotherboard();
        setupMotherboard();
        addProcessor();

        // Inline factory step so each builder picks the product subtype.
        return createComputer(computerParts);
    }

    // Abstract steps that vary by concrete builder.
    public abstract void addMotherboard();
    public abstract void setupMotherboard();
    public abstract void addProcessor();

    // Abstract factory step for constructing the concrete product subtype.
    protected abstract Computer createComputer(Map<String, String> parts);

    /**
     * Expose read-only build diagnostics to clients if they want them.
     * (The list itself is mutable, but ownership is with the builder. Prefer copying if you expose it externally.)
     */
    public List<String> getMotherboardSetupStatus() {
        return motherboardSetupStatus;
    }

    /**
     * Expose the in-progress parts (primarily for testing/inspection).
     * Consider returning an unmodifiable copy if you want stricter encapsulation here too.
     */
    public Map<String, String> getComputerParts() {
        return computerParts;
    }
}



import java.util.Map;

public class StandardComputerBuilder extends ComputerBuilder {

    @Override
    public void addMotherboard() {
        computerParts.put("Motherboard", "Standard Motherboard");
    }

    @Override
    public void setupMotherboard() {
        motherboardSetupStatus.add("Screwing the standard motherboard to the case.");
        motherboardSetupStatus.add("Plugging in the power supply connectors.");
        motherboardSetupStatus.forEach(step -> System.out.println(step));
    }

    @Override
    public void addProcessor() {
        computerParts.put("Processor", "Standard Processor");
    }

    @Override
    protected Computer createComputer(Map<String, String> parts) {
        return new StandardComputer(parts);
    }
}




import java.util.Map;

public class HighEndComputerBuilder extends ComputerBuilder {

    @Override
    public void addMotherboard() {
        computerParts.put("Motherboard", "High-end Motherboard");
    }

    @Override
    public void setupMotherboard() {
        motherboardSetupStatus.add("Screwing the high-end motherboard to the case.");
        motherboardSetupStatus.add("Plugging in the power supply connectors.");
        motherboardSetupStatus.forEach(step -> System.out.println(step));
    }

    @Override
    public void addProcessor() {
        computerParts.put("Processor", "High-end Processor");
    }

    @Override
    protected Computer createComputer(Map<String, String> parts) {
        return new HighEndComputer(parts);
    }
}


________________________________________________________________________________________________

