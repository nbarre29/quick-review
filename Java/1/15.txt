-> 

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;

public class Mistakes {
    public static void main(String[] args) {
        concurrentModificationException();
    }

    private static void concurrentModificationException() {
        List<String> words = new ArrayList<>(
                Arrays.asList("Hello", "World", "Java", "Programming", "B")
        );

        // This will throw ConcurrentModificationException
        // In Java, modifying a collection while iterating over it using methods like forEach, for-each loop,
        // or an explicit iterator without using the iterator's remove method is not allowed.
        // This is because the internal state of the iterator becomes inconsistent with the collection, causing the ConcurrentModificationException to be thrown.
//        words.forEach(word -> {
//            if (word.equals("B")) {
//                words.remove(word);
//            }
//        });

        // Correct way to remove elements during iteration
        //https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/Iterator.html
        Iterator<String> iterator = words.iterator();
        while (iterator.hasNext()) {
            String word = iterator.next();
            if (word.equals("B")) {
                iterator.remove(); // Correct way to remove elements during iteration
            }
        }

        System.out.println(words);

    }
}
------------------------------------------------------------------------------------
Iterator<String> iterator = words.iterator();
        while (iterator.hasNext()) {
            String word = iterator.next();
            if (word.equals("B")) {
                iterator.remove(); // Correct way to remove elements during iteration
            }
        }
		
// above block can be simplified 
words.removeIf(word -> word.equals("B"));


_____________________________________________________________________________________

-> 

public class Mistakes {
    public static void main(String[] args) {
        System.out.println(equalsTest());
    }

    // Strings compared using equals() method do not use == operator
    // == operator compares the reference of the objects, not the content
    // equals() method compares the content of the objects
    private static boolean equalsTest() {
        var brand = "Naveen";
        var brand2 = "Naveen";
        return brand.equals(brand2);
    }
}

_____________________________________________________________________________________

->  
//bad code
public class Mistakes {
    public static void main(String[] args) {
         System.out.println(ifs());
    }

    private static boolean ifs() {
        var bool = "a".equals("A");

        if(bool == true) {
            return true;
        }
        if(bool == false) {
            return false;
        }
        return false;
    }
}
------------------------------------------------------------------------------------
// better code 
private static boolean ifs() {
        var bool = "a".equals("A");

        if (bool) {
            return true;
        }
        if (!bool) {
            return false;
        }

        return false;

    }
	
------------------------------------------------------------------------------------
//more simplified code
private static boolean ifs() {
        return "a".equals("A");
    }
_____________________________________________________________________________________

-> public class Mistakes {
    public static void main(String[] args) {
        System.out.println(ternary(20));
    }

    private static String ternary(int age) {
        if(age >= 18) {
            return "Adult";
        } else {
            return "Child";
        }
    }
}
------------------------------------------------------------------------------------

private static String ternary(int age) {
        return age >= 18 ? "Adult" : "Child";
    }
	
_____________________________________________________________________________________

-> demonstrate 

1) Enhanced for-each loop
2) Traditional for loop
3) Using iterator for safe removal

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class Main {
    public static void main(String[] args) {

        // 1. Enhanced For-Each Loop (read-only)
        List<String> names = List.of("Alice", "Bob", "Charlie");
        System.out.println("1. Enhanced For-Each Loop:");
        for (String name : names) {
            System.out.println(name);
        }

        // 2. Traditional For Loop (modifying elements)
        //cannot use enhanced for loop because you need to update elements in the list by index. The enhanced for loop does not provide access to the index		
        List<String> modifiableList = new ArrayList<>(List.of("a", "b", "c"));
        System.out.println("\n2. Traditional For Loop (uppercase conversion):");
        for (int i = 0; i < modifiableList.size(); i++) {
            modifiableList.set(i, modifiableList.get(i).toUpperCase());
        }
        System.out.println(modifiableList);  // [A, B, C]

        // 3. Iterator (safe removal)
        List<String> namesWithRemove = new ArrayList<>(List.of("keep", "removeMe", "stay"));
        System.out.println("\n3. Iterator with Safe Removal:");
        Iterator<String> iterator = namesWithRemove.iterator();
        while (iterator.hasNext()) {
            String item = iterator.next();
            if ("removeMe".equals(item)) {
                iterator.remove();  // Safe removal during iteration
            }
        }
        System.out.println(namesWithRemove); // [keep, stay]

    }
}

Output:
1. Enhanced For-Each Loop:
Alice
Bob
Charlie

2. Traditional For Loop (uppercase conversion):
[A, B, C]

3. Iterator with Safe Removal:
[keep, stay]
--------------------------------------

1) The Traditional for loop above can be replaced with 'List.replaceAll' 

		List<String> modifiableList = new ArrayList<>(List.of("a", "b", "c"));
        System.out.println("\n2. Traditional For Loop (uppercase conversion):");
        modifiableList.replaceAll(String::toUpperCase);
        System.out.println(modifiableList);
		
		
2) The while loop can be replaced with 'Collection.removeIf' 


        List<String> namesWithRemove = new ArrayList<>(List.of("keep", "removeMe", "stay"));
        System.out.println("\n3. Iterator with Safe Removal:");       
        namesWithRemove.removeIf("removeMe"::equals);
        System.out.println(namesWithRemove); 
		
--------------------------------------
_____________________________________________________________________________________

-> Demonstrate List.replaceAll

// Capitalize First Letter of Each Word
import java.util.ArrayList;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<String> words = new ArrayList<>(List.of("java", "python", "go"));
        words.replaceAll(s -> s.substring(0, 1).toUpperCase() + s.substring(1));
        System.out.println(words);  // [Java, Python, Go]
    }
}
--------------------------------------
//Trim Whitespace from All Strings

import java.util.ArrayList;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<String> messy = new ArrayList<>(List.of("  apple  ", " banana ", "carrot "));
        messy.replaceAll(String::trim);
        System.out.println(messy);  // [apple, banana, carrot]
    }
}
--------------------------------------
// Round Decimal Numbers
import java.util.ArrayList;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<Double> decimals = new ArrayList<>(List.of(3.14, 2.71, 1.41));
        decimals.replaceAll(d -> (double) Math.round(d));
        System.out.println(decimals);  // [3.0, 3.0, 1.0]
    }
}
_____________________________________________________________________________________

==> Always use == operator to compare enums for correctness, efficiency, and compile-time safety

enum constants are compile-time constants and are implemented as public static final instances of the enum type, guaranteeing singleton behavior

public enum USState {   
    TX,
    CA,
    NY
}


public class EnumComparisonDemo {
    public static void main(String[] args) {
        USState state = USState.TX;
        
        if(state == USState.TX) {
            System.out.println("State is Texas(usiing == operator)");
        }

        // Although this works, it is not the preferred way to compare enums 
        if(state.equals(USState.TX)) {
            System.out.println("State is Texas(using equals method)");
        }

        // This will always evaluate to false because state is of type USState and cannot be equal to a String
        if(state.equals("TX")) {
            System.out.println("This will not print because state is not equal to string \"TX\"");
        }

        // The following line will cause a compile-time error because you cannot compare an enum with a String using the == operator
        // if(state == "TX") {
        //     System.out.println("This will not compile because you cannot compare enum with string using == operator");
        // }

        // Compile-time safety: if you refactor USState, invalid comparisons will be caught at compile time
        // For example, if you rename TX to TEXAS, the following line will cause a compile-time error
        // if(state == USState.TX) {
        //     System.out.println("This will not compile if TX is renamed to TEXAS");
        // }

        // Summary: Always use == operator to compare enums for correctness, efficiency, and compile-time safety
    }
}
_____________________________________________________________________________________
