-> This example demonstrates how to use interfaces in Java to define a contract and implement it in a class. It follows the principle of programming to an interface rather than an implementation.

// Define an interface
public interface GreetingService {
    void greet(String name);
}

// Implement the interface in a class
public class GreetingServiceImpl implements GreetingService {

    @Override
    public void greet(String name) {
        System.out.println("Hello, " + name + "!");
    }
}


public class Main {
    public static void main(String[] args) {
        
        GreetingService greetingService = new GreetingServiceImpl();               
        greetingService.greet("Alice");
    }
}

Output: 
Hello, Alice!
-----------------------------------------------------------------------------------------------------
-> We can rewrite the above example to use a lambda expression because GreetingService is a functional interface (it has a single abstract method).
This approach reduces boilerplate code and leverages Javaâ€™s support for functional programming.

@FunctionalInterface
public interface GreetingService {
    void greet(String name);
}

// Main class to use the interface with a lambda expression
public class Main {
    public static void main(String[] args) {
        // Use a lambda expression to implement the GreetingService interface
        GreetingService greetingService = (name) -> System.out.println("Hello, " + name + "!");

        // Use the lambda to call the method
        greetingService.greet("Alice");
    }
}

#### MyNotes:
a) In Java lambda expressions, parentheses around the parameter are optional when there's **exactly one parameter** and it has an inferred type.

Both forms are valid:

```java

// With parentheses (your current code)
GreetingService greetingService = (name) -> System.out.println("Hello, " + name + "!");

// Without parentheses  (also valid)
// without parentheses is perfectly fine and follows common Java conventions for single-parameter lambdas.
GreetingService greetingService = name -> System.out.println("Hello, " + name + "!");

// With type and parentheses (also valid)
GreetingService greetingService = (String name) -> System.out.println("Hello, " + name + "!");
```

**When parentheses are required:**
- Zero parameters: `() -> expression`
- Multiple parameters: `(a, b) -> expression`
- Explicit type declaration: `(String name) -> expression`


b) @FunctionalInterface  is optional

______________________________________________________________________________________________________

-> Lazy Evaluation in Java Streams

Lazy evaluation is a programming concept where the evaluation of an expression is delayed until its value is actually needed. In the context of Java Streams, this means that intermediate operations (like filter, map, sorted, etc.) are not executed immediately when they are chained together. Instead, they are executed only when a terminal operation (like collect, forEach, reduce, etc.) is applied to the stream. Â  

Key Points:

Intermediate Operations: These operations create a new stream and store the transformation logic. They are not executed immediately. Â  
Terminal Operations: These operations trigger the execution of the entire pipeline, starting from the source to the terminal operation. Â  
Efficiency: Lazy evaluation can significantly improve performance, especially when dealing with large datasets, as only necessary elements are processed. Â  
Short-Circuiting: Some intermediate operations, like limit and findFirst, can short-circuit the pipeline, further optimizing performance.

Benefits of Lazy Evaluation:

Performance Optimization: By processing only the necessary elements, lazy evaluation can significantly improve performance, especially for large datasets. Â  
Memory Efficiency: Fewer intermediate results are stored in memory. Â  
Flexibility: We can chain multiple intermediate operations without worrying about performance overhead. Â  
Understanding


import java.util.Arrays;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

        List<Integer> evenNumbersDoubled = numbers.stream()
                .filter(n -> n % 2 == 0)
                .map(n -> n * 2)
                .toList();

        System.out.println(evenNumbersDoubled);  // Output: [4, 8]
    }
}

#### MyNotes:
@FunctionalInterface
public interface Function<T, R> {
    R apply(T t);
    // default and static methods removed
	}

**Your example above uses the same type:**
```java
.map(n -> n * 2)  // Integer -> Integer
```

**But you could transform to a different type:**
```java
.map(n -> "Number: " + n)  // Integer -> String
```

In this case:
- Input type `T` = `Integer`
- Output type `R` = `String`

The method signature uses different type variables (`T` and `R`) to give you **flexibility**â€”you can keep the same type or change it.
______________________________________________________________________________________________________

==> This program calculates the sum of all even numbers in a list using Java Streams.

import java.util.Arrays;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1,2,3,4,5,6,7,8,9,10);

        int sumOfEvens = numbers.stream()
                                .filter(n -> n % 2 == 0)
                                .mapToInt(Integer::intValue)
                                .sum();
        System.out.println("Sum of even numbers: " + sumOfEvens);   // Sum of even numbers: 30

    }
}

#### MyNotes:
a) For understanding if we have to replace the method reference `Integer::intValue` with a lambda expression:

```java
.mapToInt(n -> n.intValue())
```

Or more concisely, since `n` is already an `Integer`:

```java
.mapToInt(n -> n)
```

The second form works because Java automatically unboxes the `Integer` to `int` when needed.

______________________________________________________________________________________________________

==> Calculate the sum of all even numbers in an array using Java Streams.

import java.util.Arrays;

public class Main {
    public static void main(String[] args) {
        int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

        int sumOfEvens = Arrays.stream(numbers)
                .filter(n -> n % 2 == 0)
                .sum();
        System.out.println("Sum of even numbers: " + sumOfEvens);   // Sum of even numbers: 30

    }
}

______________________________________________________________________________________________________

==> Is it okay to have multiple filters

import java.util.Arrays;

public class Main {
    public static void main(String[] args) {
        int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

        Arrays.stream(numbers)
                .filter(n -> n % 2 == 0)
                .filter(n -> n > 5)
                .forEach(System.out::println);

    }
}

Yes, it's **perfectly fine** to have multiple filters. This is actually a **common and recommended practice** in Java Streams.

**Benefits of multiple filters:**
- **Readability**: Each filter expresses a single, clear condition
- **Maintainability**: Easy to add, remove, or modify individual conditions
- **Debugging**: Easier to identify which condition is filtering what
- **Testability**: Each filter can be understood independently

**Your code is good as-is.** However, you could also combine them into one filter:

```java
Arrays.stream(numbers)
    .filter(n -> n % 2 == 0 && n > 5)
    .forEach(System.out::println);
```

**When to use multiple filters vs. one:**
- **Multiple filters**: When conditions are logically distinct or might change independently
- **Single filter**: When conditions are tightly coupled and always evaluated together

**Performance note**: Multiple filters have negligible performance difference from a single combined filter. The readability benefit usually outweighs any micro-optimization.

Your current approach with two separate filters is clear and maintainable.

#### MyNotes: In above case both conditions are simple checks on the same number, combining them into one filter would be slightly more effecient (avoids creating an intermediate stream) and more concise. However, the performance difference is negligible for small datasets.

______________________________________________________________________________________________________

==> Calculate the sum of the numbers in the list

```
import java.util.List;

public class Main {
    public static void main(String[] args) {

        List<Integer> numbers = List.of(1, 2, 3, 4, 5);        
        int sum = numbers.stream().mapToInt(Integer::intValue).sum();
        System.out.println("Sum: " + sum);  // Sum: 15

    }
}
```
______________________________________________________________________________________________________

==> calculate the sum of squares in the list

```
import java.util.List;

public class Main {
    public static void main(String[] args) {

        List<Integer> numbers = List.of(1, 2, 3, 4, 5);
        int sumOfSquares = numbers.stream()
                .mapToInt(n -> n * n)
                .sum();
        System.out.println("Sum of squares: " + sumOfSquares);  //Sum of squares: 55

    }
}
```
______________________________________________________________________________________________________

==> Using mapToInt to get an int array of string lengths

import java.util.Arrays;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<String> wordsList = Arrays.asList("Java", "Streams", "are", "powerful");

        int[] wordLengths = wordsList.stream()
                .mapToInt(String::length)
                .toArray();
        System.out.println(Arrays.toString(wordLengths)); // [4, 7, 3, 8]
    }
}

------------------------------------------------
==> format the output by collecting the words and their lengths into a formatted string.

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class Main {
    public static void main(String[] args) {
        List<String> wordsList = Arrays.asList("Java", "Streams", "are", "powerful");

        String result = wordsList.stream()
                .map(word -> word + " - " + word.length())
                .collect(Collectors.joining(", "));

        System.out.println(result); // Java - 4, Streams - 7, are - 3, powerful - 8
    }
}

#### MyNotes:
a) String result = wordsList.stream()
                .map((word) -> {
                    return word + " - " + word.length();
                })
                .collect(Collectors.joining(", "));
				
b) String result = wordsList.stream()
                .map((word) -> {
                    return (word + " - " + word.length());
                })
                .collect(Collectors.joining(", "));
______________________________________________________________________________________________________

==> A real scenario is to find the maximum user ID from a list of user IDs represented as strings.
A real scenario is to parse the numeric part of user IDs and find the newest user ID.

Frankly it is just for learning some stream methods.

```
import java.util.stream.Stream;

public class Main {
    public static void main(String[] args) {

        int maxValue = Stream.of("user1", "user2", "user3")
                .map(user -> user.substring(4)) // remove "user" prefix
                .mapToInt(Integer::parseInt)// Convert to primivite integer
                .max() // Find the maximum value
                .orElseThrow();  // handle empty stream

        System.out.println("Max value: " + maxValue); // Max value: 3
    }
}
```

------------------------------------------------------------------------------------------------------

==> demonstrate `orElseThrow()` with both success and failure cases:

This demonstrates:
- **Case 1**: Normal operation when a value exists
- **Case 2**: `orElseThrow()` throwing `NoSuchElementException` on an empty stream
- **Case 3**: Using `orElseThrow(Supplier)` to throw a custom exception

```
import java.util.NoSuchElementException;
import java.util.stream.Stream;

public class Main {
    public static void main(String[] args) {

        // Case 1: Stream with values - orElseThrow() returns the max value
        int maxValue = Stream.of("user1", "user2", "user3")
                .map(user -> user.substring(4))
                .mapToInt(Integer::parseInt)
                .max()
                .orElseThrow();

        System.out.println("Max value: " + maxValue);

        // Case 2: Empty stream - orElseThrow() throws NoSuchElementException
        try {
            int emptyMax = Stream.<String>empty()
                    .map(user -> user.substring(4))
                    .mapToInt(Integer::parseInt)
                    .max()
                    .orElseThrow();

            System.out.println("This won't print: " + emptyMax);
        } catch (NoSuchElementException e) {
            System.out.println("Exception caught: No value present in empty stream");
        }

        // Case 3: Custom exception with orElseThrow(Supplier)
        try {
            int customMax = Stream.<String>empty()
                    .map(user -> user.substring(4))
                    .mapToInt(Integer::parseInt)
                    .max()
                    .orElseThrow(() -> new IllegalStateException("No users found!"));
        } catch (IllegalStateException e) {
            System.out.println("Custom exception: " + e.getMessage());
        }
    }
}
```

```
Output:
Max value: 3
Exception caught: No value present in empty stream
Custom exception: No users found!
```

#### MyNotes:
a) **Why use a custom exception?**

- **More descriptive**: `IllegalStateException("No users found!")` provides domain-specific context about *why* the error occurred
- **Better error handling**: Callers can catch specific exception types for different error scenarios
- **Clearer intent**: The exception type and message communicate the business logic failure, not just "value is missing"

For example, in a real application:
- `NoSuchElementException` is generic - "no value present"
- `IllegalStateException("No users found!")` is specific - "the user list is unexpectedly empty"

This demonstrates the flexibility of `orElseThrow()` - you can use the default exception or provide a more meaningful one for your use case.

b) To declare an **empty `Stream<String>`** in Java, use the built-in `Stream.empty()` method:

```java
Stream<String> emptyStream = Stream.empty();
```
______________________________________________________________________________________________________

==> Given a list of fruit names , capitalize the first letter of each fruit.

import java.util.List;

public class Main {
    public static void main(String[] args) {

        List<String> fruits = List.of("apple", "banana", "cherry");

        // convert the first letter of each fruit to uppercase
        List<String> capitalizedFruits = fruits.stream()
                .map(fruit -> fruit.substring(0, 1).toUpperCase() + fruit.substring(1))
                .toList();

        System.out.println(capitalizedFruits);	// [Apple, Banana, Cherry]

    }
}

#### MyNotes:
a) List.of() creates an immutable list. Is it okay to use it here?

`List.of()` creates an **immutable** list, but you're not modifying the original list elements hereâ€”you're creating a **new** list with transformed values using `.stream().map().toList()`.

The original `fruits` list remains unchanged. The `capitalizedFruits` variable holds a completely separate list with the capitalized strings.

If you were trying to modify elements *in place* (like `fruits.set(0, "Apple")`), then yes, `List.of()` would throw an `UnsupportedOperationException`. But that's not what's happening here.

Your current code works fine with `List.of()`.


b) Here, you are attempting to modify an immutable list, which will cause a runtime error.
`List.of()` creates an **immutable list** that cannot be modified. When you call `replaceAll()`, it will throw an `UnsupportedOperationException`.

import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<String> fruits = List.of("apple", "banana", "cherry");
        fruits.replaceAll(fruit -> fruit.substring(0,1).toUpperCase() + fruit.substring(1));
        System.out.println(fruits);
    }
}

Fix: to make the list mutable use,  List<String> fruits = new ArrayList<>(List.of("apple", "banana", "cherry"));
______________________________________________________________________________________________________


==>
import java.util.Arrays;
import java.util.List;
import java.util.Optional;

public class Main {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);
        Optional<Integer> firstEvenSquare = numbers.stream()
                .filter(n -> n % 2 == 0)
                .map(n -> n * n)
                .findFirst(); // Stops processing as soon as the first match is found

        firstEvenSquare.ifPresent(System.out::println);  // Output: 4

//        firstEvenSquare.ifPresentOrElse(value -> System.out.println("Result: " + value), () -> System.out.println("No result found"));

//        firstEvenSquare.ifPresentOrElse(System.out::println, () -> System.out.println("No result found"));
    }
}


->  firstEvenSquare.ifPresentOrElse(System.out::println, () -> System.out.println("No result found"));

The second argument in the ifPresentOrElse method is a Runnable named emptyAction.
The second argument () -> System.out.println("No result found") is a lambda expression that implements the Runnable interface. The Runnable interface has a single abstract method run(), which takes no arguments and returns no result. The lambda expression () -> System.out.println("No result found") matches this method signature, making it a valid Runnable.

______________________________________________________________________________________________________

-> Text Blocks: Java introduced Text Blocks in Java 13 as a preview feature and made it a standard feature in Java 15. A text block is a multi-line string literal that makes it easier to work with multi-line text, such as JSON, XML, HTML, or SQL, without needing explicit escape characters.
Key Features of Text Blocks

    Uses Triple Double Quotes (""")
    A text block starts and ends with three double-quote (""").
	
    Preserves Line Breaks and Formatting
    No need to manually add \n for new lines.
	
    Automatic Formatting
    Leading spaces can be adjusted automatically.
	
    No Need for Escape Sequences
    Unlike traditional string literals, you donâ€™t need to escape quotes (\") or new lines (\n).


Example 1: Using Text Blocks for JSON

public class TextBlockExample {
    public static void main(String[] args) {
        String json = """
            {
                "name": "John",
                "age": 30,
                "city": "New York"
            }
            """;
        
        System.out.println(json);
    }
}

Output:

{
    "name": "John",
    "age": 30,
    "city": "New York"
}

âœ” No need to escape double quotes (")
âœ” Line breaks and indentation are preserved


Example 2: SQL Query with Text Blocks

public class SQLTextBlockExample {
    public static void main(String[] args) {
        String sqlQuery = """
            SELECT id, name, email
            FROM users
            WHERE status = 'ACTIVE'
            ORDER BY name ASC;
            """;

        System.out.println(sqlQuery);
    }
}

âœ” No need for string concatenation (+)
âœ” Code is more readable


Example 3: HTML with Text Blocks

public class HTMLTextBlockExample {
    public static void main(String[] args) {
        String html = """
            <html>
                <head><title>Java Text Blocks</title></head>
                <body>
                    <h1>Welcome to Java 13+</h1>
                </body>
            </html>
            """;

        System.out.println(html);
    }
}

âœ” Easy to write multi-line HTML content
âœ” No + operator required for concatenation


Conclusion

Text Blocks improve code readability, reduce the need for escape sequences, and make it easier to handle multi-line strings. They are particularly useful for JSON, SQL queries, HTML, and any structured text format.


Key Benefits of Text Blocks

    Requires \n for new lines:
        Traditional Strings: âœ… Yes
        Text Blocks: âŒ No

    Needs escaping for quotes:
        Traditional Strings: âœ… Yes
        Text Blocks: âŒ No

    Supports multi-line strings:
        Traditional Strings: âŒ No
        Text Blocks: âœ… Yes

    Preserves indentation:
        Traditional Strings: âŒ No
        Text Blocks: âœ… Yes

    Readability:
        Traditional Strings: âŒ Low
        Text Blocks: âœ… High		
		
______________________________________________________________________________________________________

==> Demonstrate all three `Integer.valueOf()` methods:

* `valueOf(String, int)` â†’ parse a number in a given radix (base)
* `valueOf(String)` â†’ parse a decimal string
* `valueOf(int)` â†’ box an `int` into an `Integer`

---

# âœ… **Java Program Demonstrating All Three `Integer.valueOf()` Methods**

```java
public class IntegerValueOfDemo {
    public static void main(String[] args) {

        // 1. valueOf(String s, int radix)
        // Converts a number in the given base (radix) to an Integer
        Integer fromBinary = Integer.valueOf("1010", 2);   // binary 1010 = 10
        Integer fromHex = Integer.valueOf("1F", 16);       // hex 1F = 31

        // 2. valueOf(String s)
        // Converts a decimal string into Integer
        Integer fromString = Integer.valueOf("123");       // decimal 123

        // 3. valueOf(int i)
        // Converts an int into an Integer (boxing)
        Integer fromInt = Integer.valueOf(456);

        // Print results
        System.out.println("valueOf(\"1010\", 2) = " + fromBinary);
        System.out.println("valueOf(\"1F\", 16) = " + fromHex);
        System.out.println("valueOf(\"123\") = " + fromString);
        System.out.println("valueOf(456) = " + fromInt);
    }
}
```

---

# ðŸ“Œ **Program Output**

```
valueOf("1010", 2) = 10
valueOf("1F", 16) = 31
valueOf("123") = 123
valueOf(456) = 456
```

---

# ðŸ“ Quick Explanation

| Method                         | What It Does                                   | Example              |
| ------------------------------ | ---------------------------------------------- | -------------------- |
| `Integer.valueOf(String, int)` | Parses the string using the given radix (2â€“36) | `"1010", 2 â†’ 10`     |
| `Integer.valueOf(String)`      | Parses a decimal string                        | `"123" â†’ 123`        |
| `Integer.valueOf(int)`         | Boxes an int to an Integer                     | `456 â†’ Integer(456)` |

-----------------------------------------------------------------------------------------------------

==> In Java (and in math/computer science), **radix** simply means **the base of a number system**.

It tells Java **how to interpret the digits in the string** you pass to `Integer.valueOf()`.

---

# â­ **Radix = Base of the number system**

Different number systems use different bases:

| Number System | Radix (Base) | Digits Used | Example         |
| ------------- | ------------ | ----------- | --------------- |
| **Binary**    | 2            | 0â€“1         | `1010` (base 2) |
| **Octal**     | 8            | 0â€“7         | `17` (base 8)   |
| **Decimal**   | 10           | 0â€“9         | `123` (base 10) |
| **Hex**       | 16           | 0â€“9, Aâ€“F    | `1F` (base 16)  |
| **Base-36**   | 36           | 0â€“9, Aâ€“Z    | `Z` (base 36)   |

Java allows radixes from **2 to 36**.

---

# ðŸ“Œ **How radix works in practice**

### âœ” Example 1: Using radix 2 (binary)

```java
Integer value = Integer.valueOf("1010", 2);
```

Interpret `"1010"` in **base 2**:

```
1Ã—2Â³ + 0Ã—2Â² + 1Ã—2Â¹ + 0Ã—2â°
= 8 + 0 + 2 + 0
= 10 (decimal)
```

---

### âœ” Example 2: Using radix 16 (hex)

```java
Integer value = Integer.valueOf("1F", 16);
```

Interpret `"1F"` in **base 16**:

```
1Ã—16Â¹ + FÃ—16â°
= 1Ã—16 + 15Ã—1
= 31
```

Here `F` means 15 in hex.

---

### âœ” Example 3: Using radix 8 (octal)

```java
Integer value = Integer.valueOf("17", 8);
```

Interpret `"17"` in **base 8**:

```
1Ã—8Â¹ + 7Ã—8â°
= 8 + 7 = 15
```

---

# ðŸŽ¯ **Why we use radix?**

Because numbers written as strings may not be decimal.

It allows converting strings in **any number system** to normal Java integers.

Use cases:

* reading binary from files
* parsing hex color codes
* parsing user input in various bases
* converting base-36 short codes
* working with cryptography or hardware interfaces

---

# â­ **Simple definition**

> **Radix = the base in which the number string is written.
> Java uses it to correctly convert the string into an integer.**

______________________________________________________________________________________________________






