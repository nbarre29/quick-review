-> List all files and directories in a specified folder. Check if the folder exists and is valid, sort the files by their last modified date in ascending order, and print each file's name along with its last modified timestamp. If the folder is empty or an error occurs, display an appropriate message.


import java.io.File;
import java.text.SimpleDateFormat;
import java.util.Arrays;

public class ListFilesInFolder {
    public static void main(String[] args) {
        //Specify the folder path
        String folderPath = "C:\\Cleanup";

        //Create a File object for the folder
        File targetFolder = new File(folderPath);

        // Check if the folder exists and is a directory
        if (targetFolder.exists() && targetFolder.isDirectory()) {
            // list all files and directories in the folder
            File[] listOfFiles = targetFolder.listFiles();

            if (listOfFiles != null) {

                // sort files by last modified in ascending order
                Arrays.sort(listOfFiles, (file1, file2) -> Long.compare(file1.lastModified(), file2.lastModified()));

                System.out.println("Files in the folder");
                SimpleDateFormat sdf = new SimpleDateFormat("MM/dd/yyyy HH:mm:ss");
                for (File file : listOfFiles) {
                    System.out.println(file.getName() + " | Last Modified: " + sdf.format(file.lastModified()));
                }
            } else {
                System.out.println("The folder is empty or an I/O error occurred.");
            }
        } else {
            System.out.println("The specified path is not a valid folder.");
        }
    }
}

Output:
Files in the folder
xanadu.txt | Last Modified: 09/26/2025 20:42:59
outagain.txt | Last Modified: 09/26/2025 22:07:59

---------------------------------------------------------------------------------------------

-> java.io.File is still widely used in Java for basic file and directory operations. However, since Java 7, the java.nio.file package (especially Path and Files) is recommended for more robust and modern file handling.

This refactored code uses java.nio.file.Path, Files, and DirectoryStream for modern file handling. It improves robustness and leverages newer Java APIs.

package demo;

import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

public class ListFilesInFolder {
    public static void main(String[] args) {
        String folderPath = "C:\\Cleanup";
        Path targetFolder = Paths.get(folderPath);

        if (Files.exists(targetFolder) && Files.isDirectory(targetFolder)) {
            try (DirectoryStream<Path> stream = Files.newDirectoryStream(targetFolder)) {
                List<Path> files = new ArrayList<>();
                for (Path entry : stream) {
                    files.add(entry);
                }

                files.sort(Comparator.comparingLong(path -> {
                    try {
                        return Files.getLastModifiedTime(path).toMillis();
                    } catch (Exception e) {
                        return 0L;
                    }
                }));

                System.out.println("Files in the folder");
                SimpleDateFormat sdf = new SimpleDateFormat("MM/dd/yyyy HH:mm:ss");
                for (Path file : files) {
                    BasicFileAttributes attrs = Files.readAttributes(file, BasicFileAttributes.class);
                    System.out.println(file.getFileName() + " | Last Modified: " + sdf.format(attrs.lastModifiedTime().toMillis()));
                }
            } catch (Exception e) {
                System.out.println("The folder is empty or an I/O error occurred.");
            }
        } else {
            System.out.println("The specified path is not a valid folder.");
        }
    }
}
---------------------------------------------------------------------------------------------

-> `SimpleDateFormat` is considered legacy since Java 8. The modern approach is to use the `java.time` package, specifically `DateTimeFormatter` with `Instant` and `LocalDateTime` for date and time formatting. This provides thread safety and better API design.

import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

public class ListFilesInFolder {
    public static void main(String[] args) {
        String folderPath = "C:\\Cleanup";
        Path targetFolder = Paths.get(folderPath);

        if (Files.exists(targetFolder) && Files.isDirectory(targetFolder)) {
            try (DirectoryStream<Path> stream = Files.newDirectoryStream(targetFolder)) {
                List<Path> files = new ArrayList<>();
                for (Path entry : stream) {
                    files.add(entry);
                }

                files.sort(Comparator.comparingLong(path -> {
                    try {
                        return Files.getLastModifiedTime(path).toMillis();
                    } catch (Exception e) {
                        return 0L;
                    }
                }));

                System.out.println("Files in the folder");
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern("MM/dd/yyyy HH:mm:ss");
                ZoneId zone = ZoneId.systemDefault();
                for (Path file : files) {
                    BasicFileAttributes attrs = Files.readAttributes(file, BasicFileAttributes.class);
                    Instant instant = attrs.lastModifiedTime().toInstant();
                    LocalDateTime dateTime = LocalDateTime.ofInstant(instant, zone);
                    System.out.println(file.getFileName() + " | Last Modified: " + formatter.format(dateTime));
                }
            } catch (Exception e) {
                System.out.println("The folder is empty or an I/O error occurred.");
            }
        } else {
            System.out.println("The specified path is not a valid folder.");
        }
    }
}

_____________________________________________________________________________________________
