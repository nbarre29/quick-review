Here is a curated list of core Java interview questions on Threads and Concurrency, along with brief explanations where necessary:
Basic Thread Concepts

    What is a thread in Java?
        A thread is a lightweight process and the smallest unit of execution in Java. It allows concurrent execution of tasks.

    How do you create a thread in Java?
        By extending the Thread class or implementing the Runnable interface.

    What is the difference between start() and run() methods in Java threads?
        start(): Creates a new thread and calls the run() method on that thread.
        run(): Executes the code in the current thread; no new thread is created.

    How do you stop a thread in Java?
        Use a volatile flag or interrupt the thread with Thread.interrupt().
        Deprecated methods like stop() should not be used due to unsafe behavior.

    What is the lifecycle of a thread in Java?
        States: NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, and TERMINATED.

    What is the difference between sleep() and wait()?
        sleep(): Temporarily pauses the current thread for a specified time. Does not release locks.
        wait(): Causes the current thread to wait until notified. It releases the lock on the object.

    What is the difference between yield() and sleep()?
        yield(): Suggests to the thread scheduler to pause the current thread and allow other threads of equal priority to execute.
        sleep(): Pauses the thread for a specified time regardless of other threads.

Thread Synchronization and Locks

    What is thread synchronization in Java?
        Synchronization ensures that only one thread accesses a shared resource at a time, preventing race conditions.

    What is the purpose of the synchronized keyword?
        It ensures mutual exclusion by locking a method or block, allowing only one thread to execute it at a time.

    What is a deadlock? How can it be avoided?
        Deadlock occurs when two or more threads are waiting for each other's resources indefinitely.
        Avoid using nested locks and maintain consistent lock ordering.

        https://docs.oracle.com/javase/tutorial/essential/concurrency/deadlock.html

    What is the difference between synchronized methods and synchronized blocks?
        Methods: Locks the entire object.
        Blocks: Locks only the code inside the block, allowing finer-grained control.

    What is a reentrant lock in Java?
        A lock that allows a thread to acquire it multiple times without causing itself to block (e.g., ReentrantLock).

Concurrency and Advanced Threading

    What is the difference between volatile and synchronized?
        volatile ensures visibility of changes to variables across threads but does not provide atomicity.
        synchronized ensures both visibility and atomicity but involves locking, which can be slower.

    What is the Executor framework in Java?
        A framework that provides a higher-level API for managing threads, such as Executor, ExecutorService, and ScheduledExecutorService.

    What is ForkJoinPool in Java?
        A thread pool designed for divide-and-conquer tasks, such as splitting a large task into smaller ones and joining their results.

    What is Callable and Future in Java?
        Callable: Computes a result, or throws an exception if unable to do so.
        Future: Represents the result of an asynchronous computation.

    What is a thread pool?
        A collection of pre-created threads used to execute multiple tasks, reducing the overhead of thread creation and destruction.

    What are the differences between Thread and ExecutorService?
        Thread creates and manages a single thread.
        ExecutorService manages a pool of threads and provides advanced task management.

Thread Communication

    How do threads communicate in Java?
        Using methods like wait(), notify(), and notifyAll() on shared objects.

    What is a CountDownLatch?
        A synchronization aid that allows one or more threads to wait until a set of operations performed by other threads completes.

    What is a CyclicBarrier?
        A synchronization aid that allows a set of threads to wait at a barrier point until all threads in the group reach that point.

    What is the difference between CountDownLatch and CyclicBarrier?
        CountDownLatch: Cannot be reused once the count reaches zero.
        CyclicBarrier: Can be reused after all threads reach the barrier.

    What is a Semaphore?
        A synchronization tool that restricts the number of threads that can access a resource simultaneously.

Concurrency Problems

    What is a race condition?
        A condition where the outcome of a program depends on the timing or sequence of threads accessing shared resources.

    What is starvation?
        A thread is perpetually denied access to resources because other threads monopolize them.

    What is livelock?
        Threads keep changing their states in response to each other but fail to make progress.

    What is a thread-safe class?
        A class designed to be safely used by multiple threads without external synchronization.

    What is an Atomic class in Java?
        Classes like AtomicInteger, AtomicLong, and AtomicReference provide lock-free, thread-safe operations on single variables.

Memory and Performance

    What is the Java Memory Model (JMM)?
        Defines how threads interact through memory and guarantees visibility of changes to variables across threads.

    What is the difference between Stack and Heap in thread memory?
        Each thread has its own stack for method calls and local variables.
        The heap is shared among all threads for object storage.

    What are some common thread performance tips?
        Minimize the use of synchronized blocks.
        Use thread-safe collections like ConcurrentHashMap.
        Avoid creating too many threads; use thread pools.

Tricky Questions

    Can a thread acquire multiple locks?
        Yes, a thread can acquire multiple locks, but improper locking can lead to deadlocks.

    What happens if a thread calls wait() on an object it doesn‚Äôt own?
        A IllegalMonitorStateException is thrown.

    What is the difference between notify() and notifyAll()?
        notify() wakes up a single thread waiting on the object's monitor.
        notifyAll() wakes up all threads waiting on the object's monitor.

    What is the difference between ConcurrentHashMap and Collections.synchronizedMap()?
        ConcurrentHashMap allows concurrent read operations and uses finer-grained locking.
        Collections.synchronizedMap() locks the entire map for every operation.

Real-World Scenarios

    Explain how you would use a thread pool to handle thousands of tasks efficiently.
    How would you design a producer-consumer system using BlockingQueue?
    How can you handle thread-safe lazy initialization in Java? (Answer: Use synchronized or AtomicReference.)

These questions cover the fundamental and advanced concepts of threads and concurrency, helping you prepare for interviews comprehensively.

---
---
______________________________________________________________________________________________________________


==> Concurrency (Executor Framework)

The Executor Framework simplifies multithreaded programming by managing thread pools.
```
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ExecutorExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(3);

        // Submit tasks to the executor
        for (int i = 1; i <= 10; i++) {
            int taskId = i;
            executor.submit(() -> {
                System.out.println("Task " + taskId + " is running on thread " + Thread.currentThread().getName());
            });
        }

        executor.shutdown();
    }
}
```

#### Output:
```
Task 2 is running on thread pool-1-thread-2
Task 3 is running on thread pool-1-thread-3
Task 1 is running on thread pool-1-thread-1
Task 5 is running on thread pool-1-thread-3
Task 4 is running on thread pool-1-thread-1
```

---
---
--------------------------------------------------------------------------------------------------------------

==> Use try-with-resources for proper resource management. The key changes:

1. **Wrapped ExecutorService in try-with-resources** - This ensures the executor is properly closed even if an exception occurs
2. **Automatic cleanup** - The `close()` method (which internally calls `shutdown()`) is automatically invoked when exiting the try block

This is the recommended approach since Java 19, when ExecutorService became AutoCloseable. The try-with-resources pattern guarantees proper resource cleanup and is safer than manual `shutdown()` calls.

```
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ExecutorExample {
    public static void main(String[] args) {
        // Using try-with-resources to ensure proper shutdown
        try (ExecutorService executor = Executors.newFixedThreadPool(3)) {
            // Submit tasks to the executor
            for (int i = 1; i <= 10; i++) {
                int taskId = i;
                executor.submit(() -> {
                    System.out.println("Task " + taskId + " is running on thread " + Thread.currentThread().getName());
                });
            }
        } // executor.close() is automatically called here
    }
}
```

---
---
______________________________________________________________________________________________________________

==> A real-world example using ExecutorService - let's build an email notification system that processes multiple email sends concurrently.

**Email Notification System** - Shows how an e-commerce platform can send 100 order confirmation emails concurrently instead of sequentially, reducing processing time from ~10 seconds to ~1 second.

uses try-with-resources for proper cleanup and demonstrate real performance benefits you'd see in production applications.

```
public record Order(int orderId, String customerEmail, double amount) {
}


import java.util.concurrent.*;
import java.util.ArrayList;
import java.util.List;

/**
 * Real-world example: Bulk Email Notification System
 * Scenario: An e-commerce platform needs to send order confirmation emails to 100 customers
 * Using ExecutorService to send emails concurrently instead of sequentially
 */
public class EmailNotificationSystem {
    
    public static void main(String[] args) {
        System.out.println("Starting Email Notification System...\n");
        
        // Simulate 100 customer orders
        List<Order> orders = generateOrders(100);
        
        // Process emails sequentially (slow way)
        processEmailsSequentially(orders);
        
        System.out.println("\n" + "=".repeat(60) + "\n");
        
        // Process emails concurrently using ExecutorService (fast way)
        processEmailsConcurrently(orders);
    }
    
    /**
     * Old approach: Sequential processing - SLOW
     */
    private static void processEmailsSequentially(List<Order> orders) {
        System.out.println("üìß Sequential Processing (one at a time):");
        long startTime = System.currentTimeMillis();
        
        for (Order order : orders) {
            sendEmail(order);
        }
        
        long endTime = System.currentTimeMillis();
        System.out.println("‚úÖ Completed in: " + (endTime - startTime) + "ms");
    }
    
    /**
     * Modern approach: Concurrent processing using ExecutorService - FAST
     */
    private static void processEmailsConcurrently(List<Order> orders) {
        System.out.println("üöÄ Concurrent Processing (using ExecutorService):");
        long startTime = System.currentTimeMillis();
        
        // Create thread pool with 10 worker threads
        try (ExecutorService executor = Executors.newFixedThreadPool(10)) {
            
            // Submit all email tasks to the executor
            List<Future<?>> futures = new ArrayList<>();
            
            for (Order order : orders) {
                Future<?> future = executor.submit(() -> sendEmail(order));
                futures.add(future);
            }
            
            // Wait for all emails to complete
            for (Future<?> future : futures) {
                try {
                    future.get(); // Block until this task completes
                } catch (InterruptedException | ExecutionException e) {
                    System.err.println("Error sending email: " + e.getMessage());
                }
            }
            
        } // executor.close() called automatically
        
        long endTime = System.currentTimeMillis();
        System.out.println("‚úÖ Completed in: " + (endTime - startTime) + "ms");
        System.out.println("‚ö° Speedup: ~" + (100 * 100 / (endTime - startTime)) + "x faster!");
    }
    
    /**
     * Simulates sending an email (takes ~100ms per email)
     */
    private static void sendEmail(Order order) {
        try {
            // Simulate email sending delay (API call, SMTP connection, etc.)
            Thread.sleep(100);
            
            // Uncomment to see which thread handles which order
            // System.out.println("Sent email for Order #" + order.orderId() +
            //                   " by " + Thread.currentThread().getName());
            
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            System.err.println("Email sending interrupted for order: " + order.orderId());
        }
    }
    
    /**
     * Generate sample orders
     */
    private static List<Order> generateOrders(int count) {
        List<Order> orders = new ArrayList<>();
        for (int i = 1; i <= count; i++) {
            orders.add(new Order(i, "customer" + i + "@email.com", 99.99 * i));
        }
        return orders;
    }    
    
}
```

#### Output:
```
Starting Email Notification System...

üìß Sequential Processing (one at a time):
‚úÖ Completed in: 10051ms

============================================================

üöÄ Concurrent Processing (using ExecutorService):
‚úÖ Completed in: 1013ms
‚ö° Speedup: ~9x faster!
```

---
---
______________________________________________________________________________________________________________

==> ## Thread vs ExecutorService

### Thread (Low-level)
You manually create and manage each thread.

```java
public class ThreadExample {
    public static void main(String[] args) {
        // Must create and manage each thread manually
        Thread t1 = new Thread(() -> System.out.println("Task 1 - " + Thread.currentThread().getName()));
        Thread t2 = new Thread(() -> System.out.println("Task 2 - " + Thread.currentThread().getName()));

        t1.start();
        t2.start();

        // Must manually wait for completion
        try {
            t1.join();
            t2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // Thread is destroyed after run() completes ‚Äî cannot be reused
    }
}
```

### ExecutorService (High-level)
A thread pool that manages, reuses, and schedules threads for you.

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class ExecutorServiceExample {
    public static void main(String[] args) throws Exception {
        // Pool of 2 reusable threads
        ExecutorService executor = Executors.newFixedThreadPool(2);

        // Submit tasks ‚Äî threads are reused from the pool
        Future<String> future1 = executor.submit(() -> "Result from " + Thread.currentThread().getName());
        executor.execute(() -> System.out.println("Task 2 - " + Thread.currentThread().getName()));

        // Get result from a Callable task
        System.out.println(future1.get());

        // Graceful shutdown ‚Äî no manual join needed
        executor.shutdown();
    }
}
```
#### MyNotes
a) `ExecutorService` is `AutoCloseable` and should be used with a try-with-resources statement to ensure proper cleanup.

**Fix:** Wrap the `ExecutorService` in a try-with-resources block (available since Java 19+ where `ExecutorService` implements `AutoCloseable`):

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class ExecutorServiceExample {
    public static void main(String[] args) throws Exception {
        // Pool of 2 reusable threads ‚Äî auto-closed after try block
        try (ExecutorService executor = Executors.newFixedThreadPool(2)) {

            // Submit tasks ‚Äî threads are reused from the pool
            Future<String> future1 = executor.submit(() -> "Result from " + Thread.currentThread().getName());
            executor.execute(() -> System.out.println("Task 2 - " + Thread.currentThread().getName()));

            // Get result from a Callable task
            System.out.println(future1.get());

        } // executor.shutdown() is called automatically here
    }
}
```

**What changed:**
- Replaced manual `executor.shutdown()` with `try (ExecutorService executor = ...)` 
- The try-with-resources block automatically calls `close()` (which internally calls `shutdown()`) when the block exits, even if an exception occurs
- This ensures the pool is always properly shut down, preventing resource leaks



### Key Differences

| Aspect | Thread | ExecutorService |
|---|---|---|
| **Level** | Low-level | High-level abstraction |
| **Thread creation** | New thread per task | Reuses threads from a pool |
| **Thread reuse** | ‚ùå Not possible | ‚úÖ Built-in |
| **Task queue** | ‚ùå None | ‚úÖ Internal queue for pending tasks |
| **Thread count control** | Manual | Configurable pool size |
| **Scalability** | Poor ‚Äî creating 1000 threads is expensive | Good ‚Äî pool limits concurrent threads |

### Why ExecutorService Is Preferred

```java
// BAD: Creating 1000 threads ‚Äî huge overhead, possible OOM
for (int i = 0; i < 1000; i++) {
    new Thread(() -> doWork()).start();
}

// GOOD: 1000 tasks, but only 10 threads running at a time
ExecutorService pool = Executors.newFixedThreadPool(10);
for (int i = 0; i < 1000; i++) {
    pool.submit(() -> doWork());
}
pool.shutdown();
```

**Rule of thumb:** Use `Thread` only when you need a single, simple background thread. Use `ExecutorService` for everything else ‚Äî it handles thread lifecycle, reuse, and scheduling for you.


---
---
______________________________________________________________________________________________________________

==> demonstrate stopping a Thread using Thread.interrupt()

```
/**
 * Demo: Stopping a Thread in Java using Thread.interrupt()
 *
 * Thread.interrupt() is the recommended way to signal a thread to stop.
 * It works by:
 *   1. Setting the thread's interrupt flag (checked via Thread.isInterrupted())
 *   2. Throwing InterruptedException if the thread is blocked in sleep(), wait(), or join()
 */
public class ThreadInterruptDemo {

    public static void main(String[] args) throws InterruptedException {
        runInterruptFlagExample();
        runInterruptDuringSleepExample();
        runRobustPatternExample();

        System.out.println("\n=== All threads stopped. Demo complete. ===");
    }

    // --- Example 1: Interrupting a thread that checks isInterrupted() ---
    private static void runInterruptFlagExample() throws InterruptedException {
        System.out.println("=== Example 1: Interrupt flag check ===");

        Thread worker1 = new Thread(() -> {
            int count = 0;
            while (!Thread.currentThread().isInterrupted()) {
                count++;
                System.out.println("[Worker-1] Working... iteration " + count);
                // Simulate some CPU-bound work
                double x = 0;
                for (int i = 0; i < 50_000_000; i++) {
                    x += Math.sqrt(i);
                }
            }
            System.out.println("[Worker-1] Detected interrupt flag. Stopping gracefully.");
        }, "Worker-1");

        worker1.start();
        Thread.sleep(2000); // Let it run for 2 seconds
        System.out.println("[Main] Interrupting Worker-1...");
        worker1.interrupt();
        worker1.join();
        System.out.println("[Main] Worker-1 has stopped.\n");
    }

    // --- Example 2: Interrupting a thread that is sleeping ---
    private static void runInterruptDuringSleepExample() throws InterruptedException {
        System.out.println("=== Example 2: Interrupt during sleep (InterruptedException) ===");

        Thread worker2 = new Thread(() -> {
            try {
                int count = 0;
                while (true) {
                    count++;
                    System.out.println("[Worker-2] Working... iteration " + count);
                    Thread.sleep(500); // Blocking call ‚Äî will throw InterruptedException
                }
            } catch (InterruptedException e) {
                System.out.println("[Worker-2] Caught InterruptedException! Stopping gracefully.");
                // Good practice: restore the interrupt flag if needed upstream
                Thread.currentThread().interrupt();
            }
        }, "Worker-2");

        worker2.start();
        Thread.sleep(2000); // Let it run for 2 seconds
        System.out.println("[Main] Interrupting Worker-2...");
        worker2.interrupt();
        worker2.join();
        System.out.println("[Main] Worker-2 has stopped.\n");
    }

    // --- Example 3: Combining both approaches (robust pattern) ---
    private static void runRobustPatternExample() throws InterruptedException {
        System.out.println("=== Example 3: Robust pattern (flag check + InterruptedException) ===");

        Thread worker3 = new Thread(() -> {
            int count = 0;
            try {
                while (!Thread.currentThread().isInterrupted()) {
                    count++;
                    System.out.println("[Worker-3] Working... iteration " + count);
                    Thread.sleep(300); // May throw InterruptedException
                }
            } catch (InterruptedException e) {
                System.out.println("[Worker-3] Interrupted during sleep.");
            }
            System.out.println("[Worker-3] Stopped gracefully after " + count + " iterations.");
        }, "Worker-3");

        worker3.start();
        Thread.sleep(2000);
        System.out.println("[Main] Interrupting Worker-3...");
        worker3.interrupt();
        worker3.join();
        System.out.println("[Main] Worker-3 has stopped.");
    }
}
```

Example 1 ‚Äî Interrupt flag check: The thread does CPU-bound work and checks Thread.currentThread().isInterrupted() in its loop condition. When interrupt() is called, the flag becomes true and the loop exits.
Example 2 ‚Äî Interrupt during sleep: The thread calls Thread.sleep() in each iteration. When interrupt() is called while sleeping, an InterruptedException is thrown, which the thread catches to stop gracefully.
Example 3 ‚Äî Robust pattern (recommended): Combines both approaches ‚Äî checks isInterrupted() in the loop condition and handles InterruptedException from blocking calls. This is the most reliable pattern for real-world code.


---
---
______________________________________________________________________________________________________________

==> demonstrate sleep() and wait()

Here's a Java program demonstrating the difference between `sleep()` and `wait()`:

- **`sleep()`** ‚Äì pauses the current thread for a specified time without releasing the lock.
- **`wait()`** ‚Äì releases the lock and waits until another thread calls `notify()`/`notifyAll()`.

```
public class SleepWaitDemo {

    private static final Object lock = new Object();

    public static void main(String[] args) {
        // Demonstrate sleep()
        Thread sleepThread = new Thread(() -> {
            synchronized (lock) {
                System.out.println("[SleepThread] Acquired lock");
                System.out.println("[SleepThread] Going to sleep for 2 seconds (lock is NOT released)...");
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                System.out.println("[SleepThread] Woke up from sleep, still holds the lock");
            }
        }, "SleepThread");

        Thread sleepWaiter = new Thread(() -> {
            System.out.println("[SleepWaiter] Trying to acquire lock...");
            synchronized (lock) {
                System.out.println("[SleepWaiter] Acquired lock (only after SleepThread released it)");
            }
        }, "SleepWaiter");

        System.out.println("=== Demonstrating sleep() ===");
        sleepThread.start();
        try {
            Thread.sleep(100);
        } catch (InterruptedException ignored) {
        } // ensure sleepThread starts first
        sleepWaiter.start();

        try {
            sleepThread.join();
            sleepWaiter.join();
        } catch (InterruptedException ignored) {
        }

        System.out.println();

        // Demonstrate wait() and notify()
        Object waitLock = new Object();

        Thread waitThread = new Thread(() -> {
            synchronized (waitLock) {
                System.out.println("[WaitThread] Acquired lock");
                System.out.println("[WaitThread] Calling wait() (lock IS released)...");
                try {
                    waitLock.wait();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                System.out.println("[WaitThread] Resumed after notify(), re-acquired the lock");
            }
        }, "WaitThread");

        Thread notifier = new Thread(() -> {
            System.out.println("[Notifier] Trying to acquire lock...");
            synchronized (waitLock) {
                System.out.println("[Notifier] Acquired lock (possible because wait() released it)");
                System.out.println("[Notifier] Calling notify()...");
                waitLock.notify();
            }
        }, "Notifier");

        System.out.println("=== Demonstrating wait() and notify() ===");
        waitThread.start();
        try {
            Thread.sleep(100);
        } catch (InterruptedException ignored) {
        } // ensure waitThread starts first
        notifier.start();

        try {
            waitThread.join();
            notifier.join();
        } catch (InterruptedException ignored) {
        }

        System.out.println();
        System.out.println("=== Summary ===");
        System.out.println("sleep(): Pauses thread, does NOT release the lock.");
        System.out.println("wait() : Pauses thread and RELEASES the lock; resumes on notify()/notifyAll().");
    }
}
```

#### Output
```
=== Demonstrating sleep() ===
[SleepThread] Acquired lock
[SleepThread] Going to sleep for 2 seconds (lock is NOT released)...
[SleepWaiter] Trying to acquire lock...
[SleepThread] Woke up from sleep, still holds the lock
[SleepWaiter] Acquired lock (only after SleepThread released it)

=== Demonstrating wait() and notify() ===
[WaitThread] Acquired lock
[WaitThread] Calling wait() (lock IS released)...
[Notifier] Trying to acquire lock...
[Notifier] Acquired lock (possible because wait() released it)
[Notifier] Calling notify()...
[WaitThread] Resumed after notify(), re-acquired the lock

=== Summary ===
sleep(): Pauses thread, does NOT release the lock.
wait() : Pauses thread and RELEASES the lock; resumes on notify()/notifyAll().
```

**Key differences illustrated:**

| Feature | `sleep()` | `wait()` |
|---|---|---|
| Defined in | `Thread` class | `Object` class |
| Lock release | **No** | **Yes** |
| Wake condition | Timer expires | `notify()` / `notifyAll()` or timeout |
| Requires `synchronized` | No | Yes (must hold the object's monitor) |

Run the program and observe that `SleepWaiter` is blocked during `sleep()`, while `Notifier` can acquire the lock immediately after `wait()` is called.

---
---
______________________________________________________________________________________________________________

==> Callable: Computes a result, or throws an exception if unable to do so.
```
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class CallableDemo {

    public static void main(String[] args) throws Exception {

        // Create a thread pool
        try (ExecutorService executor = Executors.newFixedThreadPool(2)) {

            // ‚úÖ Callable that RETURNS a result
            Callable<Integer> task = () -> {
                System.out.println("Task is running...");
                Thread.sleep(1000);
                return 42; // returns a result
            };

            // ‚úÖ Callable that THROWS an exception
            Callable<Integer> failingTask = () -> {
                System.out.println("Failing task is running...");
                if (true) throw new Exception("Something went wrong!");
                return -1;
            };

            // Submit tasks ‚Äî returns a Future
            Future<Integer> future1 = executor.submit(task);
            Future<Integer> future2 = executor.submit(failingTask);

            // Get result from task 1
            try {
                Integer result = future1.get(); // blocks until result is ready
                System.out.println("Result from task 1: " + result);
            } catch (Exception e) {
                System.out.println("Task 1 failed: " + e.getMessage());
            }

            // Get result from task 2 (will throw exception)
            try {
                Integer result = future2.get();
                System.out.println("Result from task 2: " + result);
            } catch (Exception e) {
                System.out.println("Task 2 failed: " + e.getMessage());
            }

        }
    }
}
```

#### Output:
```
Task is running...
Failing task is running...
Result from task 1: 42
Task 2 failed: java.lang.Exception: Something went wrong!
```


#### MyNotes:
a) is -1 an Integer ?

**Yes**, `-1` is an integer. Integers include all whole numbers ‚Äî positive, negative, and zero.
```
... -3, -2, -1, 0, 1, 2, 3 ...
```

---

## In Java ‚úÖ
**Yes**, `-1` is a valid `int` / `Integer` value in Java.

```java
int a = -1;           // ‚úÖ valid primitive int
Integer b = -1;       // ‚úÖ valid Integer object (autoboxing)
Integer c = -1;       // ‚úÖ perfectly fine

System.out.println(a); // -1
System.out.println(b); // -1
```

---

## Why I Used `-1` in the Callable Demo

In the failing task:
```java
Callable<Integer> failingTask = () -> {
    if (true) throw new Exception("Something went wrong!");
    return -1; // ‚úÖ this line is NEVER reached
};
```

The `return -1` was just a **placeholder** to satisfy the compiler. Since `Callable<Integer>` must return an Integer, the compiler requires a return statement ‚Äî even though in this case the exception is always thrown before reaching it.

```
if (true) throw exception   <-- always happens
return -1;                  <-- compiler requires this, but NEVER executes
```

---

## Integer Range in Java

| Type | Min Value | Max Value |
|---|---|---|
| `int` / `Integer` | `-2,147,483,648` | `2,147,483,647` |

So `-1` is well within the valid range of an Integer in Java. ‚úÖ

---

**Bottom line** ‚Äî `-1` is absolutely a valid Integer, no issues there!

---
---
______________________________________________________________________________________________________________

==> Callable vs Runnable

Both `Callable` and `Runnable` are functional interfaces in Java used to represent tasks, but they differ in a key way:

**Runnable**
- Method: `void run()`
- Returns **nothing**
- Cannot throw checked exceptions
- Used when you just need to execute some code

```java
Runnable r = () -> System.out.println("Running!");
new Thread(r).start();
```

**Callable**
- Method: `V call() throws Exception`
- Returns a **value** (generic type `V`)
- Can throw **checked exceptions**
- Used with `ExecutorService` and `Future` to get a result

```java
Callable<Integer> c = () -> 42;
Future<Integer> future = executor.submit(c);
Integer result = future.get(); // 42
```

**Quick Comparison**

| Feature | Runnable | Callable |
|---|---|---|
| Return value | `void` | Generic `V` |
| Checked exceptions | ‚ùå | ‚úÖ |
| Used with `Future` | ‚ùå | ‚úÖ |
| Package | `java.lang` | `java.util.concurrent` |

**When to use which:**
- Use **Runnable** for fire-and-forget tasks where you don't need a result.
- Use **Callable** when you need the task to return a value or propagate checked exceptions, typically in combination with `ExecutorService`.

---
---
______________________________________________________________________________________________________________

==> What is a deadlock? How can it be avoided?
        Deadlock occurs when two or more threads are waiting for each other's resources indefinitely.
        Avoid using nested locks and maintain consistent lock ordering.


Yes, your answer is correct! It covers the two most important points. You could strengthen it a bit more:

**What is a Deadlock?**

Deadlock occurs when two or more threads are blocked forever, each waiting for a resource held by the other. Four conditions must all be true for a deadlock to occur (the **Coffman Conditions**):

1. **Mutual Exclusion** ‚Äì a resource is held by only one thread at a time
2. **Hold and Wait** ‚Äì a thread holds one resource while waiting for another
3. **No Preemption** ‚Äì resources can't be forcibly taken away
4. **Circular Wait** ‚Äì Thread A waits for Thread B, which waits for Thread A

**How to Avoid It** ‚Äî your two points are spot on, plus a few more:

- **Consistent lock ordering** ‚úÖ ‚Äî always acquire locks in the same order across all threads
- **Avoid nested locks** ‚úÖ ‚Äî don't acquire a lock while already holding one if possible
- **Use `tryLock()` with timeout** ‚Äî instead of blocking indefinitely, try to acquire a lock and give up after a timeout (`ReentrantLock.tryLock(timeout, unit)`)
- **Use higher-level concurrency utilities** ‚Äî `java.util.concurrent` classes like `Semaphore`, `CountDownLatch`, or `ConcurrentHashMap` reduce the need for manual locking
- **Deadlock detection** ‚Äî some systems periodically check for circular wait conditions and break them

For an interview, your original answer is solid. Mentioning the Coffman Conditions and `tryLock()` would make it stand out.


---
---
______________________________________________________________________________________________________________

==> Deadlock describes a situation where two or more threads are blocked forever, waiting for each other.

Alphonse and Gaston are friends, and great believers in courtesy. A strict rule of courtesy is that when you bow to a friend, you must remain bowed until your friend has a chance to return the bow. Unfortunately, this rule does not account for the possibility that two friends might bow to each other at the same time. This example application, Deadlock, models this possibility:

When Deadlock runs, it's extremely likely that both threads will block when they attempt to invoke bowBack. Neither block will ever end, because each thread is waiting for the other to exit bow.

https://docs.oracle.com/javase/tutorial/essential/concurrency/deadlock.html


```
public record Friend(String name) {
    public synchronized void bow(Friend bower) {
        System.out.format("%s: %s  has bowed to me!%n", this.name, bower.name());
        bower.bowBack(this);
    }

    public synchronized void bowBack(Friend bower) {
        System.out.format("%s: %s has bowed back to me!%n", this.name, bower.name());
    }
}


public class Deadlock {

    public static void main(String[] args) {
        Friend alphonse = new Friend("Alphonse");
        Friend gaston = new Friend("Gaston");
        new Thread(() -> alphonse.bow(gaston)).start();
        new Thread(() -> gaston.bow(alphonse)).start();
    }
}
```

---
---
______________________________________________________________________________________________________________

