->
package org.example;

public class Test {
    public static void main(String[] args) {
        try {
            int a = 10;
            int b = 0;
            int result = a / b;
            System.out.println("Result: " + result);
        } catch (ArithmeticException e) {
//            System.out.println("Exception caught: " + e.getMessage());
//            e.printStackTrace();
//            throw new ArithmeticException("Division by zero is not allowed");
            throw new RuntimeException(e);
        }

    }
}
--------------------------------------------

-> best practices for exception handling in Java?

1. Use Specific Exceptions Instead of Catching Exception or Throwable

    Catching general exceptions (Exception or Throwable) can mask real issues and make debugging harder.
    Instead, catch specific exceptions like IOException, SQLException, or NullPointerException.

try {
    FileReader file = new FileReader("file.txt");
} catch (FileNotFoundException e) {
    System.err.println("File not found: " + e.getMessage());
}
--------------------------------------------

2. Avoid Swallowing Exceptions

    Always handle exceptions properly or rethrow them instead of silently ignoring them.

Bad practice:

try {
    someMethod();
} catch (IOException e) {
    // Do nothing (bad practice)
}


Better approach:

try {
    someMethod();
} catch (IOException e) {
    throw new RuntimeException("Error processing file", e);
}
--------------------------------------------


3. Use Custom Exceptions Where Appropriate

    If standard exceptions do not fit your scenario, define custom exceptions.

public class InvalidInputException extends Exception {
    public InvalidInputException(String message) {
        super(message);
    }
}

    Use custom exceptions to make error handling more meaningful.

if (userInput == null) {
    throw new InvalidInputException("User input cannot be null");
}

--------------------------------------------
4. Use finally to Release Resources

    Ensure resources like database connections, file streams, and sockets are closed properly.
    Use try-with-resources for auto-closing resources.

try (BufferedReader br = new BufferedReader(new FileReader("file.txt"))) {
    System.out.println(br.readLine());
} catch (IOException e) {
    System.err.println("Error reading file: " + e.getMessage());
}
--------------------------------------------

5. Log Exceptions Properly

    Use a logging framework like SLF4J with Logback or Log4j instead of System.out.println.


private static final Logger logger = LoggerFactory.getLogger(MyClass.class);

try {
    someMethod();
} catch (IOException e) {
    logger.error("Error processing file", e);
}
--------------------------------------------

6. Avoid Catching Exceptions Just to Log and Rethrow

    Rethrow exceptions instead of catching them only for logging.

Bad practice:

try {
    someMethod();
} catch (IOException e) {
    logger.error("Error occurred", e);
    throw e;
}

Better approach:

try {
    someMethod();
} catch (IOException e) {
    throw new CustomException("Error in processing", e);
}
--------------------------------------------

7. Prefer Checked Exceptions for Recoverable Errors and Runtime Exceptions for Programming Errors

    Use checked exceptions (Exception) for recoverable issues like network failures.
    Use unchecked exceptions (RuntimeException) for programming errors like NullPointerException.

public void readFile(String fileName) throws IOException {
    if (fileName == null) {
        throw new IllegalArgumentException("Filename cannot be null");
    }
    // Read file logic
}
--------------------------------------------

8. Avoid Using Exceptions for Control Flow

    Do not use exceptions for normal logic, such as checking for an element in a collection.

Bad practice:

try {
    int value = list.get(index);
} catch (IndexOutOfBoundsException e) {
    // Handle missing element
}

Better approach:

if (index < list.size()) {
    int value = list.get(index);
}
--------------------------------------------

9. Document Exceptions Using Javadoc

    Clearly document expected exceptions in method signatures.

/**
 * Reads a file and returns its content.
 * @param fileName the name of the file
 * @return file content
 * @throws IOException if an error occurs during file reading
 */
public String readFile(String fileName) throws IOException {
    // Read file logic
}

--------------------------------------------

10. Centralize Exception Handling (For Web Apps & APIs)

    Use a global exception handler in Spring Boot applications.

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(InvalidInputException.class)
    public ResponseEntity<String> handleInvalidInput(InvalidInputException e) {
        return ResponseEntity.badRequest().body(e.getMessage());
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleGeneralException(Exception e) {
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("An unexpected error occurred");
    }
}
--------------------------------------------

11. Use Optional to Avoid NullPointerException

    Instead of returning null, return an Optional to indicate the possibility of missing values.

public Optional<User> findUserById(String userId) {
    return userRepository.findById(userId);
}

    Usage:

Optional<User> user = findUserById("123");
user.ifPresent(System.out::println);

_________________________________________________________________________________

-> Option 1: Simple Rethrow Without Logging

try {
    someMethod();
} catch (IOException e) {
    throw new CustomException("Error in processing", e);
}

Pros:

    Keeps the exception handling clean and minimal.
    Avoids duplicate logging if the caller already logs the exception.
    Preserves the original exception (IOException) by wrapping it in CustomException.

Cons:

    No log entry at this point, making it harder to debug if no other layer logs the error.



Option 2: Logging Before Rethrowing

try {
    someMethod();
} catch (IOException e) {
    logger.error("Error in processing method someMethod, reason: {}", e.getMessage());
    throw new CustomException("Error in processing", e);
}

Pros:

    Provides immediate logging, which helps in debugging when tracing failures.
    Adds context to the logs (method name, reason).
    Still preserves the original exception by passing it to CustomException.

Cons:

    Possible duplicate logging: If the caller (or global exception handler) logs it again, this could lead to redundant logs.
    Unnecessary logging in cases where the higher layers handle and log the error.
	
	
Which One is Preferred, Option 1 OR Option 2 discussed above ?

It depends on the logging strategy of your application:

    Use Option 1 if:
        The caller (or a global exception handler) is responsible for logging errors.
        You want to avoid log duplication and keep the stack trace clean.

    Use Option 2 if:
        You need immediate logging for debugging purposes.
        The exception might be swallowed at higher levels (e.g., silent failure in an API).
        You are in a low-level module where logging errors before throwing them is useful.
		
		
Recommended Approach:

If global exception handling is in place (e.g., Spring Boot's @ControllerAdvice for REST APIs), Option 1 is preferred to avoid duplicate logs.

However, if this is a critical method where failures need to be logged for debugging, Option 2 is better.


Best of Both Worlds: Use Conditional Logging

If you want to log only when necessary, use a debug flag:

try {
    someMethod();
} catch (IOException e) {
    if (logger.isDebugEnabled()) {
        logger.debug("Error in processing method someMethod, reason: {}", e.getMessage(), e);
    }
    throw new CustomException("Error in processing", e);
}

    logger.isDebugEnabled() ensures that logging is done only when debugging is needed.
    Logging at DEBUG level prevents unnecessary logs in production while retaining useful logs for development.
	
	
Final Verdict

ðŸ”¹ Option 1 (No Logging) is preferred if global logging is already handled.
ðŸ”¹ Option 2 (Logging) is useful for debugging but should be used carefully to avoid log duplication.

_________________________________________________________________________________

-> Avoid Catching Exceptions Just to Log and Rethrow

    Rethrow exceptions instead of catching them only for logging.

Bad practice:

try {
    someMethod();
} catch (IOException e) {
    logger.error("Error occurred", e); // Logs the exception
    throw e; // Rethrows the same exception
}


Why is this bad?

    The IOException is logged here and then immediately rethrown.
    If the calling method also logs the exception, the same error appears multiple times in the logs.
    This duplicates information without adding any value.


Better approach:

try {
    someMethod();
} catch (IOException e) {
    throw new CustomException("Error in processing", e);
}


Why is this better?

    Instead of logging and rethrowing the original exception, we wrap it inside a CustomException with a meaningful message.
    This improves readability and makes debugging easier because the custom exception provides context.
    Logging should be done at the appropriate layerâ€”typically at the topmost level where the exception is handled.
	
_________________________________________________________________________________

-> https://docs.oracle.com/javase/tutorial/essential/exceptions/runtime.html

Because the Java programming language does not require methods to catch or to specify unchecked exceptions (RuntimeException, Error, and their subclasses), programmers may be tempted to write code that throws only unchecked exceptions or to make all their exception subclasses inherit from RuntimeException. Both of these shortcuts allow programmers to write code without bothering with compiler errors and without bothering to specify or to catch any exceptions. Although this may seem convenient to the programmer, it sidesteps the intent of the catch or specify requirement and can cause problems for others using your classes.


// âŒ Bad practice: Making your custom exception extend RuntimeException
public class DataProcessingException extends RuntimeException {
    public DataProcessingException(String message) {
        super(message);
    }
}


public class DataProcessor {

    // Method that throws unchecked exception
    public void processData(String data)  {
        if (data == null || data.isEmpty() ) {
            throw new DataProcessingException("Data cannot be null or empty");
        }
        // Processing logic here
        System.out.println("Processing data: " + data);
    }
}


public class Main {
    public static void main(String[] args) {
        DataProcessor processor = new DataProcessor();

        processor.processData("Hello");

        processor.processData(null); // This will throw an unchecked exception

        System.out.println("Done"); // This line will not be reached if an exception is thrown

    }
}

Why This Is Controversial ?
1) No compile-time warning:
Because DataProcessingException extends RuntimeException, the compiler does not require:
a throws clause in processData()
the caller to use try-catch

2) Runtime surprises:
A developer using processData(null) won't know about the possibility of failure until runtime, possibly far from the original bug.

3) Harder for API users:
Other developers using your class donâ€™t see from the method signature that they must handle certain error conditions.

----------------------------------------------------------------------------
-> Above example updated: Use Checked Exceptions for Recoverable Conditions

public class DataProcessingException extends Exception {
    public DataProcessingException(String message) {
        super(message);
    }
}

public class DataProcessor {

    public void processData(String data) throws DataProcessingException{
        if (data == null) {
            throw new DataProcessingException("Data cannot be null");
        }

        if (data.isBlank()) {
            throw new DataProcessingException("Data cannot be empty");
        }
        
        // Processing logic here
        System.out.println("Processing data: " + data);
    }
}

public class Main {
    public static void main(String[] args) {
        DataProcessor processor = new DataProcessor();

        try {
            processor.processData("Hello");
            processor.processData(null);  // compiler forces us to handle this exception
        } catch (DataProcessingException e) {
            throw new RuntimeException(e);
        }

    }
}


Key Takeaways
1) Making everything a RuntimeException avoids compiler enforcement, but increases the risk of hidden bugs surfacing only at runtime.
2) Checked exceptions force API users to explicitly handle error conditions â€” improving clarity, at the cost of more verbose code.


_________________________________________________________________________________

-> https://docs.oracle.com/javase/tutorial/essential/exceptions/runtime.html
One case where it is common practice to throw a RuntimeException is when the user calls a method incorrectly. For example, a method can check if one of its arguments is incorrectly null. If an argument is null, the method might throw a NullPointerException, which is an unchecked exception.


public class Rectangle {

    private final int width;
    private final int height;

    public Rectangle(int width, int height) {
        if(width <= 0 || height <= 0) {
            throw new IllegalArgumentException("Width and height cannot be zero or negative.");
        }
        this.width = width;
        this.height = height;
    }

    public int getArea() {
        return width * height;
    }
}



public class Main {
    public static void main(String[] args) {
        // âœ… Correct usage
        try {
            Rectangle rect1 = new Rectangle(5, 10);
            System.out.println("Area of rect1: " + rect1.getArea());
        } catch (IllegalArgumentException e) {
            System.err.println("Error creating rect1: " + e.getMessage());
        }

        // âŒ Incorrect usage: negative value
        try {
            Rectangle rect2 = new Rectangle(-3, 8);
            System.out.println("Area of rect2: " + rect2.getArea());
        } catch (IllegalArgumentException e) {
            System.err.println("Error creating rect2: " + e.getMessage());
        }

    }
}

Output:
Area of rect1: 50
Error creating rect2: Width and height cannot be zero or negative.


This demonstrates:
1) Fail fast behavior for invalid arguments (IllegalArgumentException is a RuntimeException).
2) How to catch and handle errors during object creation.


This example is exactly the kind of scenario where using a RuntimeException (like IllegalArgumentException) is appropriate instead of a checked exception.

ðŸ” Why a RuntimeException Fits Here
The error (width <= 0 || height <= 0) indicates a programming mistake â€” the caller violated the methodâ€™s precondition.

This is not a recoverable error at runtime. The correct fix is to change the code that called new Rectangle(...) with invalid values.

For such contract violations, Java best practices recommend throwing unchecked exceptions (RuntimeException or its subclasses) rather than checked exceptions


âš–ï¸ Advantages of RuntimeException in This Case
1. No Forced Try-Catch
Checked exceptions require the caller to either handle or declare them:

public Rectangle(...) throws IllegalArgumentException // unnecessary here

For programming errors, this just adds noise to code â€” you donâ€™t want every caller to clutter their code with meaningless try-catch.

2. Fail Fast
The exception is thrown immediately when the contract is violated.

This makes bugs surface early during development/testing instead of being swallowed or delayed.

3. Cleaner API
API remains cleaner without unnecessary throws declarations.

Callers can still catch it if they choose, but theyâ€™re not forced to.

4. Signals Caller Error, Not Recoverable Condition
Checked exceptions are for recoverable conditions (e.g., file not found, network unavailable) where the caller can take corrective action.

Invalid rectangle dimensions are not recoverable at runtime â€” they require code changes.


ðŸ“Œ Rule of Thumb
Use Checked Exceptions â†’ for situations where the caller can reasonably recover.
Use Unchecked Exceptions â†’ for programming errors, contract violations, and API misuse.

--------------------------------------------------------------------------------
-> updated version where width and height are Integer objects so we can check for null as well as negative values.


//Updated Rectangle with null check
public class Rectangle {

    private final Integer width;
    private final Integer height;

    public Rectangle(Integer width, Integer height)  {
        if(width == null|| height == null) {
            throw new NullPointerException("Width and height cannot be null.");
        }

        if(width <= 0 || height <= 0) {
            throw new IllegalArgumentException("Width and height cannot be zero or negative.");
        }
        this.width = width;
        this.height = height;
    }

    public int getArea() {
        return width * height;
    }
}


public class Main {
    public static void main(String[] args) {
        // âœ… Correct usage
        try {
            Rectangle rect1 = new Rectangle(5, 10);
            System.out.println("Area of rect1: " + rect1.getArea());
        } catch (IllegalArgumentException e) {
            System.err.println("Error creating rect1: " + e.getMessage());
        }
		
		// âŒ Incorrect usage: negative value
        try {
            Rectangle rect2 = new Rectangle(-3, 8);
            System.out.println("Area of rect2: " + rect2.getArea());
        } catch (IllegalArgumentException e) {
            System.err.println("Error creating rect2: " + e.getMessage());
        }

        // âŒ Incorrect usage: null value
        try {
            Rectangle rect3 = new Rectangle(null, 4);
            System.out.println("Area of rect3: " + rect3.getArea());
        } catch (RuntimeException e) {
            System.err.println("Error creating rect3: " + e.getMessage());
        }

    }
}

Output:
Area of rect1: 50
Error creating rect2: Width and height cannot be zero or negative.
Error creating rect3: Width and height cannot be null.


ðŸ” What Changed
a) Changed parameter types to Integer instead of int so they can be null.

b) Added an explicit null check:

if (width == null || height == null) {
    throw new NullPointerException("Width and height cannot be null.");
}

c) Still validate against negative values.
_________________________________________________________________________________

-> An example use case preferring RuntimeException

public class BankAccount {
    private boolean closed = false;
    private double balance;

    public BankAccount(double initialBalance) {
        this.balance = initialBalance;
    }

    public void closeAccount() {
        this.closed = true;
    }

    public void withdraw(double amount) {
        if (closed) {
            throw new IllegalStateException("Account is closed.");
        }
        if (amount > balance) {
            throw new IllegalArgumentException("Insufficient funds.");
        }
        balance -= amount;
    }

    public boolean isClosed() {
        return closed;
    }

    public double getBalance() {
        return balance;
    }
}


public class Main {
    public static void main(String[] args) {

        BankAccount account = new BankAccount(100.0);
        System.out.println("Initial balance: " + account.getBalance());

        try {
            account.withdraw(50.0);
            System.out.println("Balance after withdrawal: " + account.getBalance());
        } catch (IllegalArgumentException e) {
            System.err.println("Error: " + e.getMessage());
        }

        account.closeAccount();
        System.out.println("Account closed.");

        try {
            account.withdraw(20.0);
        } catch (IllegalStateException e) {
            System.err.println("Error: " + e.getMessage());
        }

    }
}

Output:
Initial balance: 100.0
Balance after withdrawal: 50.0
Account closed.
Error: Account is closed.

_________________________________________________________________________________

-> An example use case preferring RuntimeException

import java.util.ArrayList;

class ReadOnlyList<T> extends ArrayList<T> {
    @Override
    public boolean add(T t) {
        throw new UnsupportedOperationException("This list is read-only.");
    }
}



public class Main {
    public static void main(String[] args) {

        try {
            ReadOnlyList<String> roList = new ReadOnlyList<>();
            roList.add("Hello"); // will throw UnsupportedOperationException
        } catch (UnsupportedOperationException e) {
            System.err.println("Operation not supported: " + e.getMessage());
        }
    }
}

Output:
Operation not supported: This list is read-only.
_________________________________________________________________________________

-> An example use case preferring RuntimeException

package demo;

import java.util.Objects;

public class User {
    private final String name;
    private final String email;

    public User(String name, String email) {
        // Fail fast if arguments are null
        this.name = Objects.requireNonNull(name, "Name cannot be null");
        this.email = Objects.requireNonNull(email, "Email cannot be null");
    }

    public String getName() {
        return name;
    }

    public String getEmail() {
        return email;
    }

}


public class Main {
    public static void main(String[] args) {
        // âœ… Correct usage
        try {
            User user1 = new User("Alice", "alice@example.com");
            System.out.println("Created user: " + user1.getName() + ", " + user1.getEmail());
        } catch (NullPointerException e) {
            System.err.println("Error creating user1: " + e.getMessage());
        }

        // âŒ Incorrect usage: passing null for name
        try {
            User user2 = new User(null, "bob@example.com"); // will throw NPE
            System.out.println("Created user: " + user2.getName() + ", " + user2.getEmail());
        } catch (NullPointerException e) {
            System.err.println("Error creating user2: " + e.getMessage());
        }

        // âŒ Incorrect usage: passing null for email
        try {
            User user3 = new User("Charlie", null); // will throw NPE
            System.out.println("Created user: " + user3.getName() + ", " + user3.getEmail());
        } catch (NullPointerException e) {
            System.err.println("Error creating user3: " + e.getMessage());
        }
    }
}

Output:
Created user: Alice, alice@example.com
Error creating user2: Name cannot be null
Error creating user3: Email cannot be null

âœ… Why Objects.requireNonNull Is Useful Here
a) Fail Fast: Immediately throws a NullPointerException when a required parameter is missing.
b) Clear Message: The custom message helps identify exactly which argument was null.
c) Clean Code: Avoids verbose if (x == null) throw ... checks.
d) Unchecked Exception: Since NullPointerException is a RuntimeException, callers arenâ€™t forced to handle it â€” appropriate because this is a programming error.

_________________________________________________________________________________
-> RuntimeException example - Invalid Number Parsing


public class NumberFormatExceptionDemo {

    public static void main(String[] args) {
        // âœ… Correct parsing
        try {
            int num = Integer.parseInt("123");
            System.out.println("Parsed number: " + num);
        } catch (NumberFormatException e) {
            System.err.println("Error parsing number: " + e.getMessage());
        }

        // âŒ Incorrect parsing: invalid format
        try {
            int num = Integer.parseInt("abc"); // will throw NumberFormatException
            System.out.println("Parsed number: " + num);
        } catch (NumberFormatException e) {
            System.err.println("Error parsing number: " + e.getMessage());
        }

        // âŒ Incorrect parsing: contains spaces and symbols
        try {
            int num = Integer.parseInt("45.67"); // decimal format not allowed for int
            System.out.println("Parsed number: " + num);
        } catch (NumberFormatException e) {
            System.err.println("Error parsing number: " + e.getMessage());
        }
    }
}

Output:
Parsed number: 123
Error parsing number: For input string: "abc"
Error parsing number: For input string: "45.67"

_________________________________________________________________________________
-> RuntimeException example - Division by Zero


public class ArithmeticExceptionDemo {

    public static void main(String[] args) {
        // âœ… Correct division
        try {
            int result = 20 / 5;
            System.out.println("20 / 5 = " + result);
        } catch (ArithmeticException e) {
            System.err.println("Error in division: " + e.getMessage());
        }

        // âŒ Incorrect division: divisor is zero
        try {
            int result = 10 / 0; // This will throw ArithmeticException
            System.out.println("10 / 0 = " + result);
        } catch (ArithmeticException e) {
            System.err.println("Error in division: " + e.getMessage());
        }

    }
}

Output:
20 / 5 = 4
Error in division: / by zero

_________________________________________________________________________________

-> RuntimeException example - Invalid Index Access

import java.util.ArrayList;
import java.util.List;

public class IndexOutOfBoundsDemo {

    public static void main(String[] args) {
        // Example with List
        List<String> list = new ArrayList<>();
        list.add("Apple");
        list.add("Banana");
        list.add("Cherry");
        list.add("Date");
        list.add("Elderberry");

        System.out.println("List contents: " + list);

        // âœ… Correct access
        try {
            String fruit = list.get(2); // valid index
            System.out.println("Fruit at index 2: " + fruit);
        } catch (IndexOutOfBoundsException e) {
            System.err.println("Error accessing list: " + e.getMessage());
        }

        // âŒ Incorrect access: index is out of range
        try {
            String fruit = list.get(10); // will throw IndexOutOfBoundsException
            System.out.println("Fruit at index 10: " + fruit);
        } catch (IndexOutOfBoundsException e) {
            System.err.println("Error accessing list: " + e.getMessage());
        }

        // Example with Array
        String[] fruitsArray = {"Apple", "Banana", "Cherry"};

        // âŒ Incorrect access: index is out of range
        try {
            String fruit = fruitsArray[5]; // will throw ArrayIndexOutOfBoundsException
            System.out.println("Fruit at index 5: " + fruit);
        } catch (ArrayIndexOutOfBoundsException e) {
            System.err.println("Error accessing array: " + e.getMessage());
        }
    }
}

List contents: [Apple, Banana, Cherry, Date, Elderberry]
Fruit at index 2: Cherry
Error accessing list: Index 10 out of bounds for length 5
Error accessing array: Index 5 out of bounds for length 3

_________________________________________________________________________________

-> RuntimeException example - Invalid Type Casting

public class ClassCastExceptionDemo {

    public static void main(String[] args) {
        // âœ… Correct casting
        try {
            Object obj1 = "Hello World"; // obj1 actually holds a String
            String str1 = (String) obj1; // safe cast
            System.out.println("String value: " + str1);
        } catch (ClassCastException e) {
            System.err.println("Error: " + e.getMessage());
        }

        // âŒ Incorrect casting: Object holds an Integer, not a String
        try {
            Object obj2 = Integer.valueOf(42); // obj2 actually holds an Integer
            String str2 = (String) obj2; // will throw ClassCastException
            System.out.println("String value: " + str2);
        } catch (ClassCastException e) {
            System.err.println("Error: " + e.getMessage());
        }

        // âœ… Defensive approach: check type before casting
        Object obj3 = Integer.valueOf(100);
        if (obj3 instanceof String) {
            String str3 = (String) obj3;
            System.out.println("String value: " + str3);
        } else {
            System.out.println("obj3 is not a String, it's a " + obj3.getClass().getSimpleName());
        }

    }
}

Output:
String value: Hello World
obj3 is not a String, it's a Integer
Error: class java.lang.Integer cannot be cast to class java.lang.String (java.lang.Integer and java.lang.String are in module java.base of loader 'bootstrap')
_________________________________________________________________________________

-> Java RuntimeException Quick Reference

| Exception Type                                                       | When to Use                                                                    | Example Scenario                                                  |
| -------------------------------------------------------------------- | ------------------------------------------------------------------------------ | ----------------------------------------------------------------- |
| **`IllegalArgumentException`**                                       | A method receives an argument that is invalid or out of the accepted range.    | `new Rectangle(-5, 10)` â†’ width is negative.                      |
| **`NullPointerException`**                                           | A required object reference is `null` when it shouldnâ€™t be.                    | `Objects.requireNonNull(name, "Name cannot be null");`            |
| **`IllegalStateException`**                                          | A method is invoked at an inappropriate time for the objectâ€™s current state.   | Calling `withdraw()` on a closed bank account.                    |
| **`UnsupportedOperationException`**                                  | The called method is not supported in the current object.                      | Adding to a read-only list.                                       |
| **`IndexOutOfBoundsException`**                                      | Index parameter is outside the valid range for a collection, array, or string. | Accessing `list.get(10)` when list has 5 items.                   |
| **`ArithmeticException`**                                            | Illegal arithmetic operation occurs.                                           | Dividing by zero: `10 / 0`.                                       |
| **`ClassCastException`**                                             | Invalid type casting is attempted.                                             | `(String) someObject` when `someObject` is actually an `Integer`. |
| **`NumberFormatException`** (subclass of `IllegalArgumentException`) | Conversion from `String` to a number fails due to invalid format.              | `Integer.parseInt("abc")`.                                        |


âœ… Why Keep This Table Handy
a) Helps decide when unchecked exceptions are the right choice.
b) Encourages consistent exception use across a codebase.
c) Avoids the misuse of checked exceptions for programming errors.


ðŸ”¹ Key Takeaways
a) These are unchecked exceptions â€” the compiler does not force try-catch or throws.
b) They are best for programming errors, API misuse, and invalid states.
c) For recoverable errors, prefer checked exceptions to make the caller handle the situation explicitly.
_________________________________________________________________________________