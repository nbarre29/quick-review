-> 
= (assignment) Operator:     Put the value on the right‚Äëhand side into the variable on the left

Typical operands: A variable on the left, any expression on the right


== (equality/identity test) Operator:  Evaluate whether the two operands are identical

‚Ä¢ Primitives ‚Üí compares the actual numeric/boolean/char values.
‚Ä¢ Object references ‚Üí compares whether both references point to exactly the same object in memory.

Result type:  boolean

Common Pitfalls:  Using == on objects when you really want logical equality (contents), which should be done with .equals() (e.g., two different String objects containing "hello" are not == but they are equals).


public class Main {
    public static void main(String[] args) {
        // = (assignment)
        int a = 3;          // a now holds the value 3
        int b = a;          // b gets a copy of 3
        b = b + 2;          // b reassigned to 5; a is still 3

        System.out.println(a);  // 3
        System.out.println(b);  // 5

       // == with primitives
        int x = 7;
        int y = 7;
        System.out.println(x == y);   // true  (same numeric value)

        // == with object references
        String s1 = new String("hi");
        String s2 = new String("hi");
        System.out.println(s1 == s2);      // false (different objects)
        System.out.println(s1.equals(s2)); // true  (same characters)

        // Beware of Boolean assignment in conditions
        boolean flag = false;

        // if (flag = true) { ... }   // compiles and always runs, bug!
        // if (flag == true) { ... }  // comparison, but better:

        //This is considered idiomatic because it is the simplest and most readable way to check if a boolean variable (flag) is true.
        // It avoids unnecessary comparisons like if (flag == true) or potential bugs like if (flag = true) (which is an assignment, not a comparison).
        if (flag) {  // idiomatic
            System.out.println("Flag is true");
        } else {
            System.out.println("Flag is false");
        }

    }
}

Rules of thumb

    Use = only to store a value.

    Use == for primitives and to check if two references point to the same object (identity).

    Use .equals() for logical/content equality between objects (Strings, collections, your own classes, etc.).
	
------------------------------------------------------------------------------------	
class Person {
    String name;
    Person(String name) { this.name = name; }
}

public class ReferencePitfall {
    public static void main(String[] args) {
        Person p1 = new Person("Bob");
        Person p2 = p1;          // ‚Üê just copies the *reference*

        p2.name = "Alice";       // mutate through p2

        System.out.println(p1.name); // prints "Alice"!
        System.out.println(p2.name); // prints "Alice"
        System.out.println(p1 == p2); // true  ‚Äì same object identity
    }
}

What happened?

    new Person("Bob") allocates one Person object.

    p1 holds the address of that object.

    p2 = p1 copies that address ‚Äî no new Person is created.

    Changing p2.name changes the single shared object, so p1.name shows the same update.

------------------------------------------------------------------------------------

//A collection example you might hit in real code
import java.util.ArrayList;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<String> listA = new ArrayList<>();
        listA.add("one");

        List<String> listB = listA;   // same list instance
        listB.add("two");

        System.out.println(listA);    // [one, two]
        System.out.println(listB);    // [one, two]

    }
}
Many beginners expect listB to be an independent copy; instead, both variables view the same underlying ArrayList.
------------------------------------------------------------------------------------
//How to get an independent copy (clone vs. copy‚Äëconstructor)
import java.util.ArrayList;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<String> listA = new ArrayList<>();
        listA.add("one");

        List<String> listB = new ArrayList<>(listA); // copy‚Äëconstructor
        listB.add("two");

        System.out.println(listA); // [one]
        System.out.println(listB); // [one, two]

    }
}

Copy constructor / factory (preferred): create a new object initialized from the old one.

clone(): rarely used directly today; if you implement it, remember it gives only a shallow copy unless you deep‚Äëclone internal fields yourself.
_____________________________________________________________________________________

-> 
Just a **simple, clear example** (like the `ArrayList` one above) that demonstrates a **copy constructor** ‚Äî but with a *custom class*, so it‚Äôs obvious what ‚Äúindependent copy‚Äù means.


// Demonstrating Copy Constructor ‚Äî independent copy

public class Book {
    private String title;
    private final String author;

    // Regular constructor
    public Book(String title, String author) {
        this.title = title;
        this.author = author;
    }

    // Copy constructor
    public Book(Book other) {
        this.title = other.title;
        this.author = other.author;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    @Override
    public String toString() {
        return "Book{title='" + title + "', author='" + author + "'}";
    }
}



public class Main {
    public static void main(String[] args) {
        Book original = new Book("Effective Java", "Joshua Bloch");

        // Create an independent copy using copy constructor
        Book copy = new Book(original);

        // Modify copy to show they are independent
        copy.setTitle("Java Concurrency in Practice");

        System.out.println("Original: " + original);
        System.out.println("Copy:     " + copy);
    }
}


### üß† Output:

Original: Book{title='Effective Java', author='Joshua Bloch'}
Copy:     Book{title='Java Concurrency in Practice', author='Joshua Bloch'}


### ‚úÖ Key Point:

* `copy` was created with the **copy constructor**, so changing its title doesn‚Äôt affect `original`.
* Both objects are now **independent** in memory ‚Äî not references to the same instance.

_____________________________________________________________________________________

-> Updated above example showing a shallow copy: `Book.java` now contains a mutable `List<String> notes` and the copy constructor copies the list reference (shallow copy). `Main.java` demonstrates that adding a note to the copied book also affects the original, while changing the title (immutable `String`) does not.


import java.util.ArrayList;
import java.util.List;

public class Book {

    private String title;
    private final String author;
    private final List<String> notes;

    public Book(String title, String author) {
        this.title = title;
        this.author = author;
        this.notes = new ArrayList<>();
    }

    // Shallow copy: copies primitive/immutable fields and the reference to the mutable list
    public Book(Book other) {
        this.title = other.title;
        this.author = other.author;
        this.notes = other.notes; // <- shallow copy: both objects share the same list
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public void addNote(String note) {
        this.notes.add(note);
    }

    public List<String> getNotes() {
        return notes;
    }

    @Override
    public String toString() {
        return "Book{" +
                "title='" + title + '\'' +
                ", author='" + author + '\'' +
                ", notes=" + notes +
                '}';
    }
}

// src/main/java/Main.java
public class Main {
    public static void main(String[] args) {
        Book originalBook = new Book("1984", "George Orwell");
        originalBook.addNote("First edition note");

        Book copiedBook = new Book(originalBook); // shallow copy: shares notes list

        System.out.println("Original Book: " + originalBook);
        System.out.println("Copied Book: " + copiedBook);

        // Modify the shared mutable state through the copied book
        copiedBook.addNote("Added via copiedBook");
        System.out.println("\nAfter adding a note to copiedBook (shared list):");
        System.out.println("Original Book: " + originalBook);
        System.out.println("Copied Book: " + copiedBook);

        // Change an immutable field on the copy (title) to show independence
        copiedBook.setTitle("Animal Farm");
        System.out.println("\nAfter changing copiedBook title:");
        System.out.println("Original Book: " + originalBook);
        System.out.println("Copied Book: " + copiedBook);
    }
}


Output:

Original Book: Book{title='1984', author='George Orwell', notes=[First edition note]}
Copied Book: Book{title='1984', author='George Orwell', notes=[First edition note]}

After adding a note to copiedBook (shared list):
Original Book: Book{title='1984', author='George Orwell', notes=[First edition note, Added via copiedBook]}
Copied Book: Book{title='1984', author='George Orwell', notes=[First edition note, Added via copiedBook]}

After changing copiedBook title:
Original Book: Book{title='1984', author='George Orwell', notes=[First edition note, Added via copiedBook]}
Copied Book: Book{title='Animal Farm', author='George Orwell', notes=[First edition note, Added via copiedBook]}

-------------------------------------------------------------------------------------

-> Create a new list in the copy constructor so the copied `Book` gets its own `List` instance. If the list holds mutable objects, deep-copy each element inside the new list.

// Deep-ish copy: creates a new list containing the same elements
    // (strings are immutable; if elements were mutable, clone each element here)
    public Book(Book other) {
        this.title = other.title;
        this.author = other.author;
        this.notes = new ArrayList<>(other.notes); // <- deep copy of the list
    }
	
	
Output:

Original Book: Book{title='1984', author='George Orwell', notes=[First edition note]}
Copied Book: Book{title='1984', author='George Orwell', notes=[First edition note]}

After adding a note to copiedBook (shared list):
Original Book: Book{title='1984', author='George Orwell', notes=[First edition note]}
Copied Book: Book{title='1984', author='George Orwell', notes=[First edition note, Added via copiedBook]}

After changing copiedBook title:
Original Book: Book{title='1984', author='George Orwell', notes=[First edition note]}
Copied Book: Book{title='Animal Farm', author='George Orwell', notes=[First edition note, Added via copiedBook]}

_____________________________________________________________________________________

->  here‚Äôs another **simple but realistic example** of a **copy constructor**, this time using a `Person` class that contains a nested `Address` object ‚Äî to show how the copy constructor can make an **independent copy** even when one class contains another.


// Demonstrating Copy Constructor with Nested Object (Deep Copy Example)

public class Address {
    private String city;
    private final String state;

    public Address(String city, String state) {
        this.city = city;
        this.state = state;
    }

    // Copy constructor for Address
    public Address(Address other) {
        this.city = other.city;
        this.state = other.state;
    }

    public void setCity(String city) {
        this.city = city;
    }

    @Override
    public String toString() {
        return city + ", " + state;
    }
}

public class Person {
    private String name;
    private final Address address;

    public Person(String name, Address address) {
        this.name = name;
        this.address = address;
    }

    // Copy constructor for Person (deep copy)
    public Person(Person other) {
        this.name = other.name;
        this.address = new Address(other.address); // copy inner object too
    }

    public void setName(String name) {
        this.name = name;
    }

    public Address getAddress() {
        return address;
    }

    @Override
    public String toString() {
        return "Person{name='" + name + "', address=" + address + "}";
    }
}

public class Main {
    public static void main(String[] args) {
        Address addr1 = new Address("Princeton", "NJ");
        Person original = new Person("Alice", addr1);

        // Create an independent copy using copy constructor
        Person copy = new Person(original);

        // Modify copy's data
        copy.setName("Bob");
        copy.getAddress().setCity("Edison");

        System.out.println("Original: " + original);
        System.out.println("Copy:     " + copy);
    }
}
```

---

### üß† Output:

Original: Person{name='Alice', address=Princeton, NJ}
Copy:     Person{name='Bob', address=Edison, NJ}

---

### ‚úÖ Why This Is a Great Example:

* The **copy constructor of `Person`** calls the **copy constructor of `Address`** ‚Äî making it a **deep copy**.
* Modifying the city in the copy‚Äôs address doesn‚Äôt affect the original.
* You can clearly see how copy constructors create **independent objects**, not shared references.

_____________________________________________________________________________________

-> Perfect üëå ‚Äî here‚Äôs the **shallow copy version** of the same `Person` example.
You‚Äôll see exactly how skipping a deep copy causes the **two objects to share the same inner `Address`**, so changing one affects the other.

---


// Demonstrating Shallow Copy ‚Äî inner object is shared

public class Address {
    private String city;
    private final String state;

    public Address(String city, String state) {
        this.city = city;
        this.state = state;
    }

    public void setCity(String city) {
        this.city = city;
    }

    @Override
    public String toString() {
        return city + ", " + state;
    }
}

public class Person {
    private String name;
    private final Address address;

    public Person(String name, Address address) {
        this.name = name;
        this.address = address;
    }

    // ‚ùå Shallow copy constructor (does NOT create new Address)
    public Person(Person other) {
        this.name = other.name;
        this.address = other.address; // same reference
    }

    public void setName(String name) {
        this.name = name;
    }

    public Address getAddress() {
        return address;
    }

    @Override
    public String toString() {
        return "Person{name='" + name + "', address=" + address + "}";
    }
}

public class Main {
    public static void main(String[] args) {
        Address addr1 = new Address("Princeton", "NJ");
        Person original = new Person("Alice", addr1);

        // Create shallow copy (shares Address)
        Person copy = new Person(original);

        // Modify copy‚Äôs data
        copy.setName("Bob");
        copy.getAddress().setCity("Edison"); // changes the shared Address

        System.out.println("Original: " + original);
        System.out.println("Copy:     " + copy);
    }
}


---

### üß† Output:

Original: Person{name='Alice', address=Edison, NJ}
Copy:     Person{name='Bob', address=Edison, NJ}



### ‚ö†Ô∏è What Happened:

* Both `Person` objects **share the same `Address` instance** because of the shallow copy.
* Changing the city in one automatically changes it in the other.
* That‚Äôs why we need a **deep copy constructor** (`this.address = new Address(other.address)`) if we want them independent.

_____________________________________________________________________________________

-> java.util.function.Supplier<T> at a glance

What it is : A functional interface with a single method T get(); that returns a value and accepts no arguments.

import java.util.function.Supplier;
import java.util.Random;

public class SupplierDemo {
    public static void main(String[] args) {
        Random randomGenerator = new Random();

        Supplier<Integer> randomInt = () -> randomGenerator.nextInt(100); // 0‚Äë99

        System.out.println("Random #1: " + randomInt.get());
        System.out.println("Random #2: " + randomInt.get());
    }
}

Output:
Random #1: 50
Random #2: 81
------------------------------------------------------------------------------------

The Function interface takes an input and produces an output, so we can use it to pass the upper bound for the random number generation. 
Same functionality as above but using Function instead of Supplier

import java.util.Random;
import java.util.function.Function;

public class FunctionDemo {
    public static void main(String[] args) {
        Random randomGenerator = new Random();

        
        Function<Integer, Integer> randomInt = bound -> randomGenerator.nextInt(bound); // 0‚Äë99
		//Function<Integer, Integer> randomInt = randomGenerator::nextInt; // we can replace the above lambda with method reference

        System.out.println("Random #1: " + randomInt.apply(100));
        System.out.println("Random #2: " + randomInt.apply(100));
    }
}

_____________________________________________________________________________________

-> java.util.function.Supplier<T> can be used as a factory in Streams

import java.util.List;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class SupplierDemo {
    public static void main(String[] args) {
        Supplier<Stream<String>> nameStream = () -> Stream.of("Ana", "Bob", "Cleo");

        List<String> upper   = nameStream.get()
                .map(String::toUpperCase)
                .collect(Collectors.toList());

        List<String> filtered = nameStream.get()
                .filter(s -> s.length() <= 3)
                .collect(Collectors.toList());

        System.out.println(upper);     // [ANA, BOB, CLEO]
        System.out.println(filtered);  // [Ana, Bob]
    }
}

Why a Supplier<Stream>? Streams are single‚Äëuse; using a supplier lets you obtain a fresh stream each time.
Java Streams are designed to be single-use: Once you perform a terminal operation on a stream, the stream is considered consumed and cannot be used again.


Key takeaways

    Supplier produces, never consumes.

    Great for factory patterns
_____________________________________________________________________________________

-> java.util.function.Function<T, R> vs java.util.function.BiFunction<T, U, R>

    Aspect:

        Function<T, R>: Represents an operation on one input that produces a result.

        BiFunction<T, U, R>: Represents an operation on two inputs that produces a result.

    Purpose:

        Function<T, R>: Used to represent an operation on one input that results in an output.

        BiFunction<T, U, R>: Used for an operation on two inputs, producing a result.

    Method Signature:

        Function<T, R>: R apply(T t)

        BiFunction<T, U, R>: R apply(T t, U u)

    Generics:

        Function<T, R>: 2 type parameters: input, result.

        BiFunction<T, U, R>: 3 type parameters: first input, second input, result.

    Key Default Methods:

        Function<T, R>: andThen(Function) - chain unary functions.

        BiFunction<T, U, R>: andThen(Function) - post-process the result of the bi-operation.

    Typical Stream Use:

        Function<T, R>: Commonly used with map to transform elements one-by-one.

        BiFunction<T, U, R>: Rarely used inside streams (needs two separate elements), but common in collectors, Map.compute, reduce, etc.

    Analogy:

        Function<T, R>: "Mapper"

        BiFunction<T, U, R>: "Combiner" / "Merger"
		
-----------------------------------------------------------------------------------------------------	
1) Function - transform a single value
import java.util.function.Function;

public class Main {
    public static void main(String[] args) {
        Function<String, Integer> lengthFn = s -> s.length();
		//Function<String, Integer> lengthFn = String::length;   // replace above lambda with method reference

        int len = lengthFn.apply("ChatGPT"); // ‚Üí 7
        System.out.println("Length of 'ChatGPT': " + len);

    }
}
-----------------------------------------------------------------------------------------------------
2) BiFunction ‚Äì combine two values

import java.util.function.BiFunction;

public class Main {
    public static void main(String[] args) {
        BiFunction<Integer, Integer, Integer> add = (a, b) -> a + b;

        int sum = add.apply(3, 4); // ‚Üí 7
        System.out.println("Sum: " + sum);

    }
}
_____________________________________________________________________________________

-> Implementing the Supplier<T> Interface
https://dev.java/learn/lambdas/functional-interfaces/

import java.util.function.Supplier;

public class SupplierExample {
    public static void main(String[] args) {
        // Create a Supplier that returns a String
        Supplier<String> supplier = () -> "Hello Duke!";

        // Call get() method to retrieve the value
        String message = supplier.get();

        System.out.println(message);  // Hello Duke!
    }
}
_____________________________________________________________________________________

-> Implementing the Supplier<T> Interface
https://dev.java/learn/lambdas/functional-interfaces/

import java.util.Random;
import java.util.function.Supplier;

public class RandomSupplierExample {
    public static void main(String[] args) {
        // Create a Random object seeded with 314L
        Random random = new Random(314L);

        // Create a Supplier that returns random integers between 0 and 9
        Supplier<Integer> newRandom = () -> random.nextInt(10);

        // Generate and print 5 random numbers
        for (int index = 0; index < 5; index++) {
            System.out.println(newRandom.get() + " ");
        }
    }
}

Output:
1 
5 
3 
0 
2 

Random(314L) ‚Üí You created a Random object with a fixed seed (314), meaning the random numbers will always be the same sequence every time you run the program (good for testing).
----------------------------------------------------------------------------------
-> Refactored above to avoid boxing / unboxing with the usage of IntSupplier interface

import java.util.Random;
import java.util.function.IntSupplier;

public class RandomSupplierExample {
    public static void main(String[] args) {
        // Create a Random object seeded with 314L
        Random random = new Random(314L);

        IntSupplier newRandom = () -> random.nextInt(10);

        for (int index = 0; index < 5; index++) {
            System.out.println(newRandom.getAsInt() + " ");
        }
    }
}

The result of running this code is the same, but this time no boxing / unboxing occurred: this code is more performant than the previous one.

_____________________________________________________________________________________

-> Consuming Objects with Consumer<T>
https://dev.java/learn/lambdas/functional-interfaces/

A consumer does the opposite of the supplier: it takes an argument and does not return anything.

import java.util.function.Consumer;

public class RandomSupplierExample {
    public static void main(String[] args) {

        Consumer<String> printer = s -> System.out.println(s);

        // Test the Consumer with some sample strings
        printer.accept("Hello, World!");
        printer.accept("Testing Consumer in Java.");
        printer.accept("This is a test message.");
    }
}

Output:
Hello, World!
Testing Consumer in Java.
This is a test message.

--------------
Replace lambda with method reference:
Consumer<String> printer = System.out::println;
--------------

_____________________________________________________________________________________

-> Mapping Objects to Other Objects with Function<T, R>
https://dev.java/learn/lambdas/functional-interfaces/

Represents a function that accepts one argument and produces a result.

import java.util.function.Function;

public class Main {
    public static void main(String[] args) {
        Function<String, Integer> toLength = s -> s.length();
		// Function<String, Integer> toLength = String::length;  // replace lambda with method reference
        String word = "Hello, world!";
        Integer length = toLength.apply(word);
        System.out.println("The length of the word \"" + word + "\" is: " + length);
    }
}

Output:
The length of the word "Hello, world!" is: 13

What is happening with \"?

    The backslash \ is the escape character in Java strings.
    It tells Java: "The next character should be treated specially."
    In this case, \" means: Insert a double quote " character inside the string, not end the string.

‚úÖ Otherwise, if you wrote a " without escaping, Java would get confused and think the string ends there.
_____________________________________________________________________________________
-> Testing Objects with Predicate<T>
https://dev.java/learn/lambdas/functional-interfaces/
A predicate is used to test an object. It is used for filtering streams in the Stream API.
It takes an object and returns a boolean value.

import java.util.function.Predicate;

public class Main {
    public static void main(String[] args) {
        Predicate<String> length3 = s -> s.length() == 3;
        String word = "cat";
        boolean isOfLength3 = length3.test(word);
        System.out.println("Is of length 3? " + isOfLength3);  // Is of length 3? true
    }
}
_____________________________________________________________________________________
->
import java.util.Arrays;
import java.util.List;
import java.util.function.Predicate;

public class PredicateExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        // Using a lambda expression to create a predicate
        Predicate<Integer> isEven = number -> number % 2 == 0;

        // Filtering the list using the stream API and the predicate
        List<Integer> evenNumbers = numbers.stream()
                .filter(isEven)
                .toList();

        System.out.println("Even numbers: " + evenNumbers); // Output: Even numbers: [2, 4, 6, 8, 10]
    }
}

Output:
Even numbers: [2, 4, 6, 8, 10]
-----------------------------------------------------------------------------------

-> The above implementation is concise and adheres to functional programming principles. Explicitly calling test would add unnecessary verbosity without any functional benefit.
Below code explicitly calls the test method to check if each number is even.

import java.util.Arrays;
import java.util.List;
import java.util.function.Predicate;

public class PredicateExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        // Using a lambda expression to create a predicate
        Predicate<Integer> isEven = number -> number % 2 == 0;

        // Explicitly using the test method of the Predicate
        for (Integer number : numbers) {
            if (isEven.test(number)) {
                System.out.println(number + " is even");
            } else {
                System.out.println(number + " is odd");
            }
        }

    }
}

Output:
1 is odd
2 is even
3 is odd
4 is even
5 is odd
6 is even
7 is odd
8 is even
9 is odd
10 is even

_____________________________________________________________________________________

-> when you want to apply a function to each element of a collection and transform it (like how filter works with Predicate), the **map** operation in a stream uses a Function. 

Here‚Äôs a breakdown of how Function is used in the map operation:

import java.util.Arrays;
import java.util.List;
import java.util.function.Function;
import java.util.stream.Collectors;

public class FunctionMapExample {
    public static void main(String[] args) {
        // Example collection of integers
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

        // Define a Function to square each number
        Function<Integer, Integer> squareFunction = x -> x * x;

        // Use map to apply the function to each element
        List<Integer> squaredNumbers = numbers.stream()
                                                .map(squareFunction)
                                                .collect(Collectors.toList());

        // Print the squared numbers
        squaredNumbers.forEach(System.out::println);
    }
}

Output:
1
4
9
16
25
_____________________________________________________________________________________


-> Testing Two Elements with a BiPredicate
https://dev.java/learn/lambdas/functional-interfaces/

import java.util.function.BiPredicate;

public class Main {
    public static void main(String[] args) {
        BiPredicate<String, Integer> isOfLength = (word, length) -> word.length() == length;
        String word = "cat";
        int length = 3;
        boolean isWordOfLength3 = isOfLength.test(word, length);
        System.out.println("Is the word '" + word + "' of length " + length + "? " + isWordOfLength3);   // Is the word 'cat' of length 3? true
    }
}
_____________________________________________________________________________________
-> Passing a Predicate to a Collection
https://dev.java/learn/lambdas/functional-interfaces/

import java.util.ArrayList;
import java.util.List;
import java.util.function.Predicate;

public class Main {
    public static void main(String[] args) {
        List<String> immutableStrings =
                List.of("one", "two", "three", "four", "five");
        List<String> strings = new ArrayList<>(immutableStrings);
        Predicate<String> isEvenLength = s -> s.length() % 2 == 0;
        strings.removeIf(isEvenLength);
        System.out.println("strings = " + strings);

    }
}

Output:
strings = [one, two, three]
_____________________________________________________________________________________

-> 
public class Main {

    public static void main(String[] args) {
        int[] numbers = {1, 2, 3, 4, 5};
        int sum = 0;
        for (int number : numbers) {
            sum += number;
        }

        System.out.println("The sum of the array is: " + sum);


        // above code in functional style
        int functionalSum = java.util.Arrays.stream(numbers)
                .reduce(0, Integer::sum);
        System.out.println("The sum of the array using functional style is: " + functionalSum);
    }
}

Output:
The sum of the array is: 15
The sum of the array using functional style is: 15
_____________________________________________________________________________________

-> 
import java.util.Arrays;
import java.util.List;

public class Main {

    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(2, 3, 4, 5, 6);

        // 1. Reduce with identity and accumulator
        int sum = numbers.stream()
                .reduce(0, (a, b) -> a + b); // or Integer::sum
				
		// replace above lambda with method reference
		// int sum = numbers.stream().reduce(0, Integer::sum);

        System.out.println("Sum using reduce: " + sum);

        // 2. Reduce to find the product
        int product = numbers.stream()
                .reduce(1, (a, b) -> a * b);
        System.out.println("Product using reduce: " + product);

        // 3. Reduce to find the maximum
        int max = numbers.stream()
                .reduce(Integer.MIN_VALUE, Integer::max);
        System.out.println("Max using reduce: " + max);

        // 4. Reduce without identity - returns Optional
        numbers.stream()
                .reduce((a, b) -> a + b)
                .ifPresent(result -> System.out.println("Sum (no identity): " + result));
				
		 // replace above lambda with method reference
//        numbers.stream()
//                .reduce(Integer::sum)
//                .ifPresent(result -> System.out.println("Sum (no identity): " + result));
    }
}

Output:
Sum using reduce: 20
Product using reduce: 720
Max using reduce: 6
Sum (no identity): 20


| Use Case    | Code                                      | Output                      |
| ----------- | ----------------------------------------- | --------------------------- |
| Sum         | `reduce(0, (a, b) -> a + b)`              | Adds all numbers            |
| Product     | `reduce(1, (a, b) -> a * b)`              | Multiplies all numbers      |
| Max         | `reduce(Integer.MIN_VALUE, Integer::max)` | Finds maximum value         |
| No identity | `reduce((a, b) -> a + b)`                 | Returns `Optional<Integer>` |

_____________________________________________________________________________________

-> Use Stream.reduce() with custom objects ‚Äî specifically, summing up prices in a list of Product objects.


import java.util.Arrays;
import java.util.List;

public class ProductReduceExample {
    public static void main(String[] args) {
        List<Product> products = Arrays.asList(
                new Product("Book", 15.99),
                new Product("Pen", 1.49),
                new Product("Notebook", 6.25)
        );

        // 1. Use reduce with an identity and accumulator
        Double totalPrice = products.stream()
                .map(Product::getPrice)
                .reduce(0.0, (total, price) -> total + price);  // can replace with Double::sum instead of lambda here

        System.out.println("Total Price: $" + totalPrice);

        // 2. Use reduce without an identity ( returns Optional<Double> )
        products.stream()
                .map(Product::getPrice)
                .reduce(Double::sum)
                .ifPresent(sum -> System.out.println("Total (optional): $" + sum));
    }
}

Output:
Total Price: $23.73
Total (optional): $23.73
_____________________________________________________________________________________

-> Find Most Expensive Product with reduce()



public class Product {
    private final String name;
    private final double price;

    public Product(String name, double price) {
        this.name = name;
        this.price = price;
    }

    public double getPrice() {
        return price;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return name + " ($" + price + ")";
    }
}


import java.util.Arrays;
import java.util.List;

public class MaxProductReduceExample {
    public static void main(String[] args) {
        List<Product> products = Arrays.asList(
            new Product("Book", 15.99),
            new Product("Pen", 1.49),
            new Product("Notebook", 6.25),
            new Product("Headphones", 29.99)
        );

        // Use reduce to find the product with the highest price
        products.stream()
            .reduce((p1, p2) -> p1.getPrice() > p2.getPrice() ? p1 : p2)
            .ifPresent(maxProduct -> System.out.println("Most expensive product: " + maxProduct));
    }
}

Output:
Most expensive product: Headphones ($29.99)


The `reduce` method is a terminal operation that processes elements of a stream and combines them into a single result.

The lambda expression `(p1, p2) -> p1.getPrice() > p2.getPrice() ? p1 : p2` compares two `Product` objects (`p1` and `p2`) based on their `price` property. If the price of `p1` is greater than the price of `p2`, `p1` is returned; otherwise, `p2` is returned. This ensures that the stream iterates through all products and keeps the one with the highest price.

For example, if the stream contains products with prices `15.99`, `1.49`, `6.25`, and `29.99`, the `reduce` operation will compare each pair of products and ultimately return the product with the price `29.99`.

The result of the `reduce` operation is wrapped in an `Optional`, as the stream might be empty, in which case no product can be returned. The `ifPresent` method is then used to print the most expensive product if it exists.
_____________________________________________________________________________________





