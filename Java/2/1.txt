-> 
= (assignment) Operator:     Put the value on the right‚Äëhand side into the variable on the left

Typical operands: A variable on the left, any expression on the right


== (equality/identity test) Operator:  Evaluate whether the two operands are identical

‚Ä¢ Primitives ‚Üí compares the actual numeric/boolean/char values.
‚Ä¢ Object references ‚Üí compares whether both references point to exactly the same object in memory.

Result type:  boolean

Common Pitfalls:  Using == on objects when you really want logical equality (contents), which should be done with .equals() (e.g., two different String objects containing "hello" are not == but they are equals).


public class Main {
    public static void main(String[] args) {
        // = (assignment)
        int a = 3;          // a now holds the value 3
        int b = a;          // b gets a copy of 3
        b = b + 2;          // b reassigned to 5; a is still 3

        System.out.println(a);  // 3
        System.out.println(b);  // 5

       // == with primitives
        int x = 7;
        int y = 7;
        System.out.println(x == y);   // true  (same numeric value)

        // == with object references
        String s1 = new String("hi");
        String s2 = new String("hi");
        System.out.println(s1 == s2);      // false (different objects)
        System.out.println(s1.equals(s2)); // true  (same characters)

        // Beware of Boolean assignment in conditions
        boolean flag = false;

        // if (flag = true) { ... }   // compiles and always runs, bug!
        // if (flag == true) { ... }  // comparison, but better:

        //This is considered idiomatic because it is the simplest and most readable way to check if a boolean variable (flag) is true.
        // It avoids unnecessary comparisons like if (flag == true) or potential bugs like if (flag = true) (which is an assignment, not a comparison).
        if (flag) {  // idiomatic
            System.out.println("Flag is true");
        } else {
            System.out.println("Flag is false");
        }

    }
}

Rules of thumb

    Use = only to store a value.

    Use == for primitives and to check if two references point to the same object (identity).

    Use .equals() for logical/content equality between objects (Strings, collections, your own classes, etc.).
	
------------------------------------------------------------------------------------	
class Person {
    String name;
    Person(String name) { this.name = name; }
}

public class ReferencePitfall {
    public static void main(String[] args) {
        Person p1 = new Person("Bob");
        Person p2 = p1;          // ‚Üê just copies the *reference*

        p2.name = "Alice";       // mutate through p2

        System.out.println(p1.name); // prints "Alice"!
        System.out.println(p2.name); // prints "Alice"
        System.out.println(p1 == p2); // true  ‚Äì same object identity
    }
}

What happened?

    new Person("Bob") allocates one Person object.

    p1 holds the address of that object.

    p2 = p1 copies that address ‚Äî no new Person is created.

    Changing p2.name changes the single shared object, so p1.name shows the same update.

------------------------------------------------------------------------------------

//A collection example you might hit in real code
import java.util.ArrayList;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<String> listA = new ArrayList<>();
        listA.add("one");

        List<String> listB = listA;   // same list instance
        listB.add("two");

        System.out.println(listA);    // [one, two]
        System.out.println(listB);    // [one, two]

    }
}
Many beginners expect listB to be an independent copy; instead, both variables view the same underlying ArrayList.
------------------------------------------------------------------------------------
//How to get an independent copy (clone vs. copy‚Äëconstructor)
import java.util.ArrayList;
import java.util.List;

public class Main {
    public static void main(String[] args) {
        List<String> listA = new ArrayList<>();
        listA.add("one");

        List<String> listB = new ArrayList<>(listA); // copy‚Äëconstructor
        listB.add("two");

        System.out.println(listA); // [one]
        System.out.println(listB); // [one, two]

    }
}

Copy constructor / factory (preferred): create a new object initialized from the old one.

clone(): rarely used directly today; if you implement it, remember it gives only a shallow copy unless you deep‚Äëclone internal fields yourself.
_____________________________________________________________________________________

-> 
Just a **simple, clear example** (like the `ArrayList` one above) that demonstrates a **copy constructor** ‚Äî but with a *custom class*, so it‚Äôs obvious what ‚Äúindependent copy‚Äù means.


// Demonstrating Copy Constructor ‚Äî independent copy

public class Book {
    private String title;
    private final String author;

    // Regular constructor
    public Book(String title, String author) {
        this.title = title;
        this.author = author;
    }

    // Copy constructor
    public Book(Book other) {
        this.title = other.title;
        this.author = other.author;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    @Override
    public String toString() {
        return "Book{title='" + title + "', author='" + author + "'}";
    }
}



public class Main {
    public static void main(String[] args) {
        Book original = new Book("Effective Java", "Joshua Bloch");

        // Create an independent copy using copy constructor
        Book copy = new Book(original);

        // Modify copy to show they are independent
        copy.setTitle("Java Concurrency in Practice");

        System.out.println("Original: " + original);
        System.out.println("Copy:     " + copy);
    }
}


### üß† Output:

Original: Book{title='Effective Java', author='Joshua Bloch'}
Copy:     Book{title='Java Concurrency in Practice', author='Joshua Bloch'}


### ‚úÖ Key Point:

* `copy` was created with the **copy constructor**, so changing its title doesn‚Äôt affect `original`.
* Both objects are now **independent** in memory ‚Äî not references to the same instance.

_____________________________________________________________________________________

-> Updated above example showing a shallow copy: `Book.java` now contains a mutable `List<String> notes` and the copy constructor copies the list reference (shallow copy). `Main.java` demonstrates that adding a note to the copied book also affects the original, while changing the title (immutable `String`) does not.


import java.util.ArrayList;
import java.util.List;

public class Book {

    private String title;
    private final String author;
    private final List<String> notes;

    public Book(String title, String author) {
        this.title = title;
        this.author = author;
        this.notes = new ArrayList<>();
    }

    // Shallow copy: copies primitive/immutable fields and the reference to the mutable list
    public Book(Book other) {
        this.title = other.title;
        this.author = other.author;
        this.notes = other.notes; // <- shallow copy: both objects share the same list
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public void addNote(String note) {
        this.notes.add(note);
    }

    public List<String> getNotes() {
        return notes;
    }

    @Override
    public String toString() {
        return "Book{" +
                "title='" + title + '\'' +
                ", author='" + author + '\'' +
                ", notes=" + notes +
                '}';
    }
}

// src/main/java/Main.java
public class Main {
    public static void main(String[] args) {
        Book originalBook = new Book("1984", "George Orwell");
        originalBook.addNote("First edition note");

        Book copiedBook = new Book(originalBook); // shallow copy: shares notes list

        System.out.println("Original Book: " + originalBook);
        System.out.println("Copied Book: " + copiedBook);

        // Modify the shared mutable state through the copied book
        copiedBook.addNote("Added via copiedBook");
        System.out.println("\nAfter adding a note to copiedBook (shared list):");
        System.out.println("Original Book: " + originalBook);
        System.out.println("Copied Book: " + copiedBook);

        // Change an immutable field on the copy (title) to show independence
        copiedBook.setTitle("Animal Farm");
        System.out.println("\nAfter changing copiedBook title:");
        System.out.println("Original Book: " + originalBook);
        System.out.println("Copied Book: " + copiedBook);
    }
}


Output:

Original Book: Book{title='1984', author='George Orwell', notes=[First edition note]}
Copied Book: Book{title='1984', author='George Orwell', notes=[First edition note]}

After adding a note to copiedBook (shared list):
Original Book: Book{title='1984', author='George Orwell', notes=[First edition note, Added via copiedBook]}
Copied Book: Book{title='1984', author='George Orwell', notes=[First edition note, Added via copiedBook]}

After changing copiedBook title:
Original Book: Book{title='1984', author='George Orwell', notes=[First edition note, Added via copiedBook]}
Copied Book: Book{title='Animal Farm', author='George Orwell', notes=[First edition note, Added via copiedBook]}

-------------------------------------------------------------------------------------

-> Create a new list in the copy constructor so the copied `Book` gets its own `List` instance. If the list holds mutable objects, deep-copy each element inside the new list.

// Deep-ish copy: creates a new list containing the same elements
    // (strings are immutable; if elements were mutable, clone each element here)
    public Book(Book other) {
        this.title = other.title;
        this.author = other.author;
        this.notes = new ArrayList<>(other.notes); // <- deep copy of the list
    }
	
	
Output:

Original Book: Book{title='1984', author='George Orwell', notes=[First edition note]}
Copied Book: Book{title='1984', author='George Orwell', notes=[First edition note]}

After adding a note to copiedBook (shared list):
Original Book: Book{title='1984', author='George Orwell', notes=[First edition note]}
Copied Book: Book{title='1984', author='George Orwell', notes=[First edition note, Added via copiedBook]}

After changing copiedBook title:
Original Book: Book{title='1984', author='George Orwell', notes=[First edition note]}
Copied Book: Book{title='Animal Farm', author='George Orwell', notes=[First edition note, Added via copiedBook]}

_____________________________________________________________________________________

->  here‚Äôs another **simple but realistic example** of a **copy constructor**, this time using a `Person` class that contains a nested `Address` object ‚Äî to show how the copy constructor can make an **independent copy** even when one class contains another.


// Demonstrating Copy Constructor with Nested Object (Deep Copy Example)

public class Address {
    private String city;
    private final String state;

    public Address(String city, String state) {
        this.city = city;
        this.state = state;
    }

    // Copy constructor for Address
    public Address(Address other) {
        this.city = other.city;
        this.state = other.state;
    }

    public void setCity(String city) {
        this.city = city;
    }

    @Override
    public String toString() {
        return city + ", " + state;
    }
}

public class Person {
    private String name;
    private final Address address;

    public Person(String name, Address address) {
        this.name = name;
        this.address = address;
    }

    // Copy constructor for Person (deep copy)
    public Person(Person other) {
        this.name = other.name;
        this.address = new Address(other.address); // copy inner object too
    }

    public void setName(String name) {
        this.name = name;
    }

    public Address getAddress() {
        return address;
    }

    @Override
    public String toString() {
        return "Person{name='" + name + "', address=" + address + "}";
    }
}

public class Main {
    public static void main(String[] args) {
        Address addr1 = new Address("Princeton", "NJ");
        Person original = new Person("Alice", addr1);

        // Create an independent copy using copy constructor
        Person copy = new Person(original);

        // Modify copy's data
        copy.setName("Bob");
        copy.getAddress().setCity("Edison");

        System.out.println("Original: " + original);
        System.out.println("Copy:     " + copy);
    }
}
```

---

### üß† Output:

Original: Person{name='Alice', address=Princeton, NJ}
Copy:     Person{name='Bob', address=Edison, NJ}

---

### ‚úÖ Why This Is a Great Example:

* The **copy constructor of `Person`** calls the **copy constructor of `Address`** ‚Äî making it a **deep copy**.
* Modifying the city in the copy‚Äôs address doesn‚Äôt affect the original.
* You can clearly see how copy constructors create **independent objects**, not shared references.

_____________________________________________________________________________________

-> Perfect üëå ‚Äî here‚Äôs the **shallow copy version** of the same `Person` example.
You‚Äôll see exactly how skipping a deep copy causes the **two objects to share the same inner `Address`**, so changing one affects the other.

---


// Demonstrating Shallow Copy ‚Äî inner object is shared

public class Address {
    private String city;
    private final String state;

    public Address(String city, String state) {
        this.city = city;
        this.state = state;
    }

    public void setCity(String city) {
        this.city = city;
    }

    @Override
    public String toString() {
        return city + ", " + state;
    }
}

public class Person {
    private String name;
    private final Address address;

    public Person(String name, Address address) {
        this.name = name;
        this.address = address;
    }

    // ‚ùå Shallow copy constructor (does NOT create new Address)
    public Person(Person other) {
        this.name = other.name;
        this.address = other.address; // same reference
    }

    public void setName(String name) {
        this.name = name;
    }

    public Address getAddress() {
        return address;
    }

    @Override
    public String toString() {
        return "Person{name='" + name + "', address=" + address + "}";
    }
}

public class Main {
    public static void main(String[] args) {
        Address addr1 = new Address("Princeton", "NJ");
        Person original = new Person("Alice", addr1);

        // Create shallow copy (shares Address)
        Person copy = new Person(original);

        // Modify copy‚Äôs data
        copy.setName("Bob");
        copy.getAddress().setCity("Edison"); // changes the shared Address

        System.out.println("Original: " + original);
        System.out.println("Copy:     " + copy);
    }
}


---

### üß† Output:

Original: Person{name='Alice', address=Edison, NJ}
Copy:     Person{name='Bob', address=Edison, NJ}



### ‚ö†Ô∏è What Happened:

* Both `Person` objects **share the same `Address` instance** because of the shallow copy.
* Changing the city in one automatically changes it in the other.
* That‚Äôs why we need a **deep copy constructor** (`this.address = new Address(other.address)`) if we want them independent.

_____________________________________________________________________________________

==> boolean vs Boolean

## 1. `boolean flag = false;` (Primitive Type)

```java
boolean flag = false;
```

- **Primitive type** - one of Java's 8 primitive data types
- **Memory efficient** - stores directly in stack memory
- **Default value** - `false` (if it's an instance/class variable)
- **Cannot be null** - always has a value (true or false)
- **No methods** - it's just a value, not an object
- **Faster** - no object overhead

## 2. `Boolean flag = false;` (Wrapper Class)

```java
Boolean flag = false;
```

- **Object/Reference type** - wrapper class for boolean
- **Stored in heap** - reference stored in stack, object in heap
- **Default value** - `null` (if not initialized). The reference is not pointing to any object ‚Üí so default is null.
- **Can be null** - useful when you need to represent "unknown" or "not set"
- **Has methods** - `booleanValue()`, `compareTo()`, `toString()`, etc.
- **Auto-boxing** - `false` is automatically converted to `Boolean.FALSE`
- **Slower** - has object creation overhead


## When to Use Each

**Use `boolean` (primitive) when:**
- You need a simple true/false flag
- Performance matters
- You don't need null as a value
- Working with local variables or simple conditions

**Use `Boolean` (wrapper) when:**
- You need null to represent "not set" or "unknown" state
- Working with generics (e.g., `List<Boolean>`)
- Need to use Collections that require objects
- Using with databases where fields can be NULL
- Need utility methods from the Boolean class

## Example:

```java
boolean isActive = true;           // Always true or false
Boolean isVerified = null;         // Can be true, false, or null

// Collections require wrapper types
List<Boolean> flags = new ArrayList<>();  // Must use Boolean, not boolean
```

In most cases, prefer the primitive `boolean` for better performance unless you specifically need the features of the `Boolean` wrapper class.
----------------------------------------------------------------

==> Default values apply only to **fields** (instance or static).

### Local variables have *no* default value:

This gives a **compile-time error**:

```java
void test() {
    boolean x;  // MUST be initialized
    System.out.println(x); // ‚ùå compile error
}
```


Here is the **simplest possible explanation** with a **clear example** showing the difference between:

‚úîÔ∏è **fields** ‚Üí get default values
‚úîÔ∏è **local variables** ‚Üí MUST be initialized

---

# ‚úÖ **Example 1 ‚Äî Fields (instance variables) get default values**

```java
public class Demo {
    boolean a;      // default = false
    Boolean b;      // default = null

    void show() {
        System.out.println(a);  // prints false
        System.out.println(b);  // prints null
    }
}

public class Test {
    public static void main(String[] args) {
        new Demo().show();
    }
}
```

### ‚úîÔ∏è Output:

```
false
null
```

üëâ Why?
Because `a` and `b` are **fields**, and **fields always get default values**.

---

# ‚ùå **Example 2 ‚Äî Local variables do NOT get default values**

```java
public class Test {
    public static void main(String[] args) {
        boolean x;  // local variable

        System.out.println(x);  // ‚ùå compile-time error
    }
}
```

### ‚ùå Compile-time error:

```
variable x might not have been initialized
```

üëâ Why?
Because **local variables MUST be explicitly assigned** before use.
The JVM does **not** give them default values.

---

# üîç Quick Summary

| Variable Type               | Location | Default Value? | Example                      |
| --------------------------- | -------- | -------------- | ---------------------------- |
| **Field (instance/static)** | Heap     | ‚úîÔ∏è Yes         | `boolean a;` ‚Üí false         |
| **Local variable**          | Stack    | ‚ùå No           | `boolean x;` ‚Üí compile error |			

----------------------------------------------------------------
==> Use Boolean when the value may be UNKNOWN (null)
‚úî Example: three-state logic
if (flag == null) {
    // not set yet
}

```
public class ThreeStateLogicDemo {
    
    public static void main(String[] args) {
        // Three-state logic: true, false, or null (not set)
        Boolean userConsent = null;
        Boolean emailVerified = true;
        Boolean premiumMember = false;
        
        System.out.println("=== User Profile Status ===\n");
        
        // Example 1: Check if user has given consent
        checkConsent(userConsent);
        checkConsent(true);
        checkConsent(false);
        
        System.out.println("\n=== Email Verification ===\n");
        checkEmailVerification(emailVerified);
        checkEmailVerification(null);
        
        System.out.println("\n=== Membership Status ===\n");
        checkMembership(premiumMember);
        checkMembership(null);
    }
    
    public static void checkConsent(Boolean flag) {
        if (flag == null) {
            // not set yet
            System.out.println("User consent: Not answered yet - need to ask");
        } else if (flag) {
            System.out.println("User consent: Accepted - proceed with data collection");
        } else {
            System.out.println("User consent: Declined - do not collect data");
        }
    }
    
    public static void checkEmailVerification(Boolean flag) {
        if (flag == null) {
            System.out.println("Email verification: Unknown - verification email not sent");
        } else if (flag) {
            System.out.println("Email verification: Verified - full access granted");
        } else {
            System.out.println("Email verification: Not verified - limited access");
        }
    }
    
    public static void checkMembership(Boolean flag) {
        if (flag == null) {
            System.out.println("Membership: Status unknown - check payment records");
        } else if (flag) {
            System.out.println("Membership: Premium member - all features unlocked");
        } else {
            System.out.println("Membership: Free tier - basic features only");
        }
    }
}
```


```
Output:
=== User Profile Status ===

User consent: Not answered yet - need to ask
User consent: Accepted - proceed with data collection
User consent: Declined - do not collect data

=== Email Verification ===

Email verification: Verified - full access granted
Email verification: Unknown - verification email not sent

=== Membership Status ===

Membership: Free tier - basic features only
Membership: Status unknown - check payment records
```
----------------------------------------------------------------
==> Boolean handles values from databases or APIs that may return null:

```
/**
 * @param emailVerified Boolean (not boolean) to allow null
 */
// Simple User class to simulate database entity
public record User(int id, String email, Boolean emailVerified) {
}
```

```
public class BooleanDatabaseAPIDemo {
    
    public static void main(String[] args) {
        System.out.println("=== Simulating Database/API Responses ===\n");
        
        // Simulate different user scenarios
        User user1 = new User(1, "john@example.com", true);
        User user2 = new User(2, "jane@example.com", false);
        User user3 = new User(3, "bob@example.com", null); // DB field is NULL
        
        processUser(user1);
        processUser(user2);
        processUser(user3);
        
        System.out.println("\n=== API Response Scenarios ===\n");
        
        // Simulate API responses
        handleAPIResponse(true);
        handleAPIResponse(false);
        handleAPIResponse(null); // API didn't return this field
    }
    
    public static void processUser(User user) {
        System.out.println("Processing User ID: " + user.id());
        System.out.println("Email: " + user.email());
        
        // Value from database or API - may return null
        Boolean emailVerified = user.emailVerified(); // may return null
        
        if (emailVerified == null) {
            // Database field is NULL or API didn't return this field
            System.out.println("Status: Email verification status unknown");
            System.out.println("Action: Send verification email\n");
        } else if (emailVerified) {
            System.out.println("Status: Email verified ‚úì");
            System.out.println("Action: Grant full access\n");
        } else {
            System.out.println("Status: Email not verified ‚úó");
            System.out.println("Action: Resend verification link\n");
        }
    }
    
    public static void handleAPIResponse(Boolean isActive) {
        System.out.println("API Response - Account Active Status:");
        
        if (isActive == null) {
            System.out.println("  Result: Field not included in response");
            System.out.println("  Action: Use default behavior or fetch from another source\n");
        } else if (isActive) {
            System.out.println("  Result: Account is active");
            System.out.println("  Action: Allow login\n");
        } else {
            System.out.println("  Result: Account is suspended");
            System.out.println("  Action: Block login and show message\n");
        }
    }
}
```

```
Output:
=== Simulating Database/API Responses ===

Processing User ID: 1
Email: john@example.com
Status: Email verified ‚úì
Action: Grant full access

Processing User ID: 2
Email: jane@example.com
Status: Email not verified ‚úó
Action: Resend verification link

Processing User ID: 3
Email: bob@example.com
Status: Email verification status unknown
Action: Send verification email


=== API Response Scenarios ===

API Response - Account Active Status:
  Result: Account is active
  Action: Allow login

API Response - Account Active Status:
  Result: Account is suspended
  Action: Block login and show message

API Response - Account Active Status:
  Result: Field not included in response
  Action: Use default behavior or fetch from another source
```
----------------------------------------------------------------

==> Below example explains why you need Boolean (wrapper) instead of boolean (primitive) when working with Streams:

```
/**
 * @param newsletterSubscribed Boolean to allow null
 */
record UserPreference(String name, Boolean newsletterSubscribed) {
}
```

```
import java.util.*;
import java.util.stream.*;

public class BooleanStreamsDemo {
    
    public static void main(String[] args) {
        System.out.println("=== Why Boolean (Wrapper) is Needed for Streams ===\n");
        
        // Example 1: List of Boolean values (works!)
        List<Boolean> flags = Arrays.asList(true, false, true, true, false, null, true);

        // List.of does not allow null elements. So this will throw NullPointerException at runtime.
        // List<Boolean> flags = List.of(true, false, true, true, false, null, true);
        
        System.out.println("Original list: " + flags);
        
        // Count how many are TRUE
        // `.filter(flag -> flag.equals(Boolean.TRUE))` will result in NullPointerException, so use `.filter(flag -> Boolean.TRUE.equals(flag))`
        long trueCount = flags.stream()
                              .filter(Boolean.TRUE::equals)     // .filter(flag -> Boolean.TRUE.equals(flag))
                              .count();
        
        System.out.println("Count of TRUE values: " + trueCount);
        
        // Count how many are FALSE
        long falseCount = flags.stream()
                               .filter(Boolean.FALSE::equals)
                               .count();
        
        System.out.println("Count of FALSE values: " + falseCount);
        
        // Count null values
        long nullCount = flags.stream()
                              .filter(Objects::isNull)
                              .count();
        
        System.out.println("Count of NULL values: " + nullCount);

        // Count null values, Option 1: direct null check
        long nullCount1 = flags.stream()
                .filter(x -> x == null)
                .count();

        // Count null values, Option 2: call Objects.isNull via lambda
        long nullCount2 = flags.stream()
                .filter(x -> Objects.isNull(x))
                .count();
        
        System.out.println("\n=== Complex Stream Operations ===\n");
        
        // Example 2: User preferences
        List<UserPreference> preferences = Arrays.asList(
            new UserPreference("John", true),
            new UserPreference("Jane", false),
            new UserPreference("Bob", null),
            new UserPreference("Alice", true),
            new UserPreference("Charlie", null)
        );
        
        // Filter users who explicitly opted in
        List<String> optedInUsers = preferences.stream()
            .filter(pref -> Boolean.TRUE.equals(pref.newsletterSubscribed()))
            .map(UserPreference::name)
            .collect(Collectors.toList());
        
        System.out.println("Users opted IN: " + optedInUsers);
        
        // Filter users who explicitly opted out
        List<String> optedOutUsers = preferences.stream()
            .filter(pref -> Boolean.FALSE.equals(pref.newsletterSubscribed()))
            .map(UserPreference::name)
            .collect(Collectors.toList());
        
        System.out.println("Users opted OUT: " + optedOutUsers);
        
        // Filter users who haven't decided yet (null)
        List<String> undecidedUsers = preferences.stream()
            // we use == null to check for null values and can't use .equals because it would throw a NullPointerException
            .filter(pref -> pref.newsletterSubscribed() == null)
            .map(UserPreference::name)
            .collect(Collectors.toList());
        
        System.out.println("Users not decided: " + undecidedUsers);
        
        System.out.println("\n=== Why Primitive boolean Doesn't Work ===\n");
        
        // This WILL NOT COMPILE:
        // List<boolean> primitiveFlags = new ArrayList<>(); // ERROR!
        // Generics require Object types, not primitives
        
        System.out.println("‚ùå Cannot create: List<boolean>");
        System.out.println("‚úì Must use: List<Boolean>");
        System.out.println("\nReason: Java generics only work with reference types (Objects),");
        System.out.println("not primitive types like boolean, int, char, etc.");
        
        System.out.println("\n=== Specialized Primitive Streams (Alternative) ===\n");
        
        // For primitive boolean values, you'd need to use IntStream or custom approach
        boolean[] primitiveArray = {true, false, true, true, false};
        
        // Workaround: convert to int (1 for true, 0 for false)
        long trueCountPrimitive = IntStream.range(0, primitiveArray.length)
            .filter(i -> primitiveArray[i])
            .count();
        
        System.out.println("Primitive boolean array: " + Arrays.toString(primitiveArray));
        System.out.println("Count of true (using workaround): " + trueCountPrimitive);
        System.out.println("\nNote: This is more complex and doesn't support null values!");
        
        System.out.println("\n=== Real-World Example: Feature Flags ===\n");
        
        Map<String, Boolean> featureFlags = new HashMap<>();
        featureFlags.put("darkMode", true);
        featureFlags.put("betaFeatures", false);
        featureFlags.put("aiAssistant", null); // Not configured yet
        featureFlags.put("notifications", true);
        
        // Get all enabled features
        List<String> enabledFeatures = featureFlags.entrySet().stream()
            .filter(entry -> Boolean.TRUE.equals(entry.getValue()))
            .map(Map.Entry::getKey)
            .collect(Collectors.toList());
        
        System.out.println("Enabled features: " + enabledFeatures);
        
        // Get features that need configuration
        List<String> unconfiguredFeatures = featureFlags.entrySet().stream()
            //here i check for == null and not .equals because equals would throw NullPointerException
            .filter(entry -> entry.getValue() == null)
            .map(Map.Entry::getKey)
            .collect(Collectors.toList());
        
        System.out.println("Features needing configuration: " + unconfiguredFeatures);
    }
}
```

```
Output:
=== Why Boolean (Wrapper) is Needed for Streams ===

Original list: [true, false, true, true, false, null, true]
Count of TRUE values: 4
Count of FALSE values: 2
Count of NULL values: 1

=== Complex Stream Operations ===

Users opted IN: [John, Alice]
Users opted OUT: [Jane]
Users not decided: [Bob, Charlie]

=== Why Primitive boolean Doesn't Work ===

‚ùå Cannot create: List<boolean>
‚úì Must use: List<Boolean>

Reason: Java generics only work with reference types (Objects),
not primitive types like boolean, int, char, etc.

=== Specialized Primitive Streams (Alternative) ===

Primitive boolean array: [true, false, true, true, false]
Count of true (using workaround): 3

Note: This is more complex and doesn't support null values!

=== Real-World Example: Feature Flags ===

Enabled features: [darkMode, notifications]
Features needing configuration: [aiAssistant]
```
----------------------------------------------------------------
==> ## Summary Table

| Use case                       | `boolean` | `Boolean` |
| ------------------------------ | --------- | --------- |
| Simple true/false              | ‚úÖ         |           |
| Cannot be null                 | ‚úÖ         |           |
| May be null/unknown            |           | ‚úÖ         |
| Stored in a Collection         |           | ‚úÖ         |
| JSON/API responses             |           | ‚úÖ         |
| Frameworks (Spring, Hibernate) |           | ‚úÖ         |
| Optional values                |           | ‚úÖ         |
| High-performance logic         | ‚úÖ         |           |
| Three-state logic              |           | ‚úÖ         |
| Default value = false OK       | ‚úÖ         |           |

	  
_____________________________________________________________________________________		

==> This shows:

* How to combine multiple boolean checks
* Safely handle nulls
* Return an object based on Boolean.TRUE.equals()

```java
public class Main {
    public static void main(String[] args) {

        System.out.println(getApprovalMessage(true, null));   // APPROVED
        System.out.println(getApprovalMessage(false, true));  // APPROVED
        System.out.println(getApprovalMessage(null, null));   // NOT APPROVED
    }

    private static String getApprovalMessage(Boolean supervisorApproved, Boolean managerApproved) {
        String result = "NOT APPROVED";

        if (Boolean.TRUE.equals(supervisorApproved) || Boolean.TRUE.equals(managerApproved)) {
            result = "APPROVED";
        }

        return result;
    }
}

```


#### MyNotes:
a) 
Above method safely handles null values through the use of Boolean.TRUE.equals() method. 

How null safety is achieved:
Using Boolean.TRUE.equals(value) instead of value.equals(Boolean.TRUE) or value == true
When you call Boolean.TRUE.equals(supervisorApproved), if supervisorApproved is null, the equals() method simply returns false instead of throwing a NullPointerException
This is because you're calling the method on the non-null constant Boolean.TRUE, not on the potentially null variable

Why this is safe:
Boolean.TRUE.equals(null) ‚Üí returns false (no exception)
Boolean.TRUE.equals(false) ‚Üí returns false
Boolean.TRUE.equals(true) ‚Üí returns true


b) 
```
public class Main {
    public static void main(String[] args) {

        System.out.println(getApprovalMessage(true, null));
        System.out.println(getApprovalMessage(false, true));
        System.out.println(getApprovalMessage(null, null));
    }

    private static String getApprovalMessage(Boolean supervisorApproved, Boolean managerApproved) {
        if(Boolean.TRUE.equals(supervisorApproved) && Boolean.TRUE.equals(managerApproved)) {
            return "Approved by both supervisor and manager.";
        } else if (Boolean.TRUE.equals(supervisorApproved)) {
            return "Approved by supervisor only.";
        } else if (Boolean.TRUE.equals(managerApproved)) {
            return "Approved by manager only.";
        } else {
            return "Not approved.";
        }
    }
}
```

c) Checks for null explicitly before evaluating the Boolean values to avoid using `Boolean.TRUE.equals()`.
```
public class Main {
    public static void main(String[] args) {

        System.out.println(getApprovalMessage(true, null));
        System.out.println(getApprovalMessage(false, true));
        System.out.println(getApprovalMessage(null, null));
    }

    // Checks for null explicitly before evaluating the Boolean values to avoid using `Boolean.TRUE.equals()`.
    private static String getApprovalMessage(Boolean supervisorApproved, Boolean managerApproved) {
        if (supervisorApproved != null && supervisorApproved && managerApproved != null && managerApproved) {
            return "Approved by both supervisor and manager.";
        } else if (supervisorApproved != null && supervisorApproved) {
            return "Approved by supervisor only.";
        } else if (managerApproved != null && managerApproved) {
            return "Approved by manager only.";
        } else {
            return "Not approved.";
        }
    }
}
```

c.1) extracted constants to avoid any typo in string literals
```
public class Main {

    public static final String APPROVED_BY_BOTH_SUPERVISOR_AND_MANAGER = "Approved by both supervisor and manager.";
    public static final String APPROVED_BY_SUPERVISOR_ONLY = "Approved by supervisor only.";
    public static final String APPROVED_BY_MANAGER_ONLY = "Approved by manager only.";
    public static final String NOT_APPROVED = "Not approved.";

    public static void main(String[] args) {

        System.out.println(getApprovalMessage(true, null));
        System.out.println(getApprovalMessage(false, true));
        System.out.println(getApprovalMessage(null, null));
    }

    // Checks for null explicitly before evaluating the Boolean values to avoid using `Boolean.TRUE.equals()`.
    private static String getApprovalMessage(Boolean supervisorApproved, Boolean managerApproved) {
        if (supervisorApproved != null && supervisorApproved && managerApproved != null && managerApproved) {
            return APPROVED_BY_BOTH_SUPERVISOR_AND_MANAGER;
        } else if (supervisorApproved != null && supervisorApproved) {
            return APPROVED_BY_SUPERVISOR_ONLY;
        } else if (managerApproved != null && managerApproved) {
            return APPROVED_BY_MANAGER_ONLY;
        } else {
            return NOT_APPROVED;
        }
    }
}
```

_____________________________________________________________________________________
-> java.util.function.Supplier<T> at a glance

What it is : A functional interface with a single method T get(); that returns a value and accepts no arguments.

import java.util.function.Supplier;
import java.util.Random;

public class SupplierDemo {
    public static void main(String[] args) {
        Random randomGenerator = new Random();

        Supplier<Integer> randomInt = () -> randomGenerator.nextInt(100); // 0‚Äë99

        System.out.println("Random #1: " + randomInt.get());
        System.out.println("Random #2: " + randomInt.get());
    }
}

Output:
Random #1: 50
Random #2: 81
------------------------------------------------------------------------------------

The Function interface takes an input and produces an output, so we can use it to pass the upper bound for the random number generation. 
Same functionality as above but using Function instead of Supplier

import java.util.Random;
import java.util.function.Function;

public class FunctionDemo {
    public static void main(String[] args) {
        Random randomGenerator = new Random();

        
        Function<Integer, Integer> randomInt = bound -> randomGenerator.nextInt(bound); // 0‚Äë99
		//Function<Integer, Integer> randomInt = randomGenerator::nextInt; // we can replace the above lambda with method reference

        System.out.println("Random #1: " + randomInt.apply(100));
        System.out.println("Random #2: " + randomInt.apply(100));
    }
}

_____________________________________________________________________________________

-> java.util.function.Supplier<T> can be used as a factory in Streams

import java.util.List;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class SupplierDemo {
    public static void main(String[] args) {
        Supplier<Stream<String>> nameStream = () -> Stream.of("Ana", "Bob", "Cleo");

        List<String> upper   = nameStream.get()
                .map(String::toUpperCase)
                .collect(Collectors.toList());

        List<String> filtered = nameStream.get()
                .filter(s -> s.length() <= 3)
                .collect(Collectors.toList());

        System.out.println(upper);     // [ANA, BOB, CLEO]
        System.out.println(filtered);  // [Ana, Bob]
    }
}

Why a Supplier<Stream>? Streams are single‚Äëuse; using a supplier lets you obtain a fresh stream each time.
Java Streams are designed to be single-use: Once you perform a terminal operation on a stream, the stream is considered consumed and cannot be used again.


Key takeaways

    Supplier produces, never consumes.

    Great for factory patterns
_____________________________________________________________________________________

-> java.util.function.Function<T, R> vs java.util.function.BiFunction<T, U, R>

    Aspect:

        Function<T, R>: Represents an operation on one input that produces a result.

        BiFunction<T, U, R>: Represents an operation on two inputs that produces a result.

    Purpose:

        Function<T, R>: Used to represent an operation on one input that results in an output.

        BiFunction<T, U, R>: Used for an operation on two inputs, producing a result.

    Method Signature:

        Function<T, R>: R apply(T t)

        BiFunction<T, U, R>: R apply(T t, U u)

    Generics:

        Function<T, R>: 2 type parameters: input, result.

        BiFunction<T, U, R>: 3 type parameters: first input, second input, result.

    Key Default Methods:

        Function<T, R>: andThen(Function) - chain unary functions.

        BiFunction<T, U, R>: andThen(Function) - post-process the result of the bi-operation.

    Typical Stream Use:

        Function<T, R>: Commonly used with map to transform elements one-by-one.

        BiFunction<T, U, R>: Rarely used inside streams (needs two separate elements), but common in collectors, Map.compute, reduce, etc.

    Analogy:

        Function<T, R>: "Mapper"

        BiFunction<T, U, R>: "Combiner" / "Merger"
		
-----------------------------------------------------------------------------------------------------	
1) Function - transform a single value
import java.util.function.Function;

public class Main {
    public static void main(String[] args) {
        Function<String, Integer> lengthFn = s -> s.length();
		//Function<String, Integer> lengthFn = String::length;   // replace above lambda with method reference

        int len = lengthFn.apply("ChatGPT"); // ‚Üí 7
        System.out.println("Length of 'ChatGPT': " + len);

    }
}
-----------------------------------------------------------------------------------------------------
2) BiFunction ‚Äì combine two values

import java.util.function.BiFunction;

public class Main {
    public static void main(String[] args) {
        BiFunction<Integer, Integer, Integer> add = (a, b) -> a + b;

        int sum = add.apply(3, 4); // ‚Üí 7
        System.out.println("Sum: " + sum);

    }
}
_____________________________________________________________________________________

-> Implementing the Supplier<T> Interface
https://dev.java/learn/lambdas/functional-interfaces/

import java.util.function.Supplier;

public class SupplierExample {
    public static void main(String[] args) {
        // Create a Supplier that returns a String
        Supplier<String> supplier = () -> "Hello Duke!";

        // Call get() method to retrieve the value
        String message = supplier.get();

        System.out.println(message);  // Hello Duke!
    }
}
_____________________________________________________________________________________

-> Implementing the Supplier<T> Interface
https://dev.java/learn/lambdas/functional-interfaces/

import java.util.Random;
import java.util.function.Supplier;

public class RandomSupplierExample {
    public static void main(String[] args) {
        // Create a Random object seeded with 314L
        Random random = new Random(314L);

        // Create a Supplier that returns random integers between 0 and 9
        Supplier<Integer> newRandom = () -> random.nextInt(10);

        // Generate and print 5 random numbers
        for (int index = 0; index < 5; index++) {
            System.out.println(newRandom.get() + " ");
        }
    }
}

Output:
1 
5 
3 
0 
2 

Random(314L) ‚Üí You created a Random object with a fixed seed (314), meaning the random numbers will always be the same sequence every time you run the program (good for testing).
----------------------------------------------------------------------------------
-> Refactored above to avoid boxing / unboxing with the usage of IntSupplier interface

import java.util.Random;
import java.util.function.IntSupplier;

public class RandomSupplierExample {
    public static void main(String[] args) {
        // Create a Random object seeded with 314L
        Random random = new Random(314L);

        IntSupplier newRandom = () -> random.nextInt(10);

        for (int index = 0; index < 5; index++) {
            System.out.println(newRandom.getAsInt() + " ");
        }
    }
}

The result of running this code is the same, but this time no boxing / unboxing occurred: this code is more performant than the previous one.

_____________________________________________________________________________________

-> Consuming Objects with Consumer<T>
https://dev.java/learn/lambdas/functional-interfaces/

A consumer does the opposite of the supplier: it takes an argument and does not return anything.

import java.util.function.Consumer;

public class RandomSupplierExample {
    public static void main(String[] args) {

        Consumer<String> printer = s -> System.out.println(s);

        // Test the Consumer with some sample strings
        printer.accept("Hello, World!");
        printer.accept("Testing Consumer in Java.");
        printer.accept("This is a test message.");
    }
}

Output:
Hello, World!
Testing Consumer in Java.
This is a test message.

--------------
Replace lambda with method reference:
Consumer<String> printer = System.out::println;
--------------

_____________________________________________________________________________________

-> Mapping Objects to Other Objects with Function<T, R>
https://dev.java/learn/lambdas/functional-interfaces/

Represents a function that accepts one argument and produces a result.

import java.util.function.Function;

public class Main {
    public static void main(String[] args) {
        Function<String, Integer> toLength = s -> s.length();
		// Function<String, Integer> toLength = String::length;  // replace lambda with method reference
        String word = "Hello, world!";
        Integer length = toLength.apply(word);
        System.out.println("The length of the word \"" + word + "\" is: " + length);
    }
}

Output:
The length of the word "Hello, world!" is: 13

What is happening with \"?

    The backslash \ is the escape character in Java strings.
    It tells Java: "The next character should be treated specially."
    In this case, \" means: Insert a double quote " character inside the string, not end the string.

‚úÖ Otherwise, if you wrote a " without escaping, Java would get confused and think the string ends there.
_____________________________________________________________________________________
-> Testing Objects with Predicate<T>
https://dev.java/learn/lambdas/functional-interfaces/
A predicate is used to test an object. It is used for filtering streams in the Stream API.
It takes an object and returns a boolean value.

import java.util.function.Predicate;

public class Main {
    public static void main(String[] args) {
        Predicate<String> length3 = s -> s.length() == 3;
        String word = "cat";
        boolean isOfLength3 = length3.test(word);
        System.out.println("Is of length 3? " + isOfLength3);  // Is of length 3? true
    }
}
_____________________________________________________________________________________
->
import java.util.Arrays;
import java.util.List;
import java.util.function.Predicate;

public class PredicateExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        // Using a lambda expression to create a predicate
        Predicate<Integer> isEven = number -> number % 2 == 0;

        // Filtering the list using the stream API and the predicate
        List<Integer> evenNumbers = numbers.stream()
                .filter(isEven)
                .toList();

        System.out.println("Even numbers: " + evenNumbers); // Output: Even numbers: [2, 4, 6, 8, 10]
    }
}

Output:
Even numbers: [2, 4, 6, 8, 10]
-----------------------------------------------------------------------------------

-> The above implementation is concise and adheres to functional programming principles. Explicitly calling test would add unnecessary verbosity without any functional benefit.
Below code explicitly calls the test method to check if each number is even.

import java.util.Arrays;
import java.util.List;
import java.util.function.Predicate;

public class PredicateExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        // Using a lambda expression to create a predicate
        Predicate<Integer> isEven = number -> number % 2 == 0;

        // Explicitly using the test method of the Predicate
        for (Integer number : numbers) {
            if (isEven.test(number)) {
                System.out.println(number + " is even");
            } else {
                System.out.println(number + " is odd");
            }
        }

    }
}

Output:
1 is odd
2 is even
3 is odd
4 is even
5 is odd
6 is even
7 is odd
8 is even
9 is odd
10 is even

_____________________________________________________________________________________

-> when you want to apply a function to each element of a collection and transform it (like how filter works with Predicate), the **map** operation in a stream uses a Function. 

Here‚Äôs a breakdown of how Function is used in the map operation:

import java.util.Arrays;
import java.util.List;
import java.util.function.Function;
import java.util.stream.Collectors;

public class FunctionMapExample {
    public static void main(String[] args) {
        // Example collection of integers
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

        // Define a Function to square each number
        Function<Integer, Integer> squareFunction = x -> x * x;

        // Use map to apply the function to each element
        List<Integer> squaredNumbers = numbers.stream()
                                                .map(squareFunction)
                                                .collect(Collectors.toList());

        // Print the squared numbers
        squaredNumbers.forEach(System.out::println);
    }
}

Output:
1
4
9
16
25
_____________________________________________________________________________________


-> Testing Two Elements with a BiPredicate
https://dev.java/learn/lambdas/functional-interfaces/

import java.util.function.BiPredicate;

public class Main {
    public static void main(String[] args) {
        BiPredicate<String, Integer> isOfLength = (word, length) -> word.length() == length;
        String word = "cat";
        int length = 3;
        boolean isWordOfLength3 = isOfLength.test(word, length);
        System.out.println("Is the word '" + word + "' of length " + length + "? " + isWordOfLength3);   // Is the word 'cat' of length 3? true
    }
}
_____________________________________________________________________________________
-> Passing a Predicate to a Collection
https://dev.java/learn/lambdas/functional-interfaces/

import java.util.ArrayList;
import java.util.List;
import java.util.function.Predicate;

public class Main {
    public static void main(String[] args) {
        List<String> immutableStrings =
                List.of("one", "two", "three", "four", "five");
        List<String> strings = new ArrayList<>(immutableStrings);
        Predicate<String> isEvenLength = s -> s.length() % 2 == 0;
        strings.removeIf(isEvenLength);
        System.out.println("strings = " + strings);

    }
}

Output:
strings = [one, two, three]
_____________________________________________________________________________________

-> 
public class Main {

    public static void main(String[] args) {
        int[] numbers = {1, 2, 3, 4, 5};
        int sum = 0;
        for (int number : numbers) {
            sum += number;
        }

        System.out.println("The sum of the array is: " + sum);


        // above code in functional style
        // same as java.util.Arrays.stream(numbers).sum() , https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/stream/IntStream.html#sum()
        int functionalSum = java.util.Arrays.stream(numbers)
                .reduce(0, Integer::sum);       
        System.out.println("The sum of the array using functional style is: " + functionalSum);
    }
}

Output:
The sum of the array is: 15
The sum of the array using functional style is: 15

#### MyNotes:
a) 
int functionalSum = IntStream.of(numbers)
                .reduce(0, Integer::sum);
_____________________________________________________________________________________

-> 
import java.util.Arrays;
import java.util.List;

public class Main {

    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(2, 3, 4, 5, 6);

        // 1. Reduce with identity and accumulator
        int sum = numbers.stream()
                .reduce(0, (a, b) -> a + b); // or Integer::sum
				
		// replace above lambda with method reference
		// int sum = numbers.stream().reduce(0, Integer::sum);
		
		//        Reduce starts with identity = 0 and applies `Integer::sum` to each element in order.
//
//        1. Start: acc = 0
//        2. acc = Integer.sum(0, 2) => 2
//        3. acc = Integer.sum(2, 3) => 5
//        4. acc = Integer.sum(5, 4) => 9
//        5. acc = Integer.sum(9, 5) => 14
//        6. acc = Integer.sum(14, 6) => 20

        System.out.println("Sum using reduce: " + sum);

        // 2. Reduce to find the product
        int product = numbers.stream()
                .reduce(1, (a, b) -> a * b);
        System.out.println("Product using reduce: " + product);

        // 3. Reduce to find the maximum
        int max = numbers.stream()
                .reduce(Integer.MIN_VALUE, Integer::max);
        System.out.println("Max using reduce: " + max);
// Iterations for reduce with identity = Integer.MIN_VALUE and accumulator = Integer::max
// 1. Start: acc = Integer.MIN_VALUE
// 2. acc = Integer.max(Integer.MIN_VALUE, 2) => 2
// 3. acc = Integer.max(2, 3) => 3
// 4. acc = Integer.max(3, 4) => 4
// 5. acc = Integer.max(4, 5) => 5
// 6. acc = Integer.max(5, 6) => 6
// Final result returned by reduce: 6


        // 4. Reduce without identity - returns Optional
        numbers.stream()
                .reduce((a, b) -> a + b)
                .ifPresent(result -> System.out.println("Sum (no identity): " + result));
				
		 // replace above lambda with method reference
//        numbers.stream()
//                .reduce(Integer::sum)
//                .ifPresent(result -> System.out.println("Sum (no identity): " + result));
    }
}

Output:
Sum using reduce: 20
Product using reduce: 720
Max using reduce: 6
Sum (no identity): 20


| Use Case    | Code                                      | Output                      |
| ----------- | ----------------------------------------- | --------------------------- |
| Sum         | `reduce(0, (a, b) -> a + b)`              | Adds all numbers            |
| Product     | `reduce(1, (a, b) -> a * b)`              | Multiplies all numbers      |
| Max         | `reduce(Integer.MIN_VALUE, Integer::max)` | Finds maximum value         |
| No identity | `reduce((a, b) -> a + b)`                 | Returns `Optional<Integer>` |

_____________________________________________________________________________________

-> Use Stream.reduce() with custom objects ‚Äî specifically, summing up prices in a list of Product objects.

public record Product(String name, double price) {
    public double getPrice() {
        return price;
    }
}


import java.util.Arrays;
import java.util.List;

public class ProductReduceExample {
    public static void main(String[] args) {
        List<Product> products = Arrays.asList(
                new Product("Book", 15.99),
                new Product("Pen", 1.49),
                new Product("Notebook", 6.25)
        );

        // 1. Use reduce with an identity and accumulator
        Double totalPrice = products.stream()
                .map(Product::getPrice)
                .reduce(0.0, (total, price) -> total + price);  // .reduce(0.0, Double::sum);  // can replace with Double::sum instead of lambda here

        System.out.println("Total Price: $" + totalPrice);

        // 2. Use reduce without an identity ( returns Optional<Double> )
        products.stream()
                .map(Product::getPrice)
                .reduce(Double::sum)
                .ifPresent(sum -> System.out.println("Total (optional): $" + sum));
    }
}

Output:
Total Price: $23.73
Total (optional): $23.73

#### MyNotes:
a) .reduce(0.0, (total, price) -> total + price)

Here are the iterations for the `reduce` call:

**Initial state:**
- `total = 0.0` (identity value)

**Iteration 1:**
- `price = 15.99` (Book)
- `total = 0.0 + 15.99 = 15.99`

**Iteration 2:**
- `price = 1.49` (Pen)
- `total = 15.99 + 1.49 = 17.48`

**Iteration 3:**
- `price = 6.25` (Notebook)
- `total = 17.48 + 6.25 = 23.73`

**Final result:** `23.73`

The `reduce` operation takes the identity value (`0.0`) as the initial accumulator, then processes each element by applying the lambda `(total, price) -> total + price`, carrying forward the accumulated result to the next iteration.


b) remove the getPrice() from Product record and in ProductReduceExample.java update `.map(Product::price)`

public record Product(String name, double price) {
}

_____________________________________________________________________________________

-> Find Most Expensive Product with reduce()


public class Product {
    private final String name;
    private final double price;

    public Product(String name, double price) {
        this.name = name;
        this.price = price;
    }

    public double getPrice() {
        return price;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return name + " ($" + price + ")";
    }
}


import java.util.Arrays;
import java.util.List;

public class MaxProductReduceExample {
    public static void main(String[] args) {
        List<Product> products = Arrays.asList(
            new Product("Book", 15.99),
            new Product("Pen", 1.49),
            new Product("Notebook", 6.25),
            new Product("Headphones", 29.99)
        );

        // Use reduce to find the product with the highest price
        products.stream()
            .reduce((p1, p2) -> p1.getPrice() > p2.getPrice() ? p1 : p2)
            .ifPresent(maxProduct -> System.out.println("Most expensive product: " + maxProduct));
    }
}

Output:
Most expensive product: Headphones ($29.99)


The `reduce` method is a terminal operation that processes elements of a stream and combines them into a single result.

The lambda expression `(p1, p2) -> p1.getPrice() > p2.getPrice() ? p1 : p2` compares two `Product` objects (`p1` and `p2`) based on their `price` property. If the price of `p1` is greater than the price of `p2`, `p1` is returned; otherwise, `p2` is returned. This ensures that the stream iterates through all products and keeps the one with the highest price.

For example, if the stream contains products with prices `15.99`, `1.49`, `6.25`, and `29.99`, the `reduce` operation will compare each pair of products and ultimately return the product with the price `29.99`.

The result of the `reduce` operation is wrapped in an `Optional`, as the stream might be empty, in which case no product can be returned. The `ifPresent` method is then used to print the most expensive product if it exists.
_____________________________________________________________________________________

==>  Function vs BiFunction

Both are **functional interfaces** from `java.util.function` package used for transforming data.

---

## 1. Function<T, R>

Takes **one argument** and returns a result.

**Signature:**
```java
@FunctionalInterface
public interface Function<T, R> {
    R apply(T t);
}
```

- `T` = input type
- `R` = return type

### Examples

```java
import java.util.function.Function;

// Example 1: String length
Function<String, Integer> getLength = str -> str.length();
System.out.println(getLength.apply("Hello")); // Output: 5

// Example 2: Square a number
Function<Integer, Integer> square = n -> n * n;
System.out.println(square.apply(5)); // Output: 25

// Example 3: Convert to uppercase
Function<String, String> toUpper = str -> str.toUpperCase();
System.out.println(toUpper.apply("java")); // Output: JAVA
```

### With Streams
```java
List<String> names = Arrays.asList("alice", "bob", "charlie");

List<Integer> lengths = names.stream()
    .map(name -> name.length())  // Function<String, Integer>
    .collect(Collectors.toList());

System.out.println(lengths); // Output: [5, 3, 7]
```

---

## 2. BiFunction<T, U, R>

Takes **two arguments** and returns a result.

**Signature:**
```java
@FunctionalInterface
public interface BiFunction<T, U, R> {
    R apply(T t, U u);
}
```

- `T` = first input type
- `U` = second input type
- `R` = return type

### Examples

```java
import java.util.function.BiFunction;

// Example 1: Add two numbers
BiFunction<Integer, Integer, Integer> add = (a, b) -> a + b;
System.out.println(add.apply(10, 20)); // Output: 30

// Example 2: Concatenate strings
BiFunction<String, String, String> concat = (s1, s2) -> s1 + " " + s2;
System.out.println(concat.apply("Hello", "World")); // Output: Hello World

// Example 3: Calculate power
BiFunction<Double, Double, Double> power = (base, exp) -> Math.pow(base, exp);
System.out.println(power.apply(2.0, 3.0)); // Output: 8.0

// Example 4: Different types
BiFunction<String, Integer, String> repeat = (str, times) -> str.repeat(times);
System.out.println(repeat.apply("Java", 3)); // Output: JavaJavaJava
```

---

## Function vs BiFunction ‚Äî Comparison Table

| Feature        | Function       | BiFunction                                  |
| -------------- | -------------- | ------------------------------------------- |
| **Parameters** | 1              | 2                                           |
| **Method**     | `apply(T t)`   | `apply(T t, U u)`                           |
| **Common Use** | Stream `map()` | Stream `reduce()`, custom binary operations |


---

## Chaining Functions

You can chain `Function` instances:

```java
Function<Integer, Integer> multiplyBy2 = n -> n * 2;
Function<Integer, Integer> add10 = n -> n + 10;

// Chain: first multiply, then add
Function<Integer, Integer> combined = multiplyBy2.andThen(add10);
System.out.println(combined.apply(5)); // (5 * 2) + 10 = 20

// Chain: first add, then multiply
Function<Integer, Integer> reversed = multiplyBy2.compose(add10);
System.out.println(reversed.apply(5)); // (5 + 10) * 2 = 30
```

---

## Practical Example: Stream Operations

```java
List<String> items = Arrays.asList("apple", "banana", "cherry");

// Function: Transform each item
items.stream()
    .map(item -> item.toUpperCase())  // Function<String, String>
    .forEach(System.out::println);
// Output: APPLE, BANANA, CHERRY

// BiFunction: Combine stream elements with reduce
String result = items.stream()
    .reduce("Fruits:", (acc, item) -> acc + " " + item);  // BiFunction
System.out.println(result);
// Output: Fruits: apple banana cherry
```

**How reduce works above:**

- **Initial value**: `"Fruits:"` - the starting accumulator value
- **BiFunction**: `(acc, item) -> acc + " " + item` - takes two parameters:
  - `acc` (accumulator) - the running result from previous iterations
  - `item` - the current element from the stream
- **Process**: Concatenates each item to the accumulator with a space separator

**Execution flow:**
1. Start: `acc = "Fruits:"`
2. First iteration: `"Fruits:" + " " + "apple"` ‚Üí `"Fruits: apple"`
3. Second iteration: `"Fruits: apple" + " " + "banana"` ‚Üí `"Fruits: apple banana"`
4. Third iteration: `"Fruits: apple banana" + " " + "cherry"` ‚Üí `"Fruits: apple banana cherry"`

The final result is `"Fruits: apple banana cherry"`.

---

## Summary

- **Function**: One input ‚Üí one output (like `map`)
- **BiFunction**: Two inputs ‚Üí one output (like custom combiners)
- Both enable functional programming patterns in Java
_____________________________________________________________________________________

==> Consumer vs BiConsumer

Both are **functional interfaces** from `java.util.function` package used for **consuming/processing data without returning anything** (void return type).

---

## 1. Consumer<T>

Takes **one argument** and returns **nothing** (void).

**Signature:**
```java
@FunctionalInterface
public interface Consumer<T> {
    void accept(T t);
}
```

- `T` = input type
- Returns: **void**

### Examples

```java
import java.util.function.Consumer;

// Example 1: Print a message
Consumer<String> print = str -> System.out.println(str);
print.accept("Hello World"); // Output: Hello World

// Example 2: Modify an object (side effect)
Consumer<List<String>> addItem = list -> list.add("New Item");
List<String> items = new ArrayList<>();
addItem.accept(items);
System.out.println(items); // Output: [New Item]

// Example 3: Update a value
Consumer<int[]> doubleValue = arr -> arr[0] = arr[0] * 2;
int[] nums = {5};
doubleValue.accept(nums);
System.out.println(nums[0]); // Output: 10
```

### With Streams (forEach)
```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

// Consumer in forEach
names.forEach(name -> System.out.println("Hello, " + name));
// Output:
// Hello, Alice
// Hello, Bob
// Hello, Charlie

// Method reference (also a Consumer)
names.forEach(System.out::println);
```

---

## 2. BiConsumer<T, U>

Takes **two arguments** and returns **nothing** (void).

**Signature:**
```java
@FunctionalInterface
public interface BiConsumer<T, U> {
    void accept(T t, U u);
}
```

- `T` = first input type
- `U` = second input type
- Returns: **void**

### Examples

```java
import java.util.function.BiConsumer;

// Example 1: Print two values
BiConsumer<String, Integer> printDetails = (name, age) -> 
    System.out.println(name + " is " + age + " years old");
printDetails.accept("Alice", 25); // Output: Alice is 25 years old

// Example 2: Add to a map
BiConsumer<Map<String, Integer>, String> addToMap = (map, key) -> 
    map.put(key, key.length());
Map<String, Integer> wordLengths = new HashMap<>();
addToMap.accept(wordLengths, "Java");
System.out.println(wordLengths); // Output: {Java=4}

// Example 3: Calculate and display
BiConsumer<Integer, Integer> showSum = (a, b) -> 
    System.out.println("Sum: " + (a + b));
showSum.accept(10, 20); // Output: Sum: 30
```

### With Map.forEach()
```java
Map<String, Integer> scores = new HashMap<>();
scores.put("Alice", 95);
scores.put("Bob", 87);
scores.put("Charlie", 92);

// BiConsumer in Map's forEach
scores.forEach((name, score) -> 
    System.out.println(name + " scored " + score));
// Output:
// Alice scored 95
// Bob scored 87
// Charlie scored 92
```

---

## Consumer vs BiConsumer

| Feature         | Consumer                  | BiConsumer                         |
| --------------- | ------------------------- | ---------------------------------- |
| **Parameters**  | 1                         | 2                                  |
| **Method**      | `accept(T t)`             | `accept(T t, U u)`                 |
| **Return Type** | void                      | void                               |
| **Common Use**  | `forEach()`, side effects | `Map.forEach()`, paired operations |


---

## Chaining Consumers

You can chain `Consumer` instances with `andThen()`:

```java
Consumer<String> printUpper = str -> System.out.println(str.toUpperCase());
Consumer<String> printLength = str -> System.out.println("Length: " + str.length());

// Chain both consumers
Consumer<String> combined = printUpper.andThen(printLength);
combined.accept("hello");
// Output:
// HELLO
// Length: 5
```

**Note:** `BiConsumer` also supports `andThen()`:

```java
BiConsumer<String, Integer> print1 = (name, age) -> 
    System.out.println(name + ": " + age);
BiConsumer<String, Integer> print2 = (name, age) -> 
    System.out.println("Next year: " + (age + 1));

BiConsumer<String, Integer> combined = print1.andThen(print2);
combined.accept("Alice", 25);
// Output:
// Alice: 25
// Next year: 26
```

---

## Practical Examples

### Example 1: Processing a List
```java
List<String> fruits = Arrays.asList("apple", "banana", "cherry");

// Consumer: Process each element
Consumer<String> processFruit = fruit -> {
    System.out.println("Processing: " + fruit);
    // Perform some operation (logging, saving, etc.)
};

fruits.forEach(processFruit);
```

### Example 2: Map Operations
```java
Map<String, Double> prices = new HashMap<>();
prices.put("Laptop", 999.99);
prices.put("Phone", 599.99);
prices.put("Tablet", 399.99);

// BiConsumer: Apply discount
BiConsumer<String, Double> applyDiscount = (item, price) -> {
    double discounted = price * 0.9; // 10% off
    System.out.println(item + ": $" + price + " -> $" + discounted);
};

prices.forEach(applyDiscount);
// Output:
// Laptop: $999.99 -> $899.991
// Phone: $599.99 -> $539.991
// Tablet: $399.99 -> $359.991
```

### Example 3: Side Effects in Streams
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> evenNumbers = new ArrayList<>();

// Consumer: Add even numbers to another list
numbers.forEach(n -> {
    if (n % 2 == 0) {
        evenNumbers.add(n);
    }
});

System.out.println(evenNumbers); // Output: [2, 4]
```

---

## Summary

- **Consumer**: One input ‚Üí **performs action** (void)
- **BiConsumer**: Two inputs ‚Üí **performs action** (void)
- Both are for **side effects** (printing, modifying objects, logging)
- **Key difference from Function/BiFunction**: No return value

## Consumer, BiConsumer, Function, BiFunction ‚Äî Comparison Table
| Interface      | Inputs | Output | Common Use                         |
| -------------- | ------ | ------ | ---------------------------------- |
| **Consumer**   | 1      | void   | `forEach()`, logging               |
| **BiConsumer** | 2      | void   | `Map.forEach()`, paired processing |
| **Function**   | 1      | value  | `map()`, transformation            |
| **BiFunction** | 2      | value  | `reduce()`, combining              |

_____________________________________________________________________________________

==>  Predicate vs BiPredicate in Java

Both are **functional interfaces** from `java.util.function` package used for **testing conditions** and returning a **boolean** result.

---

## 1. Predicate<T>

Takes **one argument** and returns a **boolean**.

**Signature:**
```java
@FunctionalInterface
public interface Predicate<T> {
    boolean test(T t);
}
```

- `T` = input type
- Returns: **boolean** (true/false)

### Examples

```java
import java.util.function.Predicate;

// Example 1: Check if number is even
Predicate<Integer> isEven = n -> n % 2 == 0;
System.out.println(isEven.test(4));  // Output: true
System.out.println(isEven.test(7));  // Output: false

// Example 2: Check string length
Predicate<String> isLongString = str -> str.length() > 5;
System.out.println(isLongString.test("Hello"));     // Output: false
System.out.println(isLongString.test("Hello World")); // Output: true

// Example 3: Check if positive
Predicate<Integer> isPositive = n -> n > 0;
System.out.println(isPositive.test(10));  // Output: true
System.out.println(isPositive.test(-5));  // Output: false
```

### With Streams (filter)
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

// Predicate in filter
List<Integer> evenNumbers = numbers.stream()
    .filter(n -> n % 2 == 0)  // Predicate<Integer>
    .collect(Collectors.toList());

System.out.println(evenNumbers);  // Output: [2, 4, 6, 8, 10]
```

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "Dave");

// Filter names starting with 'A'
List<String> filteredNames = names.stream()
    .filter(name -> name.startsWith("A"))
    .collect(Collectors.toList());

System.out.println(filteredNames);  // Output: [Alice]
```

---

## 2. BiPredicate<T, U>

Takes **two arguments** and returns a **boolean**.

**Signature:**
```java
@FunctionalInterface
public interface BiPredicate<T, U> {
    boolean test(T t, U u);
}
```

- `T` = first input type
- `U` = second input type
- Returns: **boolean** (true/false)

### Examples

```java
import java.util.function.BiPredicate;

// Example 1: Check if sum is greater than 10
BiPredicate<Integer, Integer> sumGreaterThan10 = (a, b) -> (a + b) > 10;
System.out.println(sumGreaterThan10.test(5, 6));   // Output: true
System.out.println(sumGreaterThan10.test(3, 4));   // Output: false

// Example 2: Check if string contains substring
BiPredicate<String, String> contains = (str, substr) -> str.contains(substr);
System.out.println(contains.test("Hello World", "World"));  // Output: true
System.out.println(contains.test("Hello World", "Java"));   // Output: false

// Example 3: Check if first number is divisible by second
BiPredicate<Integer, Integer> isDivisible = (a, b) -> a % b == 0;
System.out.println(isDivisible.test(10, 2));  // Output: true
System.out.println(isDivisible.test(10, 3));  // Output: false

// Example 4: Different types
BiPredicate<String, Integer> hasMinLength = (str, minLen) -> str.length() >= minLen;
System.out.println(hasMinLength.test("Java", 3));  // Output: true
System.out.println(hasMinLength.test("Hi", 5));    // Output: false
```

---

## Predicate vs BiPredicate ‚Äî Comparison Table

| Feature         | Predicate                    | BiPredicate                         |
| --------------- | ---------------------------- | ----------------------------------- |
| **Parameters**  | 1                            | 2                                   |
| **Method**      | `test(T t)`                  | `test(T t, U u)`                    |
| **Return Type** | boolean                      | boolean                             |
| **Common Use**  | `filter()`, single condition | Comparing two values, paired checks |


---

## Combining Predicates

Predicates can be combined using logical operators:

### 1. AND (`and()`)
```java
Predicate<Integer> isPositive = n -> n > 0;
Predicate<Integer> isEven = n -> n % 2 == 0;

// Combine with AND
Predicate<Integer> isPositiveAndEven = isPositive.and(isEven);
System.out.println(isPositiveAndEven.test(4));   // Output: true
System.out.println(isPositiveAndEven.test(-4));  // Output: false
System.out.println(isPositiveAndEven.test(3));   // Output: false
```

### 2. OR (`or()`)
```java
Predicate<String> startsWithA = str -> str.startsWith("A");
Predicate<String> endsWithE = str -> str.endsWith("e");

// Combine with OR
Predicate<String> startsWithA_OR_endsWithE = startsWithA.or(endsWithE);
System.out.println(startsWithA_OR_endsWithE.test("Apple"));   // Output: true
System.out.println(startsWithA_OR_endsWithE.test("Mike"));    // Output: true
System.out.println(startsWithA_OR_endsWithE.test("Bob"));     // Output: false
```

### 3. NEGATE (`negate()`)
```java
Predicate<Integer> isEven = n -> n % 2 == 0;

// Negate (NOT)
Predicate<Integer> isOdd = isEven.negate();
System.out.println(isOdd.test(5));  // Output: true
System.out.println(isOdd.test(4));  // Output: false
```

### Combined Example
```java
Predicate<Integer> isPositive = n -> n > 0;
Predicate<Integer> isEven = n -> n % 2 == 0;
Predicate<Integer> lessThan100 = n -> n < 100;

// Complex condition: positive AND even AND less than 100
Predicate<Integer> complex = isPositive.and(isEven).and(lessThan100);

System.out.println(complex.test(50));   // Output: true
System.out.println(complex.test(-2));   // Output: false
System.out.println(complex.test(150));  // Output: false
```

**Note:** `BiPredicate` also supports `and()`, `or()`, and `negate()`:

```java
BiPredicate<Integer, Integer> bothPositive = (a, b) -> a > 0 && b > 0;
BiPredicate<Integer, Integer> bothEven = (a, b) -> a % 2 == 0 && b % 2 == 0;

BiPredicate<Integer, Integer> combined = bothPositive.and(bothEven);
System.out.println(combined.test(4, 6));   // Output: true
System.out.println(combined.test(3, 6));   // Output: false
```

---

## Practical Examples

### Example 1: Filtering with Multiple Conditions
```java
List<Integer> numbers = Arrays.asList(-5, -2, 0, 3, 8, 12, 15, 20);

Predicate<Integer> isPositive = n -> n > 0;
Predicate<Integer> isEven = n -> n % 2 == 0;

List<Integer> positiveEvenNumbers = numbers.stream()
    .filter(isPositive.and(isEven))
    .collect(Collectors.toList());

System.out.println(positiveEvenNumbers);  // Output: [8, 12, 20]
```

### Example 2: Filter Map Entries
```java
Map<String, Integer> scores = new HashMap<>();
scores.put("Alice", 95);
scores.put("Bob", 62);
scores.put("Charlie", 88);
scores.put("Dave", 45);

BiPredicate<String, Integer> isPassing = (name, score) -> score >= 60;

// Filter passing students
scores.entrySet().stream()
    .filter(entry -> isPassing.test(entry.getKey(), entry.getValue()))
    .forEach(entry -> System.out.println(entry.getKey() + ": " + entry.getValue()));
// Output:
// Alice: 95
// Bob: 62
// Charlie: 88
```

### Example 3: Validation
```java
// Predicate for email validation
Predicate<String> isValidEmail = email -> 
    email != null && email.contains("@") && email.contains(".");

System.out.println(isValidEmail.test("user@example.com"));  // Output: true
System.out.println(isValidEmail.test("invalid-email"));     // Output: false

// BiPredicate for password matching
BiPredicate<String, String> passwordsMatch = (pwd1, pwd2) -> 
    pwd1 != null && pwd1.equals(pwd2);

System.out.println(passwordsMatch.test("secret123", "secret123"));  // Output: true
System.out.println(passwordsMatch.test("secret123", "Secret123"));  // Output: false
```

### Example 4: removeIf with Predicate
```java
List<String> fruits = new ArrayList<>(Arrays.asList(
    "apple", "banana", "apricot", "cherry", "avocado"
));

// Remove fruits starting with 'a'
fruits.removeIf(fruit -> fruit.startsWith("a"));
System.out.println(fruits);  // Output: [banana, cherry]
```

---

## Summary

- **Predicate**: One input ‚Üí **boolean** (test condition)
- **BiPredicate**: Two inputs ‚Üí **boolean** (test condition with two values)
- Both are for **conditional logic** (filtering, validation, testing)
- Can be combined with `and()`, `or()`, `negate()`

## Predicate, BiPredicate, Consumer, Function ‚Äî Comparison Table

| Interface       | Inputs | Output  | Common Use                                 |
| --------------- | ------ | ------- | ------------------------------------------ |
| **Predicate**   | 1      | boolean | `filter()`, `removeIf()`, single condition |
| **BiPredicate** | 2      | boolean | Comparing two values, paired validation    |
| **Consumer**    | 1      | void    | `forEach()`, side effects                  |
| **Function**    | 1      | value   | `map()`, transformation                    |

_____________________________________________________________________________________

==> In Java Streams, **Predicate is primarily used in the following methods:**

## Core Stream Methods Using Predicate

1. **`filter(Predicate<? super T> predicate)`**
   - Filters elements based on the predicate condition
   - Returns a stream consisting of elements that match the predicate

2. **`takeWhile(Predicate<? super T> predicate)`** *(Java 9+)*
   - Takes elements while the predicate is true
   - Stops at the first element that doesn't match

3. **`dropWhile(Predicate<? super T> predicate)`** *(Java 9+)*
   - Drops elements while the predicate is true
   - Returns remaining elements after the first non-match

4. **`anyMatch(Predicate<? super T> predicate)`**
   - Terminal operation that returns true if any element matches the predicate

5. **`allMatch(Predicate<? super T> predicate)`**
   - Terminal operation that returns true if all elements match the predicate

6. **`noneMatch(Predicate<? super T> predicate)`**
   - Terminal operation that returns true if no elements match the predicate

7. **`removeIf(Predicate<? super E> filter)`**
   - While not strictly a Stream method, this Collection method uses Predicate to remove elements

These are all the standard Stream API methods that directly accept a Predicate as a parameter. The match operations (`anyMatch`, `allMatch`, `noneMatch`) are terminal operations, while `filter`, `takeWhile`, and `dropWhile` are intermediate operations that return new streams.
_____________________________________________________________________________________

==> List all the¬†Core Stream Methods Using BiPredicate

In Java Streams, **there are NO core Stream methods that directly use BiPredicate**.

The Stream API methods are designed to work with single elements from the stream, so they use:
- **Predicate<T>** for testing single elements
- **Function<T, R>** for transforming single elements
- **Consumer<T>** for consuming single elements
- etc.

## Why BiPredicate Isn't Used in Stream Methods

BiPredicate requires **two arguments** to evaluate, but stream operations typically process elements one at a time. There's no built-in stream method that needs to compare two elements simultaneously in a way that would require BiPredicate.

## Where You Might Use BiPredicate with Streams

While BiPredicate isn't directly used in Stream methods, you can use it in custom scenarios:

```java
// Example: Filtering based on two related values
BiPredicate<Integer, Integer> sumGreaterThan = (a, b) -> a + b > 10;

// You'd need to create pairs or use custom logic
list.stream()
    .filter(element -> sumGreaterThan.test(element, someOtherValue))
    .collect(Collectors.toList());
```

## Related Functional Interfaces in Streams

- **BinaryOperator<T>** - Used in `reduce()` operations
- **BiFunction<T, U, R>** - Used in `collect()` and some collectors
- **BiConsumer<T, U>** - Used in `forEach()` variants and collectors

So to directly answer your question: **zero Stream methods use BiPredicate**.
_____________________________________________________________________________________

==> List all the¬†Core Stream Methods Using Consumer

In Java Streams, **Consumer is used in the following methods:**

## Core Stream Methods Using Consumer

1. **`forEach(Consumer<? super T> action)`**
   - Terminal operation that performs an action for each element
   - Order is not guaranteed for parallel streams

2. **`forEachOrdered(Consumer<? super T> action)`**
   - Terminal operation that performs an action for each element in encounter order
   - Maintains order even in parallel streams

3. **`peek(Consumer<? super T> action)`**
   - Intermediate operation that performs an action on each element as they pass through
   - Returns a stream consisting of the elements (used mainly for debugging)

## Related: Methods Using BiConsumer

While not Consumer, these methods use **BiConsumer**:

4. **`collect(Supplier<R> supplier, BiConsumer<R, ? super T> accumulator, BiConsumer<R, R> combiner)`**
   - Mutable reduction operation
   - BiConsumer is used for accumulating elements

5. **Collectors that use BiConsumer**:
   - Many Collector implementations internally use BiConsumer
   - For example, `Collectors.toMap()`, `Collectors.groupingBy()`, etc.

## Summary

The three main Stream methods that directly accept **Consumer** are:
- `forEach()` - unordered element processing
- `forEachOrdered()` - ordered element processing  
- `peek()` - side-effect observation during stream processing

These cover all the standard ways Consumer is used in the Stream API for element-by-element operations.

_____________________________________________________________________________________

==> List all the¬†Core Stream Methods Using Function

In Java Streams, **Function is used in the following methods:**

## Core Stream Methods Using Function

1. **`map(Function<? super T, ? extends R> mapper)`**
   - Transforms each element to another type/value
   - Returns a stream of the transformed elements

2. **`flatMap(Function<? super T, ? extends Stream<? extends R>> mapper)`**
   - Transforms each element to a stream and flattens the results
   - Returns a single flattened stream

3. **`mapToInt(ToIntFunction<? super T> mapper)`**
   - Maps elements to int values
   - Returns an IntStream (uses specialized ToIntFunction)

4. **`mapToLong(ToLongFunction<? super T> mapper)`**
   - Maps elements to long values
   - Returns a LongStream (uses specialized ToLongFunction)

5. **`mapToDouble(ToDoubleFunction<? super T> mapper)`**
   - Maps elements to double values
   - Returns a DoubleStream (uses specialized ToDoubleFunction)

6. **`flatMapToInt(Function<? super T, ? extends IntStream> mapper)`**
   - FlatMaps to IntStream
   - Returns a flattened IntStream

7. **`flatMapToLong(Function<? super T, ? extends LongStream> mapper)`**
   - FlatMaps to LongStream
   - Returns a flattened LongStream

8. **`flatMapToDouble(Function<? super T, ? extends DoubleStream> mapper)`**
   - FlatMaps to DoubleStream
   - Returns a flattened DoubleStream

## Methods Using Function in Collectors

9. **`Collectors.mapping(Function<? super T, ? extends U> mapper, Collector<? super U, A, R> downstream)`**
   - Adapts a Collector by applying a mapping function

10. **`Collectors.groupingBy(Function<? super T, ? extends K> classifier)`**
    - Groups elements by a classification function

11. **`Collectors.partitioningBy()` variants** - technically use Predicate, not Function

12. **`Collectors.toMap(Function<? super T, ? extends K> keyMapper, Function<? super T, ? extends U> valueMapper)`**
    - Creates a map using key and value mapping functions

13. **`Collectors.collectingAndThen(Collector<T,A,R> downstream, Function<R,RR> finisher)`**
    - Applies a finishing transformation using Function

## Related: Methods Using BiFunction

14. **`collect()` with Collector** - Collectors may internally use BiFunction
15. **`reduce(U identity, BiFunction<U, ? super T, U> accumulator, BinaryOperator<U> combiner)`**
    - Uses BiFunction for accumulation

## Summary

The most commonly used Stream methods with **Function** are:
- **`map()`** - simple transformation
- **`flatMap()`** - transformation that flattens
- **Specialized mapping methods** (`mapToInt`, `mapToLong`, `mapToDouble`, and their flatMap variants)
- **Various Collectors** that use Function for grouping, mapping, and transforming

These cover all the primary ways Function is used in the Stream API for element transformation operations.

_____________________________________________________________________________________
