->  What is computeIfAbsent?

    It's a Map method that says:

        "If the key is already there, return its value.
        If the key is missing, create a new value, put it in the map, and return it."		

âœ… You don't have to check manually whether the key exists.


computeIfAbsent is the cleanest, safest and zero-boilerplate way to build high-speed in-memory caching for almost anything in modern Java apps.
It can be combined this with Spring Boot @Service layer caching (with annotations like @Cacheable) â€” the real way Java developers cache in production-grade projects


import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Main {
    public static void main(String[] args) {
        
        // The variable courseStudents could be renamed to studentsByCourse for better clarity
        Map<String, List<String>> courseStudents = new HashMap<>();

        // Adding students to courses
        addStudent(courseStudents, "Math", "Alice");
        addStudent(courseStudents, "Science", "Bob");
        addStudent(courseStudents, "Math", "Charlie");
        addStudent(courseStudents, "History", "David");
        addStudent(courseStudents, "Science", "Eva");

        // Print the map
        for (Map.Entry<String, List<String>> entry : courseStudents.entrySet()) {
            System.out.println("Course: " + entry.getKey() + " â†’ Students: " + entry.getValue());
        }
    }

    private static void addStudent(Map<String, List<String>> map, String course, String student) {
        // Key = course name
        // Value = list of students
        map.computeIfAbsent(course, k -> new ArrayList<>())
           .add(student);
    }
}

Output:
Course: Science â†’ Students: [Bob, Eva]
Course: History â†’ Students: [David]
Course: Math â†’ Students: [Alice, Charlie]


What happened inside computeIfAbsent(course, k -> new ArrayList<>())?

    If courseStudents already had "Math" â†’ it returns the existing list.

    If "Math" wasn't there â†’ it creates a new ArrayList, puts it under "Math", and then returns it.

    Then .add(student) is safely done without a null pointer!

-------------------------------------

map.computeIfAbsent(course, k -> new ArrayList<>())
           .add(student);

//Above line of code is put in multiple statements, for my easy understanding.
List<String> students = map.computeIfAbsent(course, k -> new ArrayList<>());
students.add(student);
-------------------------------------
______________________________________________________________________________

-> Changes to above code: removed the utility function, addStudent just to show that we can do it this way too. but having utility function is ideal as it encapsulates the repeated logic
and removes the duplicate code. 

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Main {
    public static void main(String[] args) {
        
        // The variable courseStudents could be renamed to studentsByCourse for better clarity        
        Map<String, List<String>> courseStudents = new HashMap<>();

        // Adding students to courses (without using a separate method)
        courseStudents.computeIfAbsent("Math", k -> new ArrayList<>()).add("Alice");
        courseStudents.computeIfAbsent("Science", k -> new ArrayList<>()).add("Bob");
        courseStudents.computeIfAbsent("Math", k -> new ArrayList<>()).add("Charlie");
        courseStudents.computeIfAbsent("History", k -> new ArrayList<>()).add("David");
        courseStudents.computeIfAbsent("Science", k -> new ArrayList<>()).add("Eva");

        // Print the map
        for (Map.Entry<String, List<String>> entry : courseStudents.entrySet()) {
            System.out.println("Course: " + entry.getKey() + " â†’ Students: " + entry.getValue());
        }
    }
}

#### MyNotes:  
Use a lambda-based forEach loop, or simply a forEach with a lambda expression. It uses the Map.forEach method introduced in Java 8, allowing concise iteration over map entries.

courseStudents.forEach((course, students) -> {
           System.out.println("Course: " + course + ", Students: " + students);
       });
	   
Output:
	   
Course: Science, Students: [Bob, Eva]
Course: History, Students: [David]
Course: Math, Students: [Alice, Charlie]
______________________________________________________________________________

-> 
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Main {
    public static void main(String[] args) {

        Map<String, List<String>> courseStudents = new HashMap<>();

        courseStudents.computeIfAbsent("Math", k -> List.of("Alice", "Bob"));
        courseStudents.computeIfAbsent("Science", k -> List.of("Charlie", "David"));

        courseStudents.forEach((course, students) -> {
            System.out.println("Course: " + course + ", Students: " + students);

        });

    }
}

#### MyNotes:
a) what does k -> mean above ?
In the above context, `k ->`  k is the parameter and arrow of a Java lambda expression. `computeIfAbsent` expects a `Function<K, V>` (a function that receives the missing key and returns the value to insert). So `k` is simply the name chosen for that single parameter (the key), and the arrow (`->`) separates the parameter list from the lambda body.


b) instead of "k" we can make it more descriptive?
Yes â€” use a descriptive parameter name. The lambda receives the missing map key, so names like `key` or `course` make the code clearer.

```java
courseStudents.computeIfAbsent("Math", key -> List.of("Alice", "Bob"));
courseStudents.computeIfAbsent("Science", course -> List.of("Charlie", "David"));
```
______________________________________________________________________________

-> Changes to above code:
 Used a Map<String, Set<String>> instead of Map<String, List<String>>, which prevents duplicate student names per course:

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

public class Main {
    public static void main(String[] args) {
        Map<String, Set<String>> courseStudents = new HashMap<>();

        // Adding students to courses (duplicates automatically prevented)
        courseStudents.computeIfAbsent("Math", k -> new HashSet<>()).add("Alice");
        courseStudents.computeIfAbsent("Science", k -> new HashSet<>()).add("Bob");
        courseStudents.computeIfAbsent("Math", k -> new HashSet<>()).add("Charlie");
        courseStudents.computeIfAbsent("History", k -> new HashSet<>()).add("David");
        courseStudents.computeIfAbsent("Science", k -> new HashSet<>()).add("Eva");
        courseStudents.computeIfAbsent("Science", k -> new HashSet<>()).add("Eva"); // duplicate â€” ignored

        // Print the map
        for (Map.Entry<String, Set<String>> entry : courseStudents.entrySet()) {
            System.out.println("Course: " + entry.getKey() + " â†’ Students: " + entry.getValue());
        }
    }
}


 Why use Set?

    Set (like HashSet) ensures no duplicates.
    If a student is already enrolled in the course, the .add(...) call returns false and does not add it again.
______________________________________________________________________________	
-> Changes to above code:
1) TreeSet: automatically sorts student names alphabetically.
2) TreeMap : sorts the courses too, for a clean display.

	
import java.util.Map;
import java.util.TreeMap;
import java.util.Set;
import java.util.TreeSet;

public class Main {
    public static void main(String[] args) {
        Map<String, Set<String>> courseStudents = new TreeMap<>(); // TreeMap for sorted course names (optional)

        // Add students to courses (students stored in sorted order via TreeSet)
        courseStudents.computeIfAbsent("Math", k -> new TreeSet<>()).add("Alice");
        courseStudents.computeIfAbsent("Science", k -> new TreeSet<>()).add("Bob");
        courseStudents.computeIfAbsent("Math", k -> new TreeSet<>()).add("Charlie");
        courseStudents.computeIfAbsent("History", k -> new TreeSet<>()).add("David");
        courseStudents.computeIfAbsent("Science", k -> new TreeSet<>()).add("Eva");
        courseStudents.computeIfAbsent("Science", k -> new TreeSet<>()).add("Eva"); // duplicate â€” ignored

        // Print the map
        for (Map.Entry<String, Set<String>> entry : courseStudents.entrySet()) {
            System.out.println("Course: " + entry.getKey() + " â†’ Students: " + entry.getValue());
        }
    }
}


Output:
Course: History â†’ Students: [David]
Course: Math â†’ Students: [Alice, Charlie]
Course: Science â†’ Students: [Bob, Eva]

______________________________________________________________________________

-> 
import java.util.HashMap;
import java.util.Map;

public class ComputeIfAbsentExample {
    public static void main(String[] args) {
        Map<String, Integer> fruitCounts = new HashMap<>();

        // Using computeIfAbsent to count the fruit occurrences
        String[] fruits = {"apple", "banana", "apple", "orange", "banana", "apple"};
        for (String fruit : fruits) {
            fruitCounts.computeIfAbsent(fruit, k -> 0);
            fruitCounts.put(fruit, fruitCounts.get(fruit) + 1);
        }

        // Print the fruit counts
        fruitCounts.forEach((fruit, count) -> System.out.println(fruit + ": " + count));
    }
}

Output:
orange: 1
banana: 2
apple: 3

#### MyNotes:
a) **`Map` does not implement `Iterable`**.

**Why `forEach` works here:**

`Map` has its own `forEach` method (added in Java 8) that is **not** from the `Iterable` interface. It accepts a `BiConsumer<K, V>` to process each key-value pair.

**The difference:**

```java
// Map.forEach (what you're using) - takes BiConsumer
fruitCounts.forEach((fruit, count) -> 
    System.out.println(fruit + ": " + count)
);

// Iterable.forEach (NOT available on Map) - would take Consumer
// fruitCounts.forEach(entry -> ...) // âŒ This doesn't work directly
```

**To use the `Iterable` approach, you need to convert to a collection first:**

```java
// Stream the entry set (Iterable)
fruitCounts.entrySet().forEach(entry ->
    System.out.println(entry.getKey() + ": " + entry.getValue())
);
```

**Summary:**
- `Map` is **not** `Iterable`
- `Map.forEach(BiConsumer)` is a **separate method** added in Java 8 for convenience
- If you want to use the `Iterable.forEach` or stream API, use `entrySet()`, `keySet()`, or `values()`

Your current code is correct and idiomatic â€” `Map.forEach` is the cleanest way to iterate over a map's entries!
______________________________________________________________________________

-> 
import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;

public class ComputeIfAbsentExample {
    public static void main(String[] args) {

        // Using computeIfAbsent with a more complex function
        Map<Integer, String> numberStrings = new HashMap<>();
        Function<Integer, String> numberToStringFunction = n -> "Number: " + n;

        // Compute and store if absent
        String result1 = numberStrings.computeIfAbsent(5, numberToStringFunction);
        System.out.println("Result 1: " + result1); // Output: Result 1: Number: 5
        System.out.println("Map after computeIfAbsent(5): " + numberStrings);

        // Retrieve existing value
        String result2 = numberStrings.computeIfAbsent(5, numberToStringFunction);
        System.out.println("Result 2: " + result2); // Output: Result 2: Number: 5
        System.out.println("Map after computeIfAbsent(5) again: " + numberStrings);

        // Compute and store if absent for a new key
        String result3 = numberStrings.computeIfAbsent(10, numberToStringFunction);
        System.out.println("Result 3: " + result3); // Output: Result 3: Number: 10
        System.out.println("Map after computeIfAbsent(10): " + numberStrings);
    }
}

Output:
Result 1: Number: 5
Map after computeIfAbsent(5): {5=Number: 5}
Result 2: Number: 5
Map after computeIfAbsent(5) again: {5=Number: 5}
Result 3: Number: 10
Map after computeIfAbsent(10): {5=Number: 5, 10=Number: 10}


Breakdown of Your Code: 

    You create a HashMap where:
        Key = Integer (e.g., 5, 10)
        Value = String (e.g., "Number: 5")

Function<Integer, String> numberToStringFunction = n -> "Number: " + n;

    You define a Function (Java 8 Functional Interface) that converts an Integer to a String.

    For example:
        If you input 5, it returns "Number: 5".
        If you input 10, it returns "Number: 10".
		

ðŸ”¥ Step-by-Step Explanation of computeIfAbsent
âž¡ï¸ First Call:

String result1 = numberStrings.computeIfAbsent(5, numberToStringFunction);

    Map does NOT have the key 5.

    So computeIfAbsent calls the function numberToStringFunction.apply(5).

    It returns "Number: 5".

    The map now has an entry:

    {5=Number: 5}

    result1 becomes "Number: 5".


âœ… Output:

Result 1: Number: 5
Map after computeIfAbsent(5): {5=Number: 5}

âž¡ï¸ Second Call (Same Key):

String result2 = numberStrings.computeIfAbsent(5, numberToStringFunction);

    Map already has the key 5.

    So computeIfAbsent does NOT call the function.

    It just returns the existing value "Number: 5".

    No change to the map.


âœ… Output:

Result 2: Number: 5
Map after computeIfAbsent(5) again: {5=Number: 5}

âž¡ï¸ Third Call (New Key):

String result3 = numberStrings.computeIfAbsent(10, numberToStringFunction);

    Map does NOT have the key 10.

    So it calls numberToStringFunction.apply(10).

    It returns "Number: 10".

    The map now contains:

{5=Number: 5, 10=Number: 10}

result3 becomes "Number: 10".
------------------------------------------------------------------------------

-> refactored the above

    Extract repeated printing into a helper method.
    Group logically related operations.
    Use meaningful method names.
    Make the Function inline for clarity.

import java.util.HashMap;
import java.util.Map;

public class ComputeIfAbsentExample {
    public static void main(String[] args) {
        Map<Integer, String> numberStrings = new HashMap<>();

        processNumber(numberStrings, 5);
        processNumber(numberStrings, 5); // Should retrieve existing value
        processNumber(numberStrings, 10); // New value
    }

    private static void processNumber(Map<Integer, String> map, Integer key) {
        String value = map.computeIfAbsent(key, n -> "Number: " + n);
        System.out.println("Result for key " + key + ": " + value);
        System.out.println("Map after computeIfAbsent(" + key + "): " + map);
        System.out.println("---------------------------------------------");
    }
}



Output:
Result for key 5: Number: 5
Map after computeIfAbsent(5): {5=Number: 5}
---------------------------------------------
Result for key 5: Number: 5
Map after computeIfAbsent(5): {5=Number: 5}
---------------------------------------------
Result for key 10: Number: 10
Map after computeIfAbsent(10): {5=Number: 5, 10=Number: 10}
---------------------------------------------


What Changed:
    Extracted the repeating block into a method processNumber(Map, key).
    Used inline lambda n -> "Number: " + n directly inside computeIfAbsent (no need for a separate Function variable unless it's reused heavily).
    Cleaner output separation with lines (---------------------------------------------).
    More maintainable: you can now easily test with different keys!

______________________________________________________________________________

-> Simple Java Caching Example using computeIfAbsent

import java.util.HashMap;
import java.util.Map;

public class CacheExample {
    private static final Map<Integer, Integer> cache = new HashMap<>();

    public static void main(String[] args) {
        System.out.println("Square of 5: " + getSquare(5));
        System.out.println("Square of 10: " + getSquare(10));
        System.out.println("Square of 5 again (cached): " + getSquare(5));
        System.out.println("Cache contents: " + cache);
    }

    private static int getSquare(int number) {

        return cache.computeIfAbsent(number, n -> {
            // add some delay to simulate a time-consuming calculation
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println("Calculating square for: " + n); // Log only when calculating
            return n * n;
        });
    }
}

Output:
Calculating square for: 5
Square of 5: 25
Calculating square for: 10
Square of 10: 100
Square of 5 again (cached): 25
Cache contents: {5=25, 10=100}

computing square of numbers (expensive for large calculations):

Why this is powerful:
    The first time you ask for 5, it calculates 5*5 = 25 and stores it.
    The next time you ask for 5, it immediately fetches 25 from cache.
    No recomputation is needed!
	
âš¡ Fast and efficient!

Real-world scenarios where caching with computeIfAbsent is useful:
    Database queries: Cache the result of expensive queries.
    API results: Cache external API call results.
    File reads: Cache file contents after reading once.

#### MyNotes:
a) private static final Map<Integer, Integer> cache = new HashMap<>();
why is cache declared as final, we keep on adding elements to the Map right, so i think it can't be final?

final only prevents reassigning the reference, it does not make the Map itself immutable. You can still add/remove entries from a final Map; what you cannot do is assign a new Map object to that variable.

Example consequences:
- Allowed: `cache.put(1, 1);` â€” mutating the object is fine.
- Not allowed: `cache = new HashMap<>();` â€” compile error, because the variable is final.
______________________________________________________________________________

-> Advanced Example: Caching Employee Objects


public class Employee {
    private final int id;
    private final String name;
    private final String department;

    public Employee(int id, String name, String department) {
        this.id = id;
        this.name = name;
        this.department = department;
    }

    @Override
    public String toString() {
        return "Employee{id=" + id + ", name='" + name + "', department='" + department + "'}";
    }
}

public class EmployeeDatabase {
    // Simulate a slow database lookup
    public static Employee getEmployeeFromDB(int id) {
        System.out.println("Fetching Employee " + id + " from database...");
        try {
            Thread.sleep(1000); // Simulate delay (1 second)
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return new Employee(id, "Employee" + id, "Department" + id);
    }
}


import java.util.HashMap;
import java.util.Map;

public class EmployeeCacheExample {
    private static final Map<Integer, Employee> employeeCache = new HashMap<>();

    public static void main(String[] args) {
        System.out.println(getEmployee(1));
        System.out.println(getEmployee(2));
        System.out.println(getEmployee(3));
        System.out.println(getEmployee(4));
        System.out.println(getEmployee(5));
        System.out.println(getEmployee(1)); // This will be cached!
        System.out.println(getEmployee(3)); // This will be cached!
        System.out.println(getEmployee(4)); // This will be cached!

        System.out.println("\nCache Contents:");
        employeeCache.forEach((id, employee) -> System.out.println(id + " => " + employee));
    }

    private static Employee getEmployee(int id) {
	    // return employeeCache.computeIfAbsent(id, idKey -> EmployeeDatabase.getEmployeeFromDB(idKey));
        return employeeCache.computeIfAbsent(id, EmployeeDatabase::getEmployeeFromDB);
    }
}


Output:
Fetching Employee 1 from database...
Employee{id=1, name='Employee1', department='Department1'}
Fetching Employee 2 from database...
Employee{id=2, name='Employee2', department='Department2'}
Fetching Employee 3 from database...
Employee{id=3, name='Employee3', department='Department3'}
Fetching Employee 4 from database...
Employee{id=4, name='Employee4', department='Department4'}
Fetching Employee 5 from database...
Employee{id=5, name='Employee5', department='Department5'}
Employee{id=1, name='Employee1', department='Department1'}
Employee{id=3, name='Employee3', department='Department3'}
Employee{id=4, name='Employee4', department='Department4'}

Cache Contents:
1 => Employee{id=1, name='Employee1', department='Department1'}
2 => Employee{id=2, name='Employee2', department='Department2'}
3 => Employee{id=3, name='Employee3', department='Department3'}
4 => Employee{id=4, name='Employee4', department='Department4'}
5 => Employee{id=5, name='Employee5', department='Department5'}


Only first time for Employee 1, Employee 2,Employee 3,Employee 4 and Employee 5 it hits the "database" (simulated delay).

Second call for Employee 1, Employee 3 and Employee 4 is instant â€” because it's retrieved from cache!


--------------------------
refactor Employee class as a record 

public record Employee(int id, String name, String department) {
}
--------------------------

______________________________________________________________________________

-> Practical Example: Country â†’ Capital City Lookup with Caching

Imagine:

    You have a system where users frequently request the capital city of countries.
    You don't want to hit external APIs or databases every time.
    You cache the results using computeIfAbsent.
	
public class CountryService {
    // Simulate an external service or database
    public static String fetchCapitalFromServer(String country) {
        System.out.println("Fetching capital for: " + country);
        try {
            Thread.sleep(1000); // Simulate network/database delay
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        switch (country.toLowerCase()) {
            case "usa": return "Washington, D.C.";
            case "india": return "New Delhi";
            case "france": return "Paris";
            case "japan": return "Tokyo";
            default: return "Unknown Capital";
        }
    }
}

#### MyNotes:
1) When a switch case contains a return statement, the method exits immediately, so break is not needed. The return prevents any further code (including falling through to the next case) from executing. In the code above, each case returns a value, so break is unnecessary.

2) rename the class name from "CountryService" to "CountryCapitalService" or "CountryCapitalFetcher" to follow proper naming convention to improve readability.

Class Naming:
Name should be a noun or a noun phrase describing the object or concept.
Example: CountryCapitalFetcher, EmployeeDatabase

Method Naming:
Name should be a verb or verb phrase describing the action.
Example: fetchCapitalFromDatabase, getEmployee


import java.util.HashMap;
import java.util.Map;

public class CountryCapitalCacheExample {
    private static final Map<String, String> countryCapitalCache = new HashMap<>();

    public static void main(String[] args) {
        System.out.println(getCapital("India"));
        System.out.println(getCapital("USA"));
        System.out.println(getCapital("India")); // Cached call (faster)
        System.out.println(getCapital("France"));
        System.out.println(getCapital("Japan"));
        System.out.println(getCapital("USA")); // Cached call again

        System.out.println("\nCache Contents:");
        countryCapitalCache.forEach((country, capital) -> 
            System.out.println(country + " â†’ " + capital));
    }

    private static String getCapital(String country) {
        return countryCapitalCache.computeIfAbsent(country, CountryService::fetchCapitalFromServer);
    }
}

Output:
Fetching capital for: India
New Delhi
Fetching capital for: USA
Washington, D.C.
New Delhi
Fetching capital for: France
Paris
Fetching capital for: Japan
Tokyo
Washington, D.C.

Cache Contents:
USA â†’ Washington, D.C.
Japan â†’ Tokyo
France â†’ Paris
India â†’ New Delhi


Why this is super realistic

    In real backend services, you often lookup metadata (like capitals, currencies, language codes, etc.)
    Instead of hitting slow services repeatedly, you cache the results.
    First call is slow (network or database).
    Next call is instant from memory.
	
	
-------------------------
Refactor: 
Switch statement above can be replaced with enhanced 'switch' 
Replace with switch expression
		
		
1) Traditional Switch Statement (what we're used to)

switch (country.toLowerCase()) {
    case "usa":
        return "Washington, D.C.";
    case "india":
        return "New Delhi";
    case "france":
        return "Paris";
    case "japan":
        return "Tokyo";
    default:
        return "Unknown Capital";
}

    Switch decides which code block to execute.
    return is needed manually inside each case.
    break is usually needed (here return replaces it).
	Fall-through danger? Yes, easily

2) Enhanced Switch Expression (new and better,   Java 14 stable)

return switch (country.toLowerCase()) {
    case "usa" -> "Washington, D.C.";
    case "india" -> "New Delhi";
    case "france" -> "Paris";
    case "japan" -> "Tokyo";
    default -> "Unknown Capital";
};

    switch itself becomes an expression that returns a value.
    No break needed.
    No repetition of return inside each case.
    Much cleaner and safer.
	Fall-through danger? No, impossible
-------------------------
______________________________________________________________________________

-> We can also write multi-label cases in enhanced switch:


public class CountryCapitalSwitchTest {

    public static void main(String[] args) {
        // Simulate test cases
        printCapitalForCountry("USA");
        printCapitalForCountry("united states");
        printCapitalForCountry("UK");
        printCapitalForCountry("england");
        printCapitalForCountry("India");  // Not mapped, should return default
    }

    private static void printCapitalForCountry(String country) {
        String capital = getCapitalCity(country);
        System.out.println("Country: " + country + " â†’ Capital: " + capital);
    }

    private static String getCapitalCity(String country) {
        return switch (country.toLowerCase()) {
            case "usa", "united states" -> "Washington, D.C.";
            case "uk", "england" -> "London";
            default -> "Unknown Capital";
        };
    }
}

Output:
Country: USA â†’ Capital: Washington, D.C.
Country: united states â†’ Capital: Washington, D.C.
Country: UK â†’ Capital: London
Country: england â†’ Capital: London
Country: India â†’ Capital: Unknown Capital


----------------------------------------------------------------------------------
-> In the above program, If we replace switch expression with a traditional switch statement, it will be like below:

Use a variable and break statements.

**Explanation:**  
- Use a `String` variable to store the result.
- Use `switch` with `case` labels and `break`.


public class CountryCapitalSwitchTest {

    public static void main(String[] args) {
        // Simulate test cases
        printCapitalForCountry("USA");
        printCapitalForCountry("united states");
        printCapitalForCountry("UK");
        printCapitalForCountry("england");
        printCapitalForCountry("India");  // Not mapped, should return default
    }

    private static void printCapitalForCountry(String country) {
        String capital = getCapitalCity(country);
        System.out.println("Country: " + country + " â†’ Capital: " + capital);
    }

    private static String getCapitalCity(String country) {
        String capital;
        switch (country.toLowerCase()) {
            case "usa":
            case "united states":
                capital = "Washington, D.C.";
                break;
            case "uk":
            case "england":
                capital = "London";
                break;
            default:
                capital = "Unknown Capital";
                break;
        }
        return capital;

    }
}

#### MyNotes:
case "usa":
case "united states":
        capital = "Washington, D.C.";
		
You still need both case keywords. In a traditional switch statement, each value you want to match must be listed with its own case label. There is no way to combine them into a single case line like in enhanced switch expression.
______________________________________________________________________________


