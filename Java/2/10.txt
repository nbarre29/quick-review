==> A **compact constructor** is a special feature in Java **records** (introduced in Java 14) that provides a concise way to write constructors for validation and normalization of parameters.

## Regular vs Compact Constructor

In a regular Java record, you might write:

```java
public record Person(String name, int age) {
    // Regular canonical constructor
    public Person(String name, int age) {
        if (age < 0) {
            throw new IllegalArgumentException("Age cannot be negative");
        }
        this.name = name;
        this.age = age;
    }
}
```

With a **compact constructor**, you can simplify this:

```java
public record Person(String name, int age) {
    // Compact constructor - no parameter list or assignments needed
    public Person {
        if (age < 0) {
            throw new IllegalArgumentException("Age cannot be negative");
        }
        // Fields are automatically assigned after this block
    }
}
```

## Key Features

- **No parameter list**: The parameters are implicit (taken from the record header)
- **No explicit assignments**: Fields are automatically assigned after the compact constructor completes
- **Can modify parameters**: You can normalize or transform the parameters before assignment
- **Validation**: Perfect for validation logic that runs before field initialization

## Example with Normalization

```java
public record Email(String address) {
    public Email {
        // Normalize the email to lowercase
        address = address.toLowerCase().trim();
        
        // Validate
        if (!address.contains("@")) {
            throw new IllegalArgumentException("Invalid email");
        }
    }
}
```

The compact constructor makes records cleaner and more readable when you need to add validation or normalization logic without the boilerplate of explicit field assignments.


### ✨ **Compact constructor runs *before* implicit field assignment**

Meaning:

```java
public record Person(String name, int age) {
    public Person {
        name = name.trim();  // OK
        age = Math.abs(age); // OK
        // ❌ But using this.name here is not allowed (it's not assigned yet)
    }
}
```
-----------------------------------------------------------
-> What does Normalization mean above ?

### **Normalization** = Transforming data into a standard/consistent format
- Making data uniform
- Examples:
  - `name = name.trim()` - removing whitespace
  - `email = email.toLowerCase()` - converting to lowercase
  - `phone = phone.replaceAll("[^0-9]", "")` - removing non-digits
_________________________________________________________________________________________

==> does canonical mean old way ?

No, "canonical" does not simply mean "old way"; it means the accepted, authoritative, or standard way. The word's origins are related to rules and scripture, which often involve historical texts, but the focus is on their established authority, not just their age.  
Here are the key meanings and contexts in which the word is used: 

• Authoritative/Official: The primary sense of "canonical" is something that is considered genuine, accepted, and authoritative, forming a recognized "canon" or body of work. 
• Standard/Rule: It means conforming to an established rule, principle, or standard. In many fields, it refers to the basic, standard, or most efficient form of something. 

While something "canonical" is often established over time and thus may be old, the core meaning emphasizes its status as the official or standard version, not its age in itself. The term is used in modern contexts, such as computing and web development, to denote a "master" or standard representation among many possible options. 
_________________________________________________________________________________________

==> 
public record Person(String name, int age) {
    public Person {
        if (name == null) throw new NullPointerException("name");
        if (age < 0) throw new IllegalArgumentException("age must be >= 0");
    }
}


some improvements to consider in above code

1. **Use `IllegalArgumentException` consistently** - Since `name` is a parameter validation issue, use `IllegalArgumentException` instead of `NullPointerException` (more standard for validation)

2. **Check for blank strings** - `null` isn't the only invalid case; empty strings like `""` or `"   "` should also be rejected

3. **Add descriptive error messages** - Include the actual invalid value in the message to help debugging

4. **Normalize the input** - Use `name = name.trim()` to remove leading/trailing whitespace

5. **Consider upper bounds** - An age of 500 is technically non-negative but unrealistic



public record Person(String name, int age) {
    public Person {
        // Check for null and blank names
        if (name == null || name.isBlank()) {
            throw new IllegalArgumentException("Name cannot be null or blank");
        }
        
        // Normalize the name
        name = name.trim();
        
        // Validate age
        if (age < 0) {
            throw new IllegalArgumentException("Age must be non-negative, got: " + age);
        }
        
        // Optional: set reasonable upper limit
        if (age > 150) {
            throw new IllegalArgumentException("Age must be realistic, got: " + age);
        }
    }
}

public class Main {
    public static void main(String[] args) {
        // Valid person
        Person p1 = new Person("Alice", 30);
        System.out.println(p1);

        // Normalized whitespace
        Person p2 = new Person("  Bob  ", 25);
        System.out.println(p2); // Name will be trimmed

        // These will throw exceptions:
        try {
            Person p3 = new Person(null, 30);
        } catch (IllegalArgumentException e) {
            System.out.println("Error: " + e.getMessage());
        }

        try {
            Person p4 = new Person("Charlie", -5);
        } catch (IllegalArgumentException e) {
            System.out.println("Error: " + e.getMessage());
        }

        try {
            Person p5 = new Person("", 30);
        } catch (IllegalArgumentException e) {
            System.out.println("Error: " + e.getMessage());
        }
    }
}


Output:
Person[name=Alice, age=30]
Person[name=Bob, age=25]
Error: Name cannot be null or blank
Error: Age must be non-negative, got: -5
Error: Name cannot be null or blank

-----------------------------------------------------------

In Person.java in above code, use `Objects.requireNonNull` to check for null and trim the name in one step; then validate blank and age. 

```java
import java.util.Objects;

public record Person(String name, int age) {
    public Person {
        // Null-check and normalize
        name = Objects.requireNonNull(name, "Name cannot be null").trim();
        if (name.isBlank()) {
            throw new IllegalArgumentException("Name cannot be blank");
        }

        // Validate age
        if (age < 0) {
            throw new IllegalArgumentException("Age must be non-negative, got: " + age);
        }
        if (age > 150) {
            throw new IllegalArgumentException("Age must be realistic, got: " + age);
        }
    }
}
```

isEmpty vs isBlank (brief)
- `isEmpty()` returns true only when the string length is 0.
- `isBlank()` (Java 11+) returns true when the string is empty or contains only whitespace characters (spaces, tabs, newlines, etc).
- Because your code calls `trim()` first, a whitespace-only input becomes empty, so `isEmpty()` and `isBlank()` behave the same in that specific case. If you remove `trim()`, prefer `isBlank()` to reject whitespace-only names.
- `isBlank()` uses `Character.isWhitespace` semantics and requires Java 11+.
_________________________________________________________________________________________
