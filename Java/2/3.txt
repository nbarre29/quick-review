
-> 

public enum Day {
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY,
    SUNDAY;

    public boolean isWeekend() {
        return this == SATURDAY || this == SUNDAY;
    }
}




public class Main {
    public static void main(String[] args) {
        Day today = Day.FRIDAY;

        System.out.println("Today is: " + today);

        if (today.isWeekend()) {
            System.out.println("It's the weekend! ðŸŽ‰");
        } else {
            System.out.println("It's a weekday. Keep working! ðŸ’»");
        }

        // Loop through all values
        System.out.println("\nAll Days:");
        for (Day d : Day.values()) {
            System.out.println(d + (d.isWeekend() ? " (weekend)" : " (weekday)"));
			// We can use parameterized output with System.out.printf instead of the + operator for string concatenation. 
			// This improves readability and performance for complex strings.
			// System.out.printf("%s (%s)%n", day, day.isWeekend() ? "Weekend" : "Weekday");
        }
    }
}

Output:
Today is: FRIDAY
It's a weekday. Keep working! ðŸ’»

All Days:
MONDAY (weekday)
TUESDAY (weekday)
WEDNESDAY (weekday)
THURSDAY (weekday)
FRIDAY (weekday)
SATURDAY (weekend)
SUNDAY (weekend)


The values() method is automatically generated by the Java compiler for all enum types. It is not explicitly defined in the Enum or its javadoc as it is a compiler-generated method.
For any enum, the values() method returns an array of all the constants declared in the enum in the order they are defined. in above case , Day.values() returns an array containing MONDAY, TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY, and SUNDAY.
This method is specific to enum type we define and is not part of the java.lang.Enum superclass


ðŸ§  What This Shows:

    Day is an enum with 7 constants.

    It includes a method isWeekend() to demonstrate custom logic inside an enum.

    Day.values() returns all constants â€” great for iteration.
-------------------------------	

1) System.out.println(d + (d.isWeekend() ? " (weekend)" : " (weekday)"));

Behind the scenes:
The + operator causes string concatenation, which:
a) Creates multiple temporary String objects
b) Uses StringBuilder internally
c) Is less efficient if done repeatedly or in loops
d) Each line creates several temporary strings and StringBuilder objects.
			
			
2) System.out.printf("%s (%s)%n", day, day.isWeekend() ? "Weekend" : "Weekday");
Advantages:
a) Single format string with placeholders.
b) No intermediate string objects
c) Lower memory footprint
d) Clear separation of template and data
e) More readable for complex structured output
-------------------------------

System.out.printf("%s (%s)%n", day, day.isWeekend() ? "Weekend" : "Weekday");
System.out.printf("%s (%s)%n", day.name(), day.isWeekend() ? "Weekend" : "Weekday");   

day is same as day.name() which is a string and that's why we used %s
-------------------------------
----------------------------------------------------------------------------------	
	
-> enum that associates a constant (like MON) with a custom value (like "Monday"). 



public enum Day {
    MON("Monday"),
    TUE("Tuesday"),
    WED("Wednesday"),
    THU("Thursday"),
    FRI("Friday"),
    SAT("Saturday"),
    SUN("Sunday");

    private final String fullName;

    // Constructor
    Day(String fullName) {
        this.fullName = fullName;
    }

    // Getter
    public String getFullName() {
        return fullName;
    }

    public boolean isWeekend() {
        return this == SAT || this == SUN;
    }
}




public class Main {
    public static void main(String[] args) {
        Day today = Day.MON;

        System.out.println("Today is: " + today.getFullName());

        if (today.isWeekend()) {
            System.out.println("It's the weekend! ðŸŽ‰");
        } else {
            System.out.println("It's a weekday. Keep grinding! ðŸ’¼");
        }

        System.out.println("\nAll Days:");
        for (Day d : Day.values()) {
            System.out.println(d.name() + " â†’ " + d.getFullName() + (d.isWeekend() ? " (weekend)" : " (weekday)"));
        }
    }
}

Output:

Today is: Monday
It's a weekday. Keep grinding! ðŸ’¼

All Days:
MON â†’ Monday (weekday)
TUE â†’ Tuesday (weekday)
WED â†’ Wednesday (weekday)
THU â†’ Thursday (weekday)
FRI â†’ Friday (weekday)
SAT â†’ Saturday (weekend)
SUN â†’ Sunday (weekend)


ðŸ§  Highlights:

    You use MON("Monday") and associate a custom string with each enum.

    You add a constructor and a getFullName() method to access it.

    You can still use enum features like values(), name(), and comparison.
	
______________________________________________________________________________

-> Scenario: Represent a PaymentMethod enum

Each payment method:

    Has a label (e.g., "Credit Card")

    Has a fee percentage

    Implements a different way to calculate fees



public enum PaymentMethod {
    CREDIT_CARD("Credit Card", 2.5) {
        @Override
        public double calculateFee(double amount) {
            return amount * (feePercentage / 100);
        }
    },
    PAYPAL("PayPal", 3.0) {
        @Override
        public double calculateFee(double amount) {
            return (amount * feePercentage / 100) + 0.30; // Fixed transaction fee
        }
    },
    BANK_TRANSFER("Bank Transfer", 1.0) {
        @Override
        public double calculateFee(double amount) {
            return Math.max(1.0, amount * (feePercentage / 100)); // Minimum $1 fee
        }
    };

    private final String label;
    protected final double feePercentage;

    PaymentMethod(String label, double feePercentage) {
        this.label = label;
        this.feePercentage = feePercentage;
    }

    public String getLabel() {
        return label;
    }

    public abstract double calculateFee(double amount);

    public static PaymentMethod fromLabel(String label) {
        for (PaymentMethod method : values()) {
            if (method.label.equalsIgnoreCase(label)) {
                return method;
            }
        }
        throw new IllegalArgumentException("Unknown payment method: " + label);
    }
}




public class Main {
    public static void main(String[] args) {
        double amount = 100.00;

        for (PaymentMethod method : PaymentMethod.values()) {
            double fee = method.calculateFee(amount);
            System.out.printf("%s â†’ Fee for $%.2f = $%.2f%n", method.getLabel(), amount, fee);
        }

        // Use static lookup method
        String input = "paypal";
        PaymentMethod chosen = PaymentMethod.fromLabel(input);
        System.out.println("\nChosen: " + chosen.getLabel() + ", Fee: $" + chosen.calculateFee(amount));
    }
}


Output:
Credit Card â†’ Fee for $100.00 = $2.50
PayPal â†’ Fee for $100.00 = $3.30
Bank Transfer â†’ Fee for $100.00 = $1.00

Chosen: PayPal, Fee: $3.3

Key Takeaways:

    Each constant overrides the abstract calculateFee() method differently.

    You can associate custom behavior + data with each enum constant.

    fromLabel(...) is a utility method to map strings to enums â€” useful when parsing config or user input.
	
______________________________________________________________________________
-> some refactoring on PaymentMethod.java in above code:

Since the enum constants (`CREDIT_CARD`, `PAYPAL`, `BANK_TRANSFER`) are essentially subclasses of the `PaymentMethod` enum, the `protected` modifier allows them to access the `feePercentage` field directly while still restricting access from outside the `PaymentMethod` class.

If we want to make it `private`, we would need to provide a getter method for `feePercentage` and update the overridden methods to use the getter instead.

This change ensures encapsulation by making the field `private` and accessing it through a getter, getFeePercentage()



public enum PaymentMethod {
    CREDIT_CARD("Credit Card", 2.5) {
        @Override
        public double calculateFee(double amount) {
            return amount * (getFeePercentage() / 100);
        }
    },
    PAYPAL("PayPal", 3.0) {
        @Override
        public double calculateFee(double amount) {
            return (amount * getFeePercentage() / 100) + 0.30; // Fixed transaction fee
        }
    },
    BANK_TRANSFER("Bank Transfer", 1.0) {
        @Override
        public double calculateFee(double amount) {
            return Math.max(1.0, amount * (getFeePercentage() / 100)); // Minimum $1 fee
        }
    };

    private final String label;
    private final double feePercentage;

    PaymentMethod(String label, double feePercentage) {
        this.label = label;
        this.feePercentage = feePercentage;
    }

    public String getLabel() {
        return label;
    }

    public double getFeePercentage() {
        return feePercentage;
    }

    public abstract double calculateFee(double amount);

    public static PaymentMethod fromLabel(String label) {
        for (PaymentMethod method : values()) {
            if (method.label.equalsIgnoreCase(label)) {
                return method;
            }
        }
        throw new IllegalArgumentException("Unknown payment method: " + label);
    }
}
______________________________________________________________________________


