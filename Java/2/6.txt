-> https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Collectors.html#filtering(java.util.function.Predicate,java.util.stream.Collector)

demonstrate the use of Collectors.filtering() downstream of Collectors.groupingBy()


// 1. Employee Class
// Represents an employee with an ID, name, department, and salary.
public class Employee {
    private final int id;
    private final String name;
    private final Department department; // Using an enum for Department
    private final double salary;

    public Employee(int id, String name, Department department, double salary) {
        this.id = id;
        this.name = name;
        this.department = department;
        this.salary = salary;
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public Department getDepartment() {
        return department;
    }

    public double getSalary() {
        return salary;
    }

    @Override
    public String toString() {
        return "Employee{id=" + id + ", name='" + name + "', dept=" + department + ", salary=" + salary + "}";
    }

    // It's good practice to override equals() and hashCode() for objects used in Sets or as Map keys
    // For simplicity, we'll rely on default object equality for this example,
    // but in a real application, you'd implement them based on 'id'.
}


// 2. Department Enum
// Defines different departments to group employees by.
public enum Department {
    HR, ENGINEERING, SALES, MARKETING, FINANCE
}


import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

// 3. Main Class with the Stream Example
public class StreamFilteringExample {

    public static void main(String[] args) {

        // Sample data: A list of employees
        List<Employee> employees = List.of(
                new Employee(1, "Alice", Department.ENGINEERING, 3500.00),
                new Employee(2, "Bob", Department.HR, 1800.00),
                new Employee(3, "Charlie", Department.ENGINEERING, 2100.00),
                new Employee(4, "David", Department.SALES, 2500.00),
                new Employee(5, "Eve", Department.HR, 2200.00),
                new Employee(6, "Frank", Department.ENGINEERING, 1900.00),
                new Employee(7, "Grace", Department.SALES, 1500.00),
                new Employee(8, "Heidi", Department.MARKETING, 3000.00),
                new Employee(9, "Ivan", Department.FINANCE, 2000.00), // Exactly 2000, will be excluded
                new Employee(10, "Judy", Department.ENGINEERING, 4000.00)
        );

        // Goal: Group employees by department, but only include those with salary > 2000 in each group.
        Map<Department, Set<Employee>> wellPaidEmployeesByDepartment = employees.stream()
                .collect(
                        Collectors.groupingBy(
                                Employee::getDepartment, // Classifier function: groups by Department (using getter)
                                Collectors.filtering(
                                        e -> e.getSalary() > 2000, // Predicate: filters employees within each group (using getter)
                                        Collectors.toSet() // Downstream collector: collects the filtered employees into a Set
                                )
                        )
                );

        System.out.println("Well-Paid Employees by Department (Salary > 2000):");
        wellPaidEmployeesByDepartment.forEach((department, employeeSet) -> {
            System.out.println("  " + department + ":");
            if (employeeSet.isEmpty()) {
                System.out.println("    (No well-paid employees in this department)");
            } else {
                employeeSet.forEach(employee -> System.out.println("    - " + employee.getName() + " (Salary: " + employee.getSalary() + ")"));
            }
        });


    }
}


Output:
Well-Paid Employees by Department (Salary > 2000):
  SALES:
    - David (Salary: 2500.0)
  MARKETING:
    - Heidi (Salary: 3000.0)
  HR:
    - Eve (Salary: 2200.0)
  ENGINEERING:
    - Charlie (Salary: 2100.0)
    - Judy (Salary: 4000.0)
    - Alice (Salary: 3500.0)
  FINANCE:
    (No well-paid employees in this department)
	
______________________________________________________________________________________

-> Usage of Employee record in above example:

If we were to replace the Employee class with a Java record, the equals() and hashCode() methods would be automatically overridden for us.


public record Employee(int id, String name, Department department, double salary) {

    @Override
    public String toString() {
        return "Employee{id=" + id + ", name='" + name + "', dept=" + department + ", salary=" + salary + "}";
    }

}


public enum Department {
    HR, ENGINEERING, SALES, MARKETING, FINANCE
}



import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

// 3. Main Class with the Stream Example
public class StreamFilteringExample {

    public static void main(String[] args) {

        // Sample data: A list of employees
        List<Employee> employees = List.of(
                new Employee(1, "Alice", Department.ENGINEERING, 3500.00),
                new Employee(2, "Bob", Department.HR, 1800.00),
                new Employee(3, "Charlie", Department.ENGINEERING, 2100.00),
                new Employee(4, "David", Department.SALES, 2500.00),
                new Employee(5, "Eve", Department.HR, 2200.00),
                new Employee(6, "Frank", Department.ENGINEERING, 1900.00),
                new Employee(7, "Grace", Department.SALES, 1500.00),
                new Employee(8, "Heidi", Department.MARKETING, 3000.00),
                new Employee(9, "Ivan", Department.FINANCE, 2000.00), // Exactly 2000, will be excluded
                new Employee(10, "Judy", Department.ENGINEERING, 4000.00)
        );

        // Goal: Group employees by department, but only include those with salary > 2000 in each group.
        Map<Department, Set<Employee>> wellPaidEmployeesByDepartment = employees.stream()
                .collect(
                        Collectors.groupingBy(
                                Employee::department, // Classifier function: groups by Department (using getter)
                                Collectors.filtering(
                                        e -> e.salary() > 2000, // Predicate: filters employees within each group (using getter)
                                        Collectors.toSet() // Downstream collector: collects the filtered employees into a Set
                                )
                        )
                );

        System.out.println("Well-Paid Employees by Department (Salary > 2000):");
        wellPaidEmployeesByDepartment.forEach((department, employeeSet) -> {
            System.out.println("  " + department + ":");
            if (employeeSet.isEmpty()) {
                System.out.println("    (No well-paid employees in this department)");
            } else {
                employeeSet.forEach(employee -> System.out.println("    - " + employee.name() + " (Salary: " + employee.salary() + ")"));
            }
        });


    }
}


Output:
Well-Paid Employees by Department (Salary > 2000):
  FINANCE:
    (No well-paid employees in this department)
  HR:
    - Eve (Salary: 2200.0)
  SALES:
    - David (Salary: 2500.0)
  MARKETING:
    - Heidi (Salary: 3000.0)
  ENGINEERING:
    - Judy (Salary: 4000.0)
    - Alice (Salary: 3500.0)
    - Charlie (Salary: 2100.0)
	
------------------------------------
-> 
// filter employees with salary > 2000 and group them by department
        Map<Department, List<Employee>> wellPaidEmployeesByDepartment = employees.stream()
                .filter(emp -> emp.salary() > 2000) // Filter employees with salary > 2000
                .collect(Collectors.groupingBy(Employee::department));
						
						
Output:
Well-Paid Employees by Department (Salary > 2000):
  ENGINEERING:
    - Alice (Salary: 3500.0)
    - Charlie (Salary: 2100.0)
    - Judy (Salary: 4000.0)
  SALES:
    - David (Salary: 2500.0)
  MARKETING:
    - Heidi (Salary: 3000.0)
  HR:
    - Eve (Salary: 2200.0)
						

The `filter(emp -> emp.salary() > 2000)` operation is applied before the `collect(Collectors.groupingBy(...))` operation.

The only employee in the `FINANCE` department, Ivan, has a salary of exactly 2000.00, which does not satisfy the `> 2000` condition. Therefore, Ivan is filtered out from the stream.

The `groupingBy` collector then creates a map only from the employees who passed the filter. Since no employees from the `FINANCE` department are left in the stream, the resulting map does not contain an entry for the `FINANCE` department at all. Your code only prints departments that exist as keys in the final map.

------------------------------------	
-> To include all departments in the output, you should group by department first and then filter the employees within each group. You can achieve this by using a downstream collector with `Collectors.filtering`.

```java
// Group employees by department, and for each department, filter for employees with salary > 2000.
        Map<Department, List<Employee>> wellPaidEmployeesByDepartment = employees.stream()
                .collect(Collectors.groupingBy(
                        Employee::department,
                        Collectors.filtering(emp -> emp.salary() > 2000, Collectors.toList())
                ));
```		

Output:
Well-Paid Employees by Department (Salary > 2000):
  MARKETING:
    - Heidi (Salary: 3000.0)
  ENGINEERING:
    - Alice (Salary: 3500.0)
    - Charlie (Salary: 2100.0)
    - Judy (Salary: 4000.0)
  SALES:
    - David (Salary: 2500.0)
  FINANCE:
    (No well-paid employees in this department)
  HR:
    - Eve (Salary: 2200.0)	
	
------------------------------------	

______________________________________________________________________________________


