==> Convert List to Map using Collectors.toMap

---

# ‚úÖ **1. Before (classic imperative loop) ‚Äì Correct and common**

```java
Map<Integer, String> map = new HashMap<>();
for (Person p : people) {
    map.put(p.getId(), p.getName());
}
```

This works perfectly fine and is readable.
However, it is **manual and verbose** when converting collections.

---

# ‚úÖ **2. After (functional style with streams) ‚Äì Also correct and idiomatic**

```java
Map<Integer, String> map = people.stream()
    .collect(Collectors.toMap(Person::getId, Person::getName));
```

This version is:

- **Concise**
- **More expressive**
- **Uses method references**
- **Avoids boilerplate loops**

This is considered **standard modern Java** for converting lists to maps.

---

# ‚ö†Ô∏è Important Caveat

`Collectors.toMap()` **throws an exception if keys collide**:

### ‚ö†Ô∏è you should be aware of **duplicate key** handling in real applications

```java
java.lang.IllegalStateException: Duplicate key
```

Example:

If two Person objects share the same ID:

```java

public record Person(int id, String name) {
}


import java.util.*;
import java.util.stream.Collectors;

public class ToMapDuplicateKeyDemo {

    public static void main(String[] args) {

        // List with duplicate IDs
        List<Person> people = List.of(
                new Person(1, "Alice"),
                new Person(1, "Bob"),
                new Person(2, "Charlie")
        );

        System.out.println("=== Trying collectors.toMap() WITHOUT merge function ===");
        try {
            Map<Integer, String> mapFail = people.stream()
                    .collect(Collectors.toMap(Person::id, Person::name));

            System.out.println(mapFail);
        } catch (Exception ex) {
            // This will print the Duplicate Key error
            System.out.println("Exception caught: " + ex.getMessage());
        }

        System.out.println("\n=== Using a merge function: keep the FIRST value ===");

        Map<Integer, String> mapKeepFirst = people.stream()
                .collect(Collectors.toMap(
                        Person::id,
                        Person::name,
                        (existing, replacement) -> existing   // keep existing
                ));

        System.out.println(mapKeepFirst);     //  {1=Alice, 2=Charlie}

        System.out.println("\n=== Using a merge function: keep the LATEST value ===");

        Map<Integer, String> mapKeepLatest = people.stream()
                .collect(Collectors.toMap(
                        Person::id,
                        Person::name,
                        (existing, replacement) -> replacement   // keep new one
                ));

        System.out.println(mapKeepLatest);    // {1=Bob, 2=Charlie}

        System.out.println("\n=== Using merge function to COMBINE values ===");

        Map<Integer, String> mapCombined = people.stream()
                .collect(Collectors.toMap(
                        Person::id,
                        Person::name,
                        (existing, replacement) -> existing + ", " + replacement
                ));

        System.out.println(mapCombined);  // {1=Alice, Bob, 2=Charlie}

    }
}

```

# ** Output:**

```
=== Trying collectors.toMap() WITHOUT merge function ===
Exception caught: Duplicate key 1 (attempted merging values Alice and Bob)

=== Using a merge function: keep the FIRST value ===
{1=Alice, 2=Charlie}

=== Using a merge function: keep the LATEST value ===
{1=Bob, 2=Charlie}

=== Using merge function to COMBINE values ===
{1=Alice, Bob, 2=Charlie}
```

---

---

==> How to convert List ‚Üí Map using streams + BigDecimal + enums

Great ‚Äî here is a **clean, real-world, production-style example** showing:

‚úî A `List` of objects
‚úî An enum (`Department`)
‚úî A `BigDecimal` salary
‚úî Converting the list into multiple different **Map** structures using **streams**

This is the exact pattern used in payroll, accounting, HR, or reporting systems.

---

```java
public enum Department {IT, HR, FINANCE, SALES}


import java.math.BigDecimal;

public record Employee(int id, String name, Department department, BigDecimal salary) {
}


import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.*;
import java.util.stream.Collectors;

public class EmployeeMapExample {

    public static void main(String[] args) {

        List<Employee> employees = List.of(
                new Employee(1, "Alice", Department.IT, new BigDecimal("70000")),
                new Employee(2, "Bob", Department.HR, new BigDecimal("50000")),
                new Employee(3, "Charlie", Department.IT, new BigDecimal("85000")),
                new Employee(4, "David", Department.SALES, new BigDecimal("60000")),
                new Employee(5, "Eva", Department.IT, new BigDecimal("95000"))
        );

        // 1. Map<id, Employee>
        // Very common: indexing employees by ID.
        Map<Integer, Employee> mapById = employees.stream()
                .collect(Collectors.toMap(Employee::id, e -> e));

        // 2. Map<Department, BigDecimal> ‚Äì total salaries
         //  Calculate total salary cost per department
         //  Using BigDecimal::add safely for money
        Map<Department, BigDecimal> salaryByDept = employees.stream()
                .collect(Collectors.toMap(
                        Employee::department,
                        Employee::salary,
                        BigDecimal::add
                ));

        // 3. Map<Department, List<Employee>> ‚Äì group by dept
        // Group employees by their department
        Map<Department, List<Employee>> employeesByDept = employees.stream()
                .collect(Collectors.groupingBy(Employee::department));

        // 4. Map<Department, BigDecimal> ‚Äì average salary
        Map<Department, BigDecimal> avgSalaryByDept = employees.stream()
                .collect(Collectors.groupingBy(
                        Employee::department,
                        Collectors.collectingAndThen(
                                Collectors.mapping(Employee::salary, Collectors.toList()),
                                salaries -> {
                                    BigDecimal sum = salaries.stream()
                                            .reduce(BigDecimal.ZERO, BigDecimal::add);
                                    return sum.divide(
                                            new BigDecimal(salaries.size()),
                                            2,
                                            RoundingMode.HALF_UP
                                    );
                                }
                        )
                ));

        // Print results
        System.out.println("Map by ID:");
        System.out.println(mapById);
        System.out.println("\nTotal Salary by Department:");
        System.out.println(salaryByDept);
        System.out.println("\nEmployees by Department:");
        System.out.println(employeesByDept);
        System.out.println("\nAverage Salary by Department:");
        System.out.println(avgSalaryByDept);
    }
}


```

---

# ‚≠ê Output (example)

```
Map by ID:
{1=Employee[id=1, name=Alice, department=IT, salary=70000], 2=Employee[id=2, name=Bob, department=HR, salary=50000], 3=Employee[id=3, name=Charlie, department=IT, salary=85000], 4=Employee[id=4, name=David, department=SALES, salary=60000], 5=Employee[id=5, name=Eva, department=IT, salary=95000]}

Total Salary by Department:
{IT=250000, SALES=60000, HR=50000}

Employees by Department:
{IT=[Employee[id=1, name=Alice, department=IT, salary=70000], Employee[id=3, name=Charlie, department=IT, salary=85000], Employee[id=5, name=Eva, department=IT, salary=95000]], SALES=[Employee[id=4, name=David, department=SALES, salary=60000]], HR=[Employee[id=2, name=Bob, department=HR, salary=50000]]}

Average Salary by Department:
{IT=83333.33, SALES=60000.00, HR=50000.00}
```

---

---

==> Show an example Using `EnumMap` for enum keys (super fast)

Perfect ‚Äî using **EnumMap** is one of the fastest and cleanest ways to build maps keyed by an enum.

---

# ‚úÖ Full Example: Total Salary by Department Using EnumMap

```java
public enum Department {IT, HR, FINANCE, SALES}


import java.math.BigDecimal;

public record Employee(int id, String name, Department department, BigDecimal salary) {
}

import java.math.BigDecimal;
import java.util.*;
import java.util.stream.Collectors;

public class EnumMapExample {

    public static void main(String[] args) {

        List<Employee> employees = List.of(
                new Employee(1, "Alice", Department.IT, new BigDecimal("70000")),
                new Employee(2, "Bob", Department.HR, new BigDecimal("50000")),
                new Employee(3, "Charlie", Department.IT, new BigDecimal("85000")),
                new Employee(4, "David", Department.SALES, new BigDecimal("60000")),
                new Employee(5, "Eva", Department.IT, new BigDecimal("95000"))
        );

        // Use EnumMap directly instead of HashMap
        EnumMap<Department, BigDecimal> salaryByDept = employees.stream()
                .collect(Collectors.toMap(
                        Employee::department,           // key extractor
                        Employee::salary,               // value extractor
                        BigDecimal::add,                // merge function
                        () -> new EnumMap<>(Department.class) // supplier
                ));

        System.out.println("Total Salary by Department (EnumMap):");
        salaryByDept.forEach((dept, total) ->
                System.out.println(dept + " -> " + total));
    }
}

```

---

# üìù Output

```
Total Salary by Department (EnumMap):
IT -> 250000
HR -> 50000
FINANCE -> 0   (if no entries, map may omit this key)
SALES -> 60000
```

Note: FINANCE won‚Äôt appear unless you initialize it manually.
EnumMap does **not** auto-create entries.

---

# üöÄ Quick Comparisons

### ‚úî EnumMap (best choice for enum keys)

- blazing fast
- deterministic order
- fewer memory allocations

### ‚úî HashMap

- works but slower
- allows null keys (EnumMap does NOT)

# ‚ö° Bonus: Preinitialize EnumMap for all departments

If you want **every enum key present**, even with zero values:

```java
EnumMap<Department, BigDecimal> initialized = new EnumMap<>(Department.class);
for (Department d : Department.values()) {
    initialized.put(d, BigDecimal.ZERO);
}

employees.forEach(emp ->
        initialized.merge(emp.department(), emp.salary(), BigDecimal::add)
);
```

This avoids missing keys.

---

==> You are asked to generate an Ecommerce report

You must generate a report **per product category** showing:

- Each order has a list of products and each product belongs to a category
- Total quantity sold but
- Only include orders whose **total order value > ‚Çπ500**
- Excluding products marked **"OUT_OF_STOCK"** (even if was part of the order),
- Sort result by **total quantity DESC**

---

```java
import java.math.BigDecimal;

public record Product(
        String name,
        String category,
        int quantity,           // quantity purchased in this order
        BigDecimal price,       // price per unit
        StockStatus stockStatus // IN_STOCK / OUT_OF_STOCK
) {
}


import java.util.List;

public record Order(
        int id,
        List<Product> products
) {
}

public enum StockStatus {IN_STOCK, OUT_OF_STOCK}



import java.util.*;
import java.math.BigDecimal;
import java.util.stream.Collectors;

public class EcommerceReport {

    public static void main(String[] args) {

        List<Order> orders = getOrders(); // assume method returns sample data

        Map<String, Integer> report = orders.stream()

                // 1Ô∏è‚É£ Filter only orders with total value > 500
                .filter(order -> order.products().stream()
                        .map(p -> p.price().multiply(BigDecimal.valueOf(p.quantity())))
                        .reduce(BigDecimal.ZERO, BigDecimal::add)
                        .compareTo(new BigDecimal("500")) > 0
                )

                // 2Ô∏è‚É£ Extract all products from all orders
                .flatMap(order -> order.products().stream())

                // 3Ô∏è‚É£ Exclude OUT_OF_STOCK products
                .filter(p -> p.stockStatus() == StockStatus.IN_STOCK)

                // 4Ô∏è‚É£ Group by product category, summing quantities
                .collect(Collectors.groupingBy(
                        Product::category,
                        Collectors.summingInt(Product::quantity)
                ));

        // 5Ô∏è‚É£ Sort by quantity DESC
        LinkedHashMap<String, Integer> sortedReport = report.entrySet().stream()
                .sorted(Map.Entry.<String, Integer>comparingByValue().reversed())
                .collect(Collectors.toMap(
                        Map.Entry::getKey,
                        Map.Entry::getValue,
                        (a, b) -> a,
                        LinkedHashMap::new
                ));

        // 6Ô∏è‚É£ Print the final report
        System.out.println("=== CATEGORY SALES REPORT ===");
        sortedReport.forEach((category, qty) ->
                System.out.println(category + ": " + qty));
    }

    // Sample data generator (from above)
    private static List<Order> getOrders() {
        return List.of(
                new Order(1, List.of(
                        new Product("Keyboard", "Electronics", 2, new BigDecimal("700"), StockStatus.IN_STOCK),
                        new Product("Mouse", "Electronics", 1, new BigDecimal("300"), StockStatus.OUT_OF_STOCK),
                        new Product("Notebook", "Stationery", 5, new BigDecimal("50"), StockStatus.IN_STOCK)
                )),
                new Order(2, List.of(
                        new Product("Laptop", "Electronics", 1, new BigDecimal("55000"), StockStatus.IN_STOCK),
                        new Product("Pen", "Stationery", 10, new BigDecimal("10"), StockStatus.IN_STOCK)
                )),
                new Order(3, List.of(
                        new Product("Pencil", "Stationery", 2, new BigDecimal("20"), StockStatus.IN_STOCK)
                ))
        );
    }
}

```

---

# üìå **Explanation of Each Step**

### ‚úî Step 1 ‚Äî Filter only expensive orders

```java
order.products().stream()
    .map(p -> p.price() * p.quantity)
    .reduce(BigDecimal.ZERO, BigDecimal::add)
```

### ‚úî Step 2 ‚Äî Flatten products from all orders

Using:

```java
.flatMap(order -> order.products().stream())
```

### ‚úî Step 3 ‚Äî Keep only IN_STOCK products

```java
.filter(p -> p.stockStatus() == StockStatus.IN_STOCK)
```

### ‚úî Step 4 ‚Äî Group by category and sum quantities

```java
Collectors.groupingBy(Product::category, Collectors.summingInt(Product::quantity))
```

### ‚úî Step 5 ‚Äî Sort by quantity descending

Using sorted + LinkedHashMap.

---

# üéØ **Example Output**

```
=== CATEGORY SALES REPORT ===
Stationery: 15
Electronics: 3
```

Because:

- Order 3 is excluded (< 500)
- Out-of-stock Mouse is excluded
- Electronics: Keyboard (2) + Laptop (1) = 3
- Stationery: Notebook (5) + Pen (10) = 15

---

**REFERENCE**
https://www.youtube.com/watch?v=lm3rgUM1tDk

---

---

==> Updated the above code to support **(1) ‚Äúorders in the last 24 hours with total value > 500‚Äù** and **(2) ‚Äúinclude the product ID‚Äù**, we need **two small model changes**:

1. `Order` must have a timestamp (ex: `createdAt`)
2. `Product` must have a `productId`

---

## Order.java (add `createdAt`)

```java
import java.time.Instant;
import java.util.List;

public record Order(
        int id,
        Instant createdAt,
        List<Product> products
) {
}
```

---

## Product.java (add `productId`)

```java
import java.math.BigDecimal;

public record Product(
        long productId,
        String name,
        String category,
        int quantity,           // quantity purchased in this order
        BigDecimal price,       // price per unit
        StockStatus stockStatus // IN_STOCK / OUT_OF_STOCK
) {
}
```

---

## StockStatus ( No changes)

```java
public enum StockStatus {IN_STOCK, OUT_OF_STOCK}
```

---

## EcommerceReport.java (filter last 24h + total > 500, and print productId)

```java
import java.math.BigDecimal;
import java.time.Duration;
import java.time.Instant;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

public class EcommerceReport {

    public static void main(String[] args) {

        List<Order> orders = getOrders(); // assume method returns sample data

        Map<String, Integer> report = orders.stream()

                // 1Ô∏è‚É£ Filter only orders with total value > 500
                .filter(order -> order.products().stream()
                        .map(p -> p.price().multiply(BigDecimal.valueOf(p.quantity())))
                        .reduce(BigDecimal.ZERO, BigDecimal::add)
                        .compareTo(new BigDecimal("500")) > 0
                )

                // 2Ô∏è‚É£ Extract all products from all orders
                .flatMap(order -> order.products().stream())

                // 3Ô∏è‚É£ Exclude OUT_OF_STOCK products
                .filter(p -> p.stockStatus() == StockStatus.IN_STOCK)

                // 4Ô∏è‚É£ Group by product category, summing quantities
                .collect(Collectors.groupingBy(
                        Product::category,
                        Collectors.summingInt(Product::quantity)
                ));

        // 5Ô∏è‚É£ Sort by quantity DESC
        LinkedHashMap<String, Integer> sortedReport = report.entrySet().stream()
                .sorted(Map.Entry.<String, Integer>comparingByValue().reversed())
                .collect(Collectors.toMap(
                        Map.Entry::getKey,
                        Map.Entry::getValue,
                        (a, b) -> a,
                        LinkedHashMap::new
                ));

        // 6Ô∏è‚É£ Print the final report
        System.out.println("=== CATEGORY SALES REPORT ===");
        sortedReport.forEach((category, qty) ->
                System.out.println(category + ": " + qty));
    }

    // Sample data generator (from above)
    private static List<Order> getOrders() {
        Instant now = Instant.now();

        return List.of(
                // ‚úÖ Qualifies: within 24h + total > 500
                new Order(1, now.minus(Duration.ofHours(2)), List.of(
                        new Product(101L, "Keyboard", "Electronics", 2, new BigDecimal("700"), StockStatus.IN_STOCK),
                        new Product(102L, "Mouse", "Electronics", 1, new BigDecimal("300"), StockStatus.OUT_OF_STOCK),
                        new Product(201L, "Notebook", "Stationery", 5, new BigDecimal("50"), StockStatus.IN_STOCK)
                )),

                // ‚ùå NOT within 24h (30 hours ago)
                new Order(2, now.minus(Duration.ofHours(30)), List.of(
                        new Product(301L, "Laptop", "Electronics", 1, new BigDecimal("55000"), StockStatus.IN_STOCK),
                        new Product(202L, "Pen", "Stationery", 10, new BigDecimal("10"), StockStatus.IN_STOCK)
                )),

                // ‚ùå Within 24h, but total <= 500
                new Order(3, now.minus(Duration.ofHours(10)), List.of(
                        new Product(203L, "Pencil", "Stationery", 2, new BigDecimal("20"), StockStatus.IN_STOCK)
                ))
        );
    }
}

```

# **Output**

```
=== CATEGORY SALES REPORT ===
Stationery: 15
Electronics: 3
```

---

---

---
