==> Convert List to Map using Collectors.toMap

---

# ‚úÖ **1. Before (classic imperative loop) ‚Äì Correct and common**

```
Map<Integer, String> map = new HashMap<>();
for (Person p : people) {
    map.put(p.getId(), p.getName());
}
```

This works perfectly fine and is readable.
However, it is **manual and verbose** when converting collections.

---

# ‚úÖ **2. After (functional style with streams) ‚Äì Also correct and idiomatic**

```
Map<Integer, String> map = people.stream()
    .collect(Collectors.toMap(Person::getId, Person::getName));
```

This version is:

- **Concise**
- **More expressive**
- **Uses method references**
- **Avoids boilerplate loops**

This is considered **standard modern Java** for converting lists to maps.

---

# ‚ö†Ô∏è Important Caveat

`Collectors.toMap()` **throws an exception if keys collide**:

### ‚ö†Ô∏è you should be aware of **duplicate key** handling in real applications

```
java.lang.IllegalStateException: Duplicate key
```

Example:

If two Person objects share the same ID:

```

public record Person(int id, String name) {
}


import java.util.*;
import java.util.stream.Collectors;

public class ToMapDuplicateKeyDemo {

    public static void main(String[] args) {

        // List with duplicate IDs
        List<Person> people = List.of(
                new Person(1, "Alice"),
                new Person(1, "Bob"),
                new Person(2, "Charlie")
        );

        System.out.println("=== Trying collectors.toMap() WITHOUT merge function ===");
        try {
            Map<Integer, String> mapFail = people.stream()
                    .collect(Collectors.toMap(Person::id, Person::name));

            System.out.println(mapFail);
        } catch (Exception ex) {
            // This will print the Duplicate Key error
            System.out.println("Exception caught: " + ex.getMessage());
        }

        System.out.println("\n=== Using a merge function: keep the FIRST value ===");

        Map<Integer, String> mapKeepFirst = people.stream()
                .collect(Collectors.toMap(
                        Person::id,
                        Person::name,
                        (existing, replacement) -> existing   // keep existing
                ));

        System.out.println(mapKeepFirst);     //  {1=Alice, 2=Charlie}

        System.out.println("\n=== Using a merge function: keep the LATEST value ===");

        Map<Integer, String> mapKeepLatest = people.stream()
                .collect(Collectors.toMap(
                        Person::id,
                        Person::name,
                        (existing, replacement) -> replacement   // keep new one
                ));

        System.out.println(mapKeepLatest);    // {1=Bob, 2=Charlie}

        System.out.println("\n=== Using merge function to COMBINE values ===");

        Map<Integer, String> mapCombined = people.stream()
                .collect(Collectors.toMap(
                        Person::id,
                        Person::name,
                        (existing, replacement) -> existing + ", " + replacement
                ));

        System.out.println(mapCombined);  // {1=Alice, Bob, 2=Charlie}

    }
}

```

# ** Output:**

```
=== Trying collectors.toMap() WITHOUT merge function ===
Exception caught: Duplicate key 1 (attempted merging values Alice and Bob)

=== Using a merge function: keep the FIRST value ===
{1=Alice, 2=Charlie}

=== Using a merge function: keep the LATEST value ===
{1=Bob, 2=Charlie}

=== Using merge function to COMBINE values ===
{1=Alice, Bob, 2=Charlie}
```

---

==> How to convert List ‚Üí Map using streams + BigDecimal + enums

Great ‚Äî here is a **clean, real-world, production-style example** showing:

‚úî A `List` of objects
‚úî An enum (`Department`)
‚úî A `BigDecimal` salary
‚úî Converting the list into multiple different **Map** structures using **streams**

This is the exact pattern used in payroll, accounting, HR, or reporting systems.

---

```
public enum Department {IT, HR, FINANCE, SALES}


import java.math.BigDecimal;

public record Employee(int id, String name, Department department, BigDecimal salary) {
}


import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.*;
import java.util.stream.Collectors;

public class EmployeeMapExample {

    public static void main(String[] args) {

        List<Employee> employees = List.of(
                new Employee(1, "Alice", Department.IT, new BigDecimal("70000")),
                new Employee(2, "Bob", Department.HR, new BigDecimal("50000")),
                new Employee(3, "Charlie", Department.IT, new BigDecimal("85000")),
                new Employee(4, "David", Department.SALES, new BigDecimal("60000")),
                new Employee(5, "Eva", Department.IT, new BigDecimal("95000"))
        );

        // 1. Map<id, Employee>
        // Very common: indexing employees by ID.
        Map<Integer, Employee> mapById = employees.stream()
                .collect(Collectors.toMap(Employee::id, e -> e));

        // 2. Map<Department, BigDecimal> ‚Äì total salaries
         //  Calculate total salary cost per department
         //  Using BigDecimal::add safely for money
        Map<Department, BigDecimal> salaryByDept = employees.stream()
                .collect(Collectors.toMap(
                        Employee::department,
                        Employee::salary,
                        BigDecimal::add
                ));

        // 3. Map<Department, List<Employee>> ‚Äì group by dept
        // Group employees by their department
        Map<Department, List<Employee>> employeesByDept = employees.stream()
                .collect(Collectors.groupingBy(Employee::department));

        // 4. Map<Department, BigDecimal> ‚Äì average salary
        Map<Department, BigDecimal> avgSalaryByDept = employees.stream()
                .collect(Collectors.groupingBy(
                        Employee::department,
                        Collectors.collectingAndThen(
                                Collectors.mapping(Employee::salary, Collectors.toList()),
                                salaries -> {
                                    BigDecimal sum = salaries.stream()
                                            .reduce(BigDecimal.ZERO, BigDecimal::add);
                                    return sum.divide(
                                            new BigDecimal(salaries.size()),
                                            2,
                                            RoundingMode.HALF_UP
                                    );
                                }
                        )
                ));

        // Print results
        System.out.println("Map by ID:");
        System.out.println(mapById);
        System.out.println("\nTotal Salary by Department:");
        System.out.println(salaryByDept);
        System.out.println("\nEmployees by Department:");
        System.out.println(employeesByDept);
        System.out.println("\nAverage Salary by Department:");
        System.out.println(avgSalaryByDept);
    }
}


```

---

# ‚≠ê Output (example)

```
Map by ID:
{1=Employee[id=1, name=Alice, department=IT, salary=70000], 2=Employee[id=2, name=Bob, department=HR, salary=50000], 3=Employee[id=3, name=Charlie, department=IT, salary=85000], 4=Employee[id=4, name=David, department=SALES, salary=60000], 5=Employee[id=5, name=Eva, department=IT, salary=95000]}

Total Salary by Department:
{IT=250000, SALES=60000, HR=50000}

Employees by Department:
{IT=[Employee[id=1, name=Alice, department=IT, salary=70000], Employee[id=3, name=Charlie, department=IT, salary=85000], Employee[id=5, name=Eva, department=IT, salary=95000]], SALES=[Employee[id=4, name=David, department=SALES, salary=60000]], HR=[Employee[id=2, name=Bob, department=HR, salary=50000]]}

Average Salary by Department:
{IT=83333.33, SALES=60000.00, HR=50000.00}
```

---

==> Show an example Using `EnumMap` for enum keys (super fast)

Perfect ‚Äî using **EnumMap** is one of the fastest and cleanest ways to build maps keyed by an enum.

---

# ‚úÖ Full Example: Total Salary by Department Using EnumMap

```
public enum Department {IT, HR, FINANCE, SALES}


import java.math.BigDecimal;

public record Employee(int id, String name, Department department, BigDecimal salary) {
}

import java.math.BigDecimal;
import java.util.*;
import java.util.stream.Collectors;

public class EnumMapExample {

    public static void main(String[] args) {

        List<Employee> employees = List.of(
                new Employee(1, "Alice", Department.IT, new BigDecimal("70000")),
                new Employee(2, "Bob", Department.HR, new BigDecimal("50000")),
                new Employee(3, "Charlie", Department.IT, new BigDecimal("85000")),
                new Employee(4, "David", Department.SALES, new BigDecimal("60000")),
                new Employee(5, "Eva", Department.IT, new BigDecimal("95000"))
        );

        // Use EnumMap directly instead of HashMap
        EnumMap<Department, BigDecimal> salaryByDept = employees.stream()
                .collect(Collectors.toMap(
                        Employee::department,           // key extractor
                        Employee::salary,               // value extractor
                        BigDecimal::add,                // merge function
                        () -> new EnumMap<>(Department.class) // supplier
                ));

        System.out.println("Total Salary by Department (EnumMap):");
        salaryByDept.forEach((dept, total) ->
                System.out.println(dept + " -> " + total));
    }
}

```

---

# üìù Output

```
Total Salary by Department (EnumMap):
IT -> 250000
HR -> 50000
FINANCE -> 0   (if no entries, map may omit this key)
SALES -> 60000
```

Note: FINANCE won‚Äôt appear unless you initialize it manually.
EnumMap does **not** auto-create entries.

---

# üöÄ Quick Comparisons

### ‚úî EnumMap (best choice for enum keys)

- blazing fast
- deterministic order
- fewer memory allocations

### ‚úî HashMap

- works but slower
- allows null keys (EnumMap does NOT)

# ‚ö° Bonus: Preinitialize EnumMap for all departments

If you want **every enum key present**, even with zero values:

```
EnumMap<Department, BigDecimal> initialized = new EnumMap<>(Department.class);
for (Department d : Department.values()) {
    initialized.put(d, BigDecimal.ZERO);
}

employees.forEach(emp ->
        initialized.merge(emp.department(), emp.salary(), BigDecimal::add)
);
```

This avoids missing keys.

---
