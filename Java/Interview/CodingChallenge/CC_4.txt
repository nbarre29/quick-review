==> Find duplicate characters in a string using Java Streams

https://www.youtube.com/watch?v=1Ps5F1PU72M

import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;

public class Test {
    public static void main(String[] args) {
        String input = "axccbdd";

        /*final Map<String, Long> collect = Arrays.stream(input.split("")).collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
        System.out.println(collect);*/

        final List<String> duplicateElements = Arrays.stream(input.split("")).collect(Collectors.groupingBy(Function.identity(), Collectors.counting()))
                .entrySet()
                .stream()
                .filter(x -> x.getValue() > 1)     // x.getValue() == 1  for uniqueElements
                .map(Map.Entry::getKey)
                .collect(Collectors.toList());

        System.out.println(duplicateElements);
    }
}
----------------------------------------------------

import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;

public class Test {
    public static void main(String[] args) {
        String input = "Fear leads to anger anger leads to hatred hatred leads to conflict conflict leads to suffering";

        /*final Map<String, Long> collect = Arrays.stream(input.split("")).collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
        System.out.println(collect);*/

        final List<String> duplicateWords = Arrays.stream(input.split("\\s")).collect(Collectors.groupingBy(Function.identity(), Collectors.counting()))
                .entrySet()
                .stream()
                .filter(x -> x.getValue() > 1)
                .map(Map.Entry::getKey)
                .collect(Collectors.toList());

        System.out.println(duplicateWords);
    }
}
----------------------------------------------------
final List<String> duplicateWords = Arrays.stream(input.split("\\s+")).collect(Collectors.groupingBy(Function.identity(), Collectors.counting()))
                .entrySet()
                .stream()
                .filter(x -> x.getValue() > 1)
                .map(Map.Entry::getKey)
                .collect(Collectors.toList());
____________________________________________________
// find first non-repeat element from a given string
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.function.Function;
import java.util.stream.Collectors;

public class Test {
    public static void main(String[] args) {
        String input = "ilovejavatechie";

        final String firstNonRepeatElement = Arrays.stream(input.split("")).collect(Collectors.groupingBy(Function.identity(), LinkedHashMap::new, Collectors.counting()))
                .entrySet()
                .stream()
                .filter(x -> x.getValue() == 1)      // x.getValue() > 1 to get the first repeat element
                .findFirst().get().getKey();
        System.out.println("1st non repeat element " + firstNonRepeatElement);


    }
}

______________________________________________________________________________________
==> 
import java.util.Arrays;
import java.util.Comparator;

public class Test {
    public static void main(String[] args) {
        int[] numbers = {5, 9, 11, 2, 8, 21, 1};

        Integer secondHighestNumber = Arrays.stream(numbers).boxed()
                .sorted(Comparator.reverseOrder())
                .skip(1)
                .findFirst().get();
        System.out.println(secondHighestNumber);  //11

    }
}
---------------------------------------------------------------------------------------
==> Above code calls .get on an Optional without checking if a value is present first. This can throw NoSuchElementException if the array has fewer than 2 elements.

Replace the unsafe .get() call with .orElse(null), which is a safer way to handle Optional values. This prevents potential NoSuchElementException errors and returns null if the array doesn't have a second highest number (e.g., if the array has fewer than 2 elements).

```
import java.util.Arrays;
import java.util.Comparator;

public class Test {
    public static void main(String[] args) {
        int[] numbers = {5, 9, 11, 2, 8, 21, 1};

        Integer secondHighestNumber = Arrays.stream(numbers).boxed()
                .sorted(Comparator.reverseOrder())
                .skip(1)
                .findFirst()
                .orElse(null);
        System.out.println(secondHighestNumber);

    }
}
```


```
import java.util.Arrays;
import java.util.Comparator;

public class Test {
    public static void main(String[] args) {
        int[] numbers = {5};

        Integer secondHighestNumber = Arrays.stream(numbers).boxed()
                .sorted(Comparator.reverseOrder())
                .skip(1)
                .findFirst().orElseThrow(() -> new IllegalArgumentException("Array must contain at least two distinct numbers"));
        System.out.println(secondHighestNumber);

    }
}
```
---------------------------------------------------------------------------------------

==> Another approach of converting an IntStream to a Stream<Integer>
boxed() is a more concise, stream-specific method, but just showing that there is another approach, mapToObj(Integer::valueOf)

```
import java.util.Arrays;
import java.util.Comparator;

public class Test {
    public static void main(String[] args) {
        int[] numbers = {5, 9, 11, 2, 8, 21, 1};

        Integer secondHighestNumber = Arrays.stream(numbers).mapToObj(Integer::valueOf)
                .sorted(Comparator.reverseOrder())
                .skip(1)
                .findFirst()
                .orElse(null);
        System.out.println(secondHighestNumber);

    }
}
```

______________________________________________________________________________________

==> Find the longest string from given array
import java.util.Arrays;

public class Test {
    public static void main(String[] args) {
        String[] strArray = {"java", "techie", "springboot", "microservices"};

        String longestString = Arrays.stream(strArray).reduce((word1, word2) -> word1.length() > word2.length() ? word1 : word2).get();
        System.out.println(longestString);

    }
}
---------------------------------------------------------------------------------------
==> a simpler approach! The new version uses Arrays.stream().max() with Comparator.comparingInt(String::length), which is more straightforward than using reduce().

Key improvements:
a) More readable: max() directly expresses the intent of finding the maximum element
b) Less code: No need to write custom reduction logic
c) Cleaner: The comparator Comparator.comparingInt(String::length) is concise and clear

```
import java.util.Arrays;
import java.util.Comparator;

public class Test {
    public static void main(String[] args) {
        String[] strArray = {"java", "techie", "springboot", "microservices"};

        String longestString = Arrays.stream(strArray)
                .max(Comparator.comparingInt(String::length))
                .get();
        System.out.println(longestString);

    }
}
```
______________________________________________________________________________________
//print all the shortest strings in an array of strings
import java.util.Arrays;

public class Test {
    public static void main(String[] args) {
        String[] strArray = {"apple", "banana", "cat", "dog", "elephant"};

// Find the length of the shortest string
        int shortestLength = Arrays.stream(strArray)
                .mapToInt(String::length)
                .min()
                .orElse(0);

// Print all the shortest strings
        Arrays.stream(strArray)
                .filter(word -> word.length() == shortestLength)
                .forEach(System.out::println);


    }
}
______________________________________________________________________________________
//print all the longest strings in an array of strings
import java.util.Arrays;

public class Test {
    public static void main(String[] args) {
        String[] strArray = {"apple", "banana", "antelope", "cat", "dog", "elephant", "flounder"};

// Find the length of the longest string
        int longestLength = Arrays.stream(strArray)
                .mapToInt(String::length)
                .max()
                .orElse(0);

// Print all the longest strings
        Arrays.stream(strArray)
                .filter(word -> word.length() == longestLength)
                .forEach(System.out::println);

    }
}
______________________________________________________________________________________
==> print all elements in an array which starts with 1

import java.util.Arrays;

public class FindNumbersStartingWith1 {

    public static void main(String[] args) {
        int[] arrayOfInts = {1234, 1235, 1236, 43232, 12443, 5646334, 1231412, 6798796, 8987};

        // Find all the numbers which start with 1.
        Arrays.stream(arrayOfInts)
                .filter(number -> String.valueOf(number).startsWith("1"))
                .forEach(System.out::println);

    }
}
---------------------------------------------------------------------------------------
==> Do not convert int to String above:

 Yes ðŸ‘ â€” you **can do it without converting the number to a String**, using **pure numeric logic**.
Whether itâ€™s *simpler* depends on how you define simplicity, but it is definitely more **efficient and interview-friendly**.

---

## âœ… **Numeric (no String conversion) approach**

### Idea

A number â€œstarts with 1â€ if its **most significant digit** is `1`.

We can repeatedly divide by `10` until only one digit is left.

---

## âœ… **Clean numeric solution**

```
import java.util.Arrays;

public class FindNumbersStartingWith1 {

    public static void main(String[] args) {
        int[] arrayOfInts = {1234, 1235, 1236, 43232, 12443, 5646334, 1231412, 6798796, 8987};

        Arrays.stream(arrayOfInts)
                .filter(FindNumbersStartingWith1::startsWithOne)
                .forEach(System.out::println);
    }

    private static boolean startsWithOne(int number) {
        number = Math.abs(number); // safety for negatives
        while (number >= 10) {
            number /= 10;
        }
        return number == 1;
    }
}
```

### âœ… Output

```
1234
1235
1236
12443
1231412
```

---

## ðŸ§  **How it works**

Example: `1234`

```
1234 / 10 â†’ 123
123  / 10 â†’ 12
12   / 10 â†’ 1   âœ…
```

Now the leading digit is `1`.

---

## âš¡ **Is this â€œsimplerâ€ than String?**

### âœ” String approach

```java
String.valueOf(number).startsWith("1")
```

* Very readable
* Very common in interviews
* Slightly less efficient (string allocation)

### âœ” Numeric approach

```java
while (number >= 10) number /= 10;
return number == 1;
```

* No object creation
* Faster & memory-efficient
* More â€œcomputer scienceâ€ style
* Often preferred in **performance-sensitive code**

---

## â­ **Best Practice Recommendation**

| Scenario                      | Preferred Approach |
| ----------------------------- | ------------------ |
| Readability / interviews      | âœ… String approach  |
| Performance / low-level logic | âœ… Numeric approach |
| Large streams / hot paths     | âœ… Numeric approach |

Both are **correct**.
Knowing **both** is ideal.

---

If you want, I can also show:

* A **log10-based** solution
* A **bitwise** trick (for specific ranges)
* How to generalize this for â€œstarts with Nâ€

Just tell me!

______________________________________________________________________________________


==> String.join
import java.util.Arrays;
import java.util.List;

public class Test {
    public static void main(String[] args) {
        List<String> numbers = Arrays.asList("1", "2", "3", "4");
        String result = String.join("-", numbers);
        System.out.println(result);
    }
}

----------------------------------------------------
//Skip & limit method usecase based example
import java.util.stream.IntStream;

public class Test {
    public static void main(String[] args) {
        IntStream.rangeClosed(1, 10)
                .skip(1)
                .limit(8)
                .forEach(System.out::println);
    }
}
______________________________________________________________________________________

==> map vs flatmap

```
import java.util.List;

public record Customer(int id, String name, String email, List<String> phoneNumbers) {
}


import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class EkartDataBase {
    public static List<Customer> getAll() {
        return Stream.of(
                new Customer(101, "john", "john@gmail.com", Arrays.asList("397937955", "21654725")),
                new Customer(102, "smith", "smith@gmail.com", Arrays.asList("89563865", "2487238947")),
                new Customer(103, "peter", "peter@gmail.com", Arrays.asList("38946328654", "3286487236")),
                new Customer(104, "kely", "kely@gmail.com", Arrays.asList("389246829364", "948609467"))
        ).collect(Collectors.toList());
    }
}


import java.util.List;
import java.util.stream.Collectors;

public class MapVsFlatMap {
    public static void main(String[] args) {

        List<Customer> customers = EkartDataBase.getAll();

        // Extracting email addresses using map
        List<String> emails = customers.stream()
                .map(Customer::email)
                .collect(Collectors.toList());
        System.out.println(emails);

        // Extracting phone numbers using map
        List<List<String>> phoneNumbers = customers.stream()
                .map(Customer::phoneNumbers)
                .collect(Collectors.toList());
        System.out.println(phoneNumbers);

        // Extracting phone numbers using flatMap to flatten the lists into a single list
        List<String> phones = customers.stream()
                .flatMap(customer -> customer.phoneNumbers().stream())
                .collect(Collectors.toList());
        System.out.println(phones);
    }
}
```

#### Output
```
[john@gmail.com, smith@gmail.com, peter@gmail.com, kely@gmail.com]
[[397937955, 21654725], [89563865, 2487238947], [38946328654, 3286487236], [389246829364, 948609467]]
[397937955, 21654725, 89563865, 2487238947, 38946328654, 3286487236, 389246829364, 948609467]
```
______________________________________________________________________________________
