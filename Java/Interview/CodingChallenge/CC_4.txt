==> Find duplicate characters in a string using Java Streams

https://www.youtube.com/watch?v=1Ps5F1PU72M

import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;

public class Test {
    public static void main(String[] args) {
        String input = "axccbdd";

        /* Map<String, Long> collect = Arrays.stream(input.split("")).collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
        System.out.println(collect);*/

        List<String> duplicateElements = Arrays.stream(input.split("")).collect(Collectors.groupingBy(Function.identity(), Collectors.counting()))
                .entrySet()
                .stream()
                .filter(entry -> entry.getValue() > 1)     // entry.getValue() == 1  for uniqueElements
                .map(Map.Entry::getKey)
                .collect(Collectors.toList());

        System.out.println(duplicateElements);
    }
}

#### MyNotes:
a) `.map(Map.Entry::getKey)` is same as `.map(entry -> entry.getKey())`

-------------------------------------------------------------------------------------
==> any improvements to above code ?

The code works correctly but can be improved for readability and efficiency:

**Issues:**
1. **Long method chain**: The stream pipeline is hard to read on one line
2. **Intermediate list collection**: Not necessary if you just want to print
3. **Legacy `toList()`**: Java 16+ has a simpler alternative

**Improved version:**

```java
import java.util.Arrays;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;

public class Test {
    public static void main(String[] args) {
        String input = "axccbdd";

        Map<String, Long> charCounts = Arrays.stream(input.split(""))
                .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));

        charCounts.entrySet()
                .stream()
                .filter(entry -> entry.getValue() > 1)
                .map(Map.Entry::getKey)
                .forEach(System.out::println);
    }
}
```

**Alternative - more efficient approach without `split()`:**

```java
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;

public class Test {
    public static void main(String[] args) {
        String input = "axccbdd";

        input.chars()
                .mapToObj(c -> (char) c)
                .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()))
                .entrySet()
                .stream()
                .filter(entry -> entry.getValue() > 1)
                .map(Map.Entry::getKey)
                .forEach(System.out::println);
    }
}
```

**Benefits:**
- Avoids creating intermediate String array with `split()`
- More readable with intermediate variable
- Uses `forEach()` instead of collecting to a list just for printing

______________________________________________________________________________________

==> Find duplicate words in a string using Java Streams
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;

public class Test {
    public static void main(String[] args) {
        String input = "Fear leads to anger anger leads to hatred hatred leads to conflict conflict leads to suffering";

        List<String> duplicateWords = Arrays.stream(input.split("\\s"))
                .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()))
                .entrySet()
                .stream()
                .filter(x -> x.getValue() > 1)
                .map(Map.Entry::getKey)
                .toList();

        System.out.println(duplicateWords);
    }
}
--------------------------------------------------------------------------------------

==> Any improvements to above code ?

Here are some improvements to consider:

1. **Case-insensitive comparison**: Words like "Anger" and "anger" would be treated as different
2. **Simplify stream operations**: Combine the two streams into one
3. **Add input validation**: Handle null or empty input
4. **Extract constants**: Make the regex pattern clearer
5. **Improve variable naming**: Be more descriptive

**Improved version:**

```java
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;

public class Test {
    private static final String WHITESPACE_PATTERN = "\\s+";

    public static void main(String[] args) {
        String input = "Fear leads to anger anger leads to hatred hatred leads to conflict conflict leads to suffering";

        List<String> duplicateWords = findDuplicateWords(input);
        System.out.println(duplicateWords);
    }

    private static List<String> findDuplicateWords(String text) {
        if (text == null || text.isBlank()) {
            return Collections.emptyList();
        }

        return Arrays.stream(text.toLowerCase().split(WHITESPACE_PATTERN))
                .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()))
                .entrySet()
                .stream()
                .filter(entry -> entry.getValue() > 1)
                .map(Map.Entry::getKey)
                .toList();
    }
}
```

**Key changes:**
- Added null/empty check
- Made comparison case-insensitive with `toLowerCase()`
- Used `\\s+` to handle multiple whitespaces
- Extracted method for better testability and reusability
- Used constant for regex pattern
______________________________________________________________________________________

==> Find the first non-repeating character in a string using Java 8 features
```
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.function.Function;
import java.util.stream.Collectors;

public class Test {
    public static void main(String[] args) {
        String input = "ilovejavatechie";

        final String firstNonRepeatElement = Arrays.stream(input.split(""))
                .collect(Collectors.groupingBy(Function.identity(), LinkedHashMap::new, Collectors.counting()))
                .entrySet()
                .stream()
                .filter(entry -> entry.getValue() == 1)      // entry.getValue() > 1 to get the first repeat element
                .findFirst().get().getKey();
        System.out.println("1st non repeat element " + firstNonRepeatElement);

    }
}
```
---------------------------------------------------------------------------------------
==> Any improvements to above code:

Yes ðŸ‘ â€” your solution is **correct and already quite good**, but it **can be simplified and made cleaner**, while keeping it **Java-8-only and interview-friendly**.

Below Iâ€™ll show **progressive simplifications**, explain *why* theyâ€™re better, and point out a couple of **small improvements**.

---

## âœ… Whatâ€™s good in your current code

* âœ” Correct logic
* âœ” Preserves insertion order using `LinkedHashMap`
* âœ” Uses Streams properly
* âœ” Interview-ready

---

## ðŸ”§ Improvements / Simplifications

### 1ï¸âƒ£ Avoid `split("")` (inefficient + regex-based)

`split("")`:

* Uses regex
* Creates a `String[]`
* Slightly heavy

Better to stream characters directly.

---

## âœ… **Cleanest & Most Idiomatic Java 8 Solution**

```java
import java.util.LinkedHashMap;
import java.util.function.Function;
import java.util.stream.Collectors;

public class Test {
    public static void main(String[] args) {
        String input = "ilovejavatechie";

        Character firstNonRepeating =
                input.chars()
                     .mapToObj(c -> (char) c)
                     .collect(Collectors.groupingBy(
                             Function.identity(),
                             LinkedHashMap::new,
                             Collectors.counting()
                     ))
                     .entrySet()
                     .stream()
                     .filter(e -> e.getValue() == 1)
                     .map(e -> e.getKey())
                     .findFirst()
                     .orElse(null);

        System.out.println("1st non repeating char: " + firstNonRepeating);
    }
}
```

### âœ… Why this is better

* No regex
* No intermediate arrays
* More idiomatic Java 8
* Safer (`orElse(null)` instead of `.get()`)

---

## âš ï¸ Important Safety Improvement

### âŒ Avoid this

```java
.findFirst().get(); // can throw NoSuchElementException
```

### âœ… Prefer this

```java
.orElse(null);
// or
.orElseThrow(() -> new RuntimeException("No non-repeating character"));
```

Interviewers **notice this**.

---

## ðŸ§  Alternative (More functional, no map exposed)

```java
Character first =
        input.chars()
             .mapToObj(c -> (char) c)
             .filter(ch -> input.indexOf(ch) == input.lastIndexOf(ch))
             .findFirst()
             .orElse(null);
```

### Trade-off

* âœ” Very concise
* âŒ O(nÂ²) internally
* âŒ Not ideal for large strings

Good for **short strings only**.

---

## ðŸŽ¯ Interview-Perfect One-Line Explanation

> â€œI use a LinkedHashMap to count character occurrences while preserving order, then return the first character with count 1.â€

---

## ðŸ Final Recommendation

| Approach                  | Use Case              |
| ------------------------- | --------------------- |
| Your original             | âœ” Correct             |
| `chars()` + LinkedHashMap | âœ… **Best & cleanest** |
| `indexOf/lastIndexOf`     | Quick demo only       |

---

______________________________________________________________________________________

==> Find the second highest number in an array of integers
```
import java.util.Arrays;
import java.util.Comparator;

public class Test {
    public static void main(String[] args) {
        int[] numbers = {5, 9, 11, 2, 8, 21, 1};

        Integer secondHighestNumber = Arrays.stream(numbers)
                .boxed()
                .sorted(Comparator.reverseOrder())
                .skip(1)
                .findFirst()
                .get();
        System.out.println(secondHighestNumber);  //11

    }
}
```
---------------------------------------------------------------------------------------
==> Above code calls .get on an Optional without checking if a value is present first. This can throw NoSuchElementException if the array has fewer than 2 elements.

Replace the unsafe .get() call with .orElse(null), which is a safer way to handle Optional values. This prevents potential NoSuchElementException errors and returns null if the array doesn't have a second highest number (e.g., if the array has fewer than 2 elements).

```
import java.util.Arrays;
import java.util.Comparator;

public class Test {
    public static void main(String[] args) {
        int[] numbers = {5, 9, 11, 2, 8, 21, 1};

        Integer secondHighestNumber = Arrays.stream(numbers)
                .boxed()
                .sorted(Comparator.reverseOrder())
                .skip(1)
                .findFirst()
                .orElse(null);
        System.out.println(secondHighestNumber);

    }
}
```


```
import java.util.Arrays;
import java.util.Comparator;

public class Test {
    public static void main(String[] args) {
        int[] numbers = {5, 9, 11, 2, 8, 21, 1};

        Arrays.stream(numbers)
                .boxed()
                .sorted(Comparator.reverseOrder())
                .skip(1)
                .findFirst()
                .ifPresent(System.out::println);
    }
}
```


```
import java.util.Arrays;
import java.util.Comparator;

public class Test {
    public static void main(String[] args) {
        int[] numbers = {5};

        Integer secondHighestNumber = Arrays.stream(numbers)
                .boxed()
                .sorted(Comparator.reverseOrder())
                .skip(1)
                .findFirst()
                .orElseThrow(() -> new IllegalArgumentException("Array must contain at least two distinct numbers"));
        System.out.println(secondHighestNumber);

    }
}
```

```
import java.util.Arrays;
import java.util.Comparator;

public class Test {
    public static void main(String[] args) {
        int[] numbers = {5, 9, 11, 2, 8, 21, 1};

        Arrays.stream(numbers)
                .boxed()
                .sorted(Comparator.reverseOrder())
                .skip(1)
                .findFirst()
                .ifPresentOrElse(secondHighest ->
                        System.out.println("The second highest number is: " + secondHighest),
                    () -> System.out.println("There is no second highest number.")
                );

    }
}
```

---------------------------------------------------------------------------------------

==> Another approach of converting an IntStream to a Stream<Integer>
boxed() is a more concise, stream-specific method, but just showing that there is another approach, mapToObj(Integer::valueOf)

```
import java.util.Arrays;
import java.util.Comparator;

public class Test {
    public static void main(String[] args) {
        int[] numbers = {5, 9, 11, 2, 8, 21, 1};

        Integer secondHighestNumber = Arrays.stream(numbers)
                .mapToObj(Integer::valueOf)
                .sorted(Comparator.reverseOrder())
                .skip(1)
                .findFirst()
                .orElse(null);
        System.out.println(secondHighestNumber);

    }
}
```

______________________________________________________________________________________

==> Find the longest string from given array
```
import java.util.Arrays;

public class Test {
    public static void main(String[] args) {
        String[] strArray = {"java", "techie", "springboot", "microservices"};

        String longestString = Arrays.stream(strArray)
                .reduce((word1, word2) -> word1.length() > word2.length() ? word1 : word2)
                .get();
        System.out.println(longestString);

    }
}
```
---------------------------------------------------------------------------------------
==> a simpler approach! The new version uses Arrays.stream().max() with Comparator.comparingInt(String::length), which is more straightforward than using reduce().

Key improvements:
a) More readable: max() directly expresses the intent of finding the maximum element
b) Less code: No need to write custom reduction logic
c) Cleaner: The comparator Comparator.comparingInt(String::length) is concise and clear

```
import java.util.Arrays;
import java.util.Comparator;

public class Test {
    public static void main(String[] args) {
        String[] strArray = {"java", "techie", "springboot", "microservices"};

        String longestString = Arrays.stream(strArray)
                .max(Comparator.comparingInt(String::length))
                .get();
        System.out.println(longestString);

    }
}
```

#### MyNotes:
a)
```
import java.util.Arrays;
import java.util.Comparator;

public class Test {
    public static void main(String[] args) {
        String[] strArray = {"java", "techie", "springboot", "microservices"};

        Arrays.stream(strArray)
                .max(Comparator.comparingInt(String::length))
                .ifPresentOrElse(longestString ->
                                System.out.println("Longest string: " + longestString),
                        () -> System.out.println("Array is empty"));

    }
}
```

b) Find the shortest string in the array using min() method 
```
Arrays.stream(strArray)
                .min(Comparator.comparingInt(String::length))
                .ifPresent(System.out::println);
```

______________________________________________________________________________________

==> print all elements in an array which starts with 1

import java.util.Arrays;

public class FindNumbersStartingWith1 {

    public static void main(String[] args) {
        int[] arrayOfInts = {1234, 1235, 1236, 43232, 12443, 5646334, 1231412, 6798796, 8987};

        // Find all the numbers which start with 1.
        Arrays.stream(arrayOfInts)
                .filter(number -> String.valueOf(number).startsWith("1"))
                .forEach(System.out::println);

    }
}
---------------------------------------------------------------------------------------
==> Do not convert int to String above code:

 Yes ðŸ‘ â€” you **can do it without converting the number to a String**, using **pure numeric logic**.
Whether itâ€™s *simpler* depends on how you define simplicity, but it is definitely more **efficient and interview-friendly**.

---

## âœ… **Numeric (no String conversion) approach**

### Idea

A number â€œstarts with 1â€ if its **most significant digit** is `1`.

We can repeatedly divide by `10` until only one digit is left.

---

## âœ… **Clean numeric solution**

```
import java.util.Arrays;

public class FindNumbersStartingWith1 {

    public static void main(String[] args) {
        int[] arrayOfInts = {1234, 1235, 1236, 43232, 12443, 5646334, 1231412, 6798796, 8987};

        Arrays.stream(arrayOfInts)
                .filter(FindNumbersStartingWith1::startsWithOne)
                .forEach(System.out::println);
    }

    private static boolean startsWithOne(int number) {
        number = Math.abs(number); // safety for negatives
        while (number >= 10) {
            number /= 10;
        }
        return number == 1;
    }
}
```

### âœ… Output

```
1234
1235
1236
12443
1231412
```

---

## ðŸ§  **How it works**

Example: `1234`

```
1234 / 10 â†’ 123
123  / 10 â†’ 12
12   / 10 â†’ 1   âœ…
```

Now the leading digit is `1`.

---

## âš¡ **Is this â€œsimplerâ€ than String?**

### âœ” String approach

```java
String.valueOf(number).startsWith("1")
```

* Very readable
* Very common in interviews
* Slightly less efficient (string allocation)

### âœ” Numeric approach

```java
while (number >= 10) number /= 10;
return number == 1;
```

* No object creation
* Faster & memory-efficient
* More â€œcomputer scienceâ€ style
* Often preferred in **performance-sensitive code**

---

## â­ **Best Practice Recommendation**

| Scenario                      | Preferred Approach |
| ----------------------------- | ------------------ |
| Readability / interviews      | âœ… String approach  |
| Performance / low-level logic | âœ… Numeric approach |
| Large streams / hot paths     | âœ… Numeric approach |

Both are **correct**.
Knowing **both** is ideal.

---

If you want, I can also show:

* A **log10-based** solution
* A **bitwise** trick (for specific ranges)
* How to generalize this for â€œstarts with Nâ€

Just tell me!

______________________________________________________________________________________

==> String.join
import java.util.Arrays;
import java.util.List;

public class Test {
    public static void main(String[] args) {
        List<String> numbers = Arrays.asList("1", "2", "3", "4");
        String result = String.join("-", numbers);
        System.out.println(result);
    }
}

---------------------------------------------------------------------------------------
//Skip & limit method usecase based example
import java.util.stream.IntStream;

public class Test {
    public static void main(String[] args) {
        IntStream.rangeClosed(1, 10)
                .skip(1)
                .limit(8)
                .forEach(System.out::println);
    }
}
______________________________________________________________________________________

==> map vs flatmap

```
import java.util.List;

public record Customer(int id, String name, String email, List<String> phoneNumbers) {
}


import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class EkartDataBase {
    public static List<Customer> getAll() {
        return Stream.of(
                new Customer(101, "john", "john@gmail.com", Arrays.asList("397937955", "21654725")),
                new Customer(102, "smith", "smith@gmail.com", Arrays.asList("89563865", "2487238947")),
                new Customer(103, "peter", "peter@gmail.com", Arrays.asList("38946328654", "3286487236")),
                new Customer(104, "kely", "kely@gmail.com", Arrays.asList("389246829364", "948609467"))
        ).collect(Collectors.toList());
    }
}


import java.util.List;
import java.util.stream.Collectors;

public class MapVsFlatMap {
    public static void main(String[] args) {

        List<Customer> customers = EkartDataBase.getAll();

        // Extracting email addresses using map
        List<String> emails = customers.stream()
                .map(Customer::email)
                .collect(Collectors.toList());
        System.out.println(emails);

        // Extracting phone numbers using map
        List<List<String>> phoneNumbers = customers.stream()
                .map(Customer::phoneNumbers)
                .collect(Collectors.toList());
        System.out.println(phoneNumbers);

        // Extracting phone numbers using flatMap to flatten the lists into a single list
        List<String> phones = customers.stream()
                .flatMap(customer -> customer.phoneNumbers().stream())
                .collect(Collectors.toList());
        System.out.println(phones);
    }
}
```

#### Output
```
[john@gmail.com, smith@gmail.com, peter@gmail.com, kely@gmail.com]
[[397937955, 21654725], [89563865, 2487238947], [38946328654, 3286487236], [389246829364, 948609467]]
[397937955, 21654725, 89563865, 2487238947, 38946328654, 3286487236, 389246829364, 948609467]
```
______________________________________________________________________________________

==> Here's a small example demonstrating `(char)` casting:

```
public class Main {
    public static void main(String[] args) {
        // ASCII value to char
        int asciiValue = 65;
        char ch = (char) asciiValue;
        System.out.println(ch); // Output: A

        // Numeric operations
        int num = 97;
        char letter = (char) num;
        System.out.println(letter); // Output: a

        // Character arithmetic
        char c = 'A';
        int nextChar = c + 1;
        System.out.println((char) nextChar); // Output: B

        // Converting back
        char x = 'Z';
        int value = (int) x;
        System.out.println(value); // Output: 90
    }
}

```

The `(char)` cast converts an integer to its corresponding Unicode/ASCII character representation.

______________________________________________________________________________________

==> Demonstrates the difference between using (char) cast and not using it
```

public class Main {
    public static void main(String[] args) {
        String text = "Hello";

        System.out.println("Without (char) cast:");
        text.chars()
                .forEach(ch -> System.out.println(ch + " is an int"));

        System.out.println("\nWith (char) cast:");
        text.chars()
                .mapToObj(ch -> (char) ch)
                .forEach(ch -> System.out.println(ch + " is a char"));

        //using (char) but without mapToObj
        System.out.println("\nWith (char) cast but without mapToObj:");
        text.chars()
                .forEach(ch -> System.out.println((char) ch + " is a char"));


    }
}

```
#### Output:
```
Without (char) cast:
72 is an int
101 is an int
108 is an int
108 is an int
111 is an int

With (char) cast:
H is a char
e is a char
l is a char
l is a char
o is a char

With (char) cast but without mapToObj:
H is a char
e is a char
l is a char
l is a char
o is a char
```
______________________________________________________________________________________


