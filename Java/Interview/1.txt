==> Find the average of salaries in each department

public record Employee(String name, String department, double salary) {
}

```
import java.util.List;

public class Main {
    public static void main(String[] args) {

        List<Employee> employees = List.of(
                new Employee("Alice", "Engineering", 90000),
                new Employee("Bob", "Engineering", 85000),
                new Employee("Charlie", "HR", 60000),
                new Employee("Diana", "HR", 65000),
                new Employee("Eve", "Marketing", 70000)
        );

        employees.stream()
                .collect(
                        java.util.stream.Collectors.groupingBy(
                                Employee::department,
                                java.util.stream.Collectors.averagingDouble(Employee::salary)
                        )
                )
                .forEach((department, avgSalary) ->
                        System.out.println("Department: " + department + ", Average Salary: " + avgSalary)
                );
    }
}
```

```
Output:
Department: Engineering, Average Salary: 87500.0
Department: HR, Average Salary: 62500.0
Department: Marketing, Average Salary: 70000.0
```

#### MyNotes:
a) Map<String, Double> averageSalaryByDepartment = employees.stream()
                .collect(Collectors.groupingBy(Employee::department, Collectors.averagingDouble(Employee::salary)));

   averageSalaryByDepartment.forEach((department, avgSalary) ->
                System.out.println("Department: " + department + ", Average Salary: " + avgSalary));
				
				
b) // Find the highest paid employee
        Employee highestPaid = employees.stream()
                .max(java.util.Comparator.comparingDouble(Employee::salary))
                .orElseThrow();      // we could also have .orElse(null);

        System.out.println("Highest Paid Employee: " + highestPaid.name() + ", Salary: " + highestPaid.salary());	

#### MyNotes: 

a) with lambda it will be: ```.max((e1, e2) -> Double.compare(e1.salary(), e2.salary()))```

b) If we just want the highest salary, we can use the max() method from DoubleStream

```
double maxSalary = employees.stream()
                .mapToDouble(Employee::salary)
                .max()
                .orElse(0.0);

System.out.println("Maximum Salary: " + maxSalary);
```



c) // Calculate average salary of all employees
        double overallAvgSalary = employees.stream()
                .mapToDouble(Employee::salary)
                .average()
                .orElse(0.0);   // we cannot use `orElse(null)` with `OptionalDouble`** ‚Äî it won‚Äôt compile.
        System.out.println("Overall Average Salary: " + overallAvgSalary);	
		
#### MyNotes:  
a) **`mapToDouble()` converts from `Employee` objects to primitive `double` values.**

Here's the breakdown:

1. **Input**: `Stream<Employee>` (stream of objects)
2. **`mapToDouble(Employee::salary)`**: Extracts the `salary()` from each `Employee` and creates a `DoubleStream`
3. **Output**: `DoubleStream` (stream of primitive `double` values)

**Why use `mapToDouble()` instead of `map()`?**

```java
// Using mapToDouble() - returns DoubleStream
employees.stream()
    .mapToDouble(Employee::salary)  // DoubleStream
    .average()                       // returns OptionalDouble

// Using map() - returns Stream<Double>
employees.stream()
    .map(Employee::salary)           // Stream<Double> (boxed objects)
    .mapToDouble(Double::doubleValue) // need extra step
    .average()
```

**Benefits of `mapToDouble()`:**
- **Performance** - avoids boxing/unboxing overhead (no `Double` wrapper objects created)
- **Specialized operations** - `DoubleStream` has methods like `average()`, `sum()`, `min()`, `max()` that work directly with primitives
- **Cleaner code** - direct conversion in one step

So `mapToDouble()` is actually **unboxing** - going from objects to primitives, which is more efficient.

c.1) 
```
employees.stream()
                .mapToDouble(Employee::salary)
                .average()
                .ifPresent(avgSalary -> System.out.println("Average Salary: " + avgSalary));
```

c.2)
```
employees.stream()
                .mapToDouble(Employee::salary)
                .average()
                .ifPresentOrElse(
                        avgSalary -> System.out.println("Average salary: " + avgSalary),
                        () -> System.out.println("Could not calculate average salary.")
                );
```

REFERENCE:
https://www.youtube.com/watch?v=JVRy0IKLH0A

________________________________________________________________________________________

==> // Calculate average salary of all employees
        double overallAvgSalary = employees.stream()
                .mapToDouble(Employee::salary)
                .average()
                .orElse(0.0);
        System.out.println("Overall Average Salary: " + overallAvgSalary);


 choosing between **`orElse(0.0)`**, **`orElse(null)`**, and **`orElseThrow()`** depends entirely on what the *absence of a value* means in your domain.

Let‚Äôs break it down clearly.

---

# ‚úÖ **Your specific example**

```
employees.stream()
    .mapToDouble(Employee::salary)
    .average()
```

* `.average()` returns an `OptionalDouble`.
* It **cannot** contain `null` because primitive optionals (`OptionalDouble`, `OptionalInt`, `OptionalLong`) do NOT allow null.

üëâ **So you cannot use `orElse(null)` with `OptionalDouble`** ‚Äî it won‚Äôt compile.
`null` does not match the required primitive `double`.

Therefore, in your case:

* `orElse(0.0)` ‚úî valid
* `orElseThrow()` ‚úî valid
* `orElse(null)` ‚ùå not possible

---

# ‚úÖ General usage in other optionals (e.g., `Optional<T>`)


---

# üìä **Comparison Table: `orElse(0.0)` vs `orElse(null)` vs `orElseThrow()`**

| Method                                                               | When to Use                                                                       | What It Means                          | Pros                                                                        | Cons                                                                        |
| -------------------------------------------------------------------- | --------------------------------------------------------------------------------- | -------------------------------------- | --------------------------------------------------------------------------- | --------------------------------------------------------------------------- |
| **`orElse(0.0)`**                                                    | When you want a *safe default* value that makes sense in your domain              | Returns a default if Optional is empty | Simple; avoids exceptions; good for numeric calculations                    | Can hide bugs if 0.0 is not a meaningful value                              |
| **`orElse(null)`** (only for `Optional<T>`, not primitive optionals) | When `null` is a *valid domain signal* and the caller is designed to handle nulls | Returns `null` on empty                | Works when integrating with older APIs; can intentionally represent absence | Brings back `NullPointerException` problems; not recommended in modern Java |
| **`orElseThrow()`**                                                  | When *absence is an error condition*                                              | Throws exception if Optional is empty  | Very explicit; good for invariants; prevents silent failures                | Caller must handle exception; not good for ‚Äúnormal empty‚Äù cases             |

---

# üîç When should you use each?

## ‚úî **Use `orElse(0.0)` when:**

* You're doing math and `0.0` is a sensible fallback.
* Missing data is **normal**, not exceptional.
* You want safe, predictable behavior.

**Example:**

```
double avg = optionalAvg.orElse(0.0);
```

Good for:

* totals
* averages
* counters
* scoring

---

## ‚úî **Use `orElse(null)` when:**

* You‚Äôre working with `Optional<T>` (not primitive types).
* Your system already uses `null` to represent absence.
* You‚Äôre interfacing with *legacy code* that expects nulls.

‚úî Only use when null is an intentional part of your domain model.
‚úò Avoid if you can ‚Äî Optionals were invented *to avoid nulls*.

---

## ‚úî **Use `orElseThrow()` when:**

* A missing value means **your code is in an invalid state**.
* You want to fail fast and loudly.
* The value must be present logically.

**Example:**

```
double avg = optionalAvg.orElseThrow(() -> new IllegalStateException("No employees"));
```

Good for:

* Required configuration values
* Required database lookups
* Authentication/authorization flows
* Invariants ("this must never be empty")

---

# ‚≠ê Recommendation for *your* code

In your exact example:

### **If 0.0 is a reasonable average when there are no employees ‚Üí use:**

```
.orElse(0.0)
```

### **If having 0 employees is a bug ‚Üí use:**

```
.orElseThrow(() -> new IllegalStateException("No employees to calculate average"))
```

### **You cannot use `orElse(null)` here**

because `OptionalDouble` only accepts primitives.

---

# ‚úî Final Summary Table (Short Version)

| Scenario                                                   | Best Choice                           |
| ---------------------------------------------------------- | ------------------------------------- |
| Normal empty case; want default                            | `orElse(0.0)`                         |
| Absence is exceptional; should fail                        | `orElseThrow()`                       |
| Need to return null intentionally (non-primitive Optional) | `orElse(null)`                        |
| Using OptionalDouble                                       | `orElse(0.0)` or `orElseThrow()` only |

---

________________________________________________________________________________________

==> Find all unique skills from a list of employees

```
import java.util.List;

public record Employee(String name, List<String> skills) {

}


import java.util.Arrays;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
// this program demonstrates the use of flatMap to extract unique skills from a list of employees
public class Main {
    public static void main(String[] args) {

        List<Employee> employees = Arrays.asList(
                new Employee("Dillip", Arrays.asList("Java", "Spring", "SQL")),
                new Employee("Kiran", Arrays.asList("Java", "React", "AWS")),
                new Employee("Ravi", Arrays.asList("Python", ".Net", "AWS"))
        );

        Set<String> uniqueSkills = employees.stream()
                .flatMap(emp -> emp.skills().stream()) // flattening the skills lists into a single stream
                .collect(Collectors.toSet()); // collecting unique skills into a set
        System.out.println(uniqueSkills);  // [Java, .Net, Spring, React, AWS, SQL, Python]


    }
}
```

REFERENCE: https://www.youtube.com/watch?v=EFXJSG52nao

#### MyNotes:
a) List<String> uniqueSkills = employees.stream()
                .flatMap(emp -> emp.skills().stream())
                .distinct()
                .toList();
________________________________________________________________________________________


