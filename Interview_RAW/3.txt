
==> What is Optional?

`Optional` is a **container object introduced in Java 8** that may or may not contain a non-null value.

Instead of returning `null`, we return:

```java
Optional<T>
```

It represents:

* âœ… A value is present
* âŒ A value is absent (empty)

---

# ğŸ”¹ Why Was It Introduced?

To reduce **NullPointerException (NPE)**.

Before Java 8:

```java
String name = user.getName();
if (name != null) {
    System.out.println(name.toUpperCase());
}
```

If we forget the null check â†’ ğŸ’¥ NPE.

---

# ğŸ”¹ With Optional

```java
Optional<String> name = Optional.ofNullable(user.getName());

name.ifPresent(n -> 
    System.out.println(n.toUpperCase())
);
```

Cleaner. Safer. More expressive.

---


# ğŸ”¹ Example: Safe Default Value

```java
Optional<String> name = Optional.ofNullable(null);

String result = name.orElse("Default Name");
System.out.println(result); // Default Name
```

---

# ğŸ”¹ Example: Throw Exception If Missing

```java
String name = Optional.ofNullable(user.getName())
        .orElseThrow(() -> new RuntimeException("Name not found"));
```

---

# ğŸ”¹ Why Should We Use Optional?

### âœ… 1. Avoid NullPointerException

### âœ… 2. Make API more expressive

### âœ… 3. Force caller to handle absence

### âœ… 4. Cleaner functional style with Streams

### âœ… 5. Improves code readability

---

# ğŸ”¥ Important Interview Clarification

`Optional` is meant for:

âœ” Return types
âŒ Not for fields
âŒ Not for method parameters
âŒ Not for serialization

They may test this.

---

# ğŸ”¹ When NOT To Use Optional

Bad usage:

```java
class User {
    Optional<String> name;   // âŒ Not recommended
}
```

Good usage:

```java
public Optional<User> findUserById(Long id)
```

---

# ğŸ”¥ Interview-Perfect Answer (Short Version)

If asked:

> What is Optional and why do we use it?

Say:

> Optional is a container object introduced in Java 8 that may or may not contain a value. It is used to avoid NullPointerException and make the absence of a value explicit in method return types. It encourages safer and more expressive code by forcing callers to handle missing values instead of returning null.

Clean. Structured. Professional.

---

If you'd like, I can also explain:

* Difference between `orElse()` and `orElseGet()` (very common trick question)
* When Optional becomes anti-pattern
* Optional vs null performance impact
* How Optional works with Streams

https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/Optional.html

---
---
_________________________________________________________________________________________________________

==> How does garbage collection work?

This is a **very common core Java screening question**, especially for banking clients.

They donâ€™t expect JVM internals â€” but they do expect clear understanding.

Hereâ€™s the structured way to answer it.

---

# ğŸ”¹ What is Garbage Collection?

Garbage Collection (GC) is the process by which the **JVM automatically removes unused objects from memory (heap)**.

Its goal is to:

* Free memory
* Prevent memory leaks
* Avoid manual memory management (like C/C++)

---

# ğŸ”¹ Where Does It Work?

GC works in the **Heap memory**, not stack.

```text
Stack â†’ method calls, local variables  
Heap  â†’ objects created using new
```

Example:

```java
User user = new User();
```

That object lives in the heap.

---

# ğŸ”¹ When Is an Object Eligible for GC?

An object becomes eligible when:

âœ” No active references point to it.

Example:

```java
User user = new User();
user = null;   // Now eligible for GC
```

Or:

```java
createUser();  // object created inside method
// method ends â†’ reference lost â†’ eligible
```

---

# ğŸ”¹ How Does GC Know an Object Is Unused?

Java uses **Reachability Analysis**.

It starts from:

* Static variables
* Local variables in stack
* Active threads
* JNI references

If an object cannot be reached from these â€œGC rootsâ€ â†’ it is eligible for collection.

---

# ğŸ”¹ Generational Garbage Collection (Very Important)

Heap is divided into:

### 1ï¸âƒ£ Young Generation

* Eden space
* Survivor spaces (S0, S1)
* Most objects die here
* Minor GC happens here

### 2ï¸âƒ£ Old (Tenured) Generation

* Long-living objects
* Major GC happens here

### 3ï¸âƒ£ Metaspace

* Class metadata (since Java 8)
* Replaced PermGen

---

# ğŸ”¹ How It Works Step-by-Step

1. Objects created â†’ go to Eden
2. Minor GC runs â†’ removes unused objects
3. Surviving objects move to Survivor space
4. After several cycles â†’ promoted to Old generation
5. Major GC runs occasionally â†’ cleans Old generation

---

# ğŸ”¹ Types of Garbage Collectors (Mention 1â€“2 Only)

* Serial GC
* Parallel GC
* CMS (Concurrent Mark Sweep)
* G1 GC (default in modern Java)
* ZGC (low latency)

In interviews, mentioning **G1 GC** is good enough.

---

# ğŸ”¥ Short Interview-Ready Answer

If asked:

> How does garbage collection work in Java?

You can say:

> Java uses automatic garbage collection to manage heap memory. It uses reachability analysis to determine which objects are no longer referenced from GC roots. The heap is divided into young and old generations. Most objects are created in the young generation and collected during minor GC. Long-lived objects move to the old generation, where major GC occurs. Modern JVMs typically use the G1 garbage collector for efficient memory management.

That is strong and professional.

---

# ğŸ” Common Follow-Up Questions

They may ask:

* What causes memory leaks in Java?
* What is Stop-The-World?
* What is GC tuning?
* Difference between Minor and Major GC?
* What is Metaspace?
* Can GC guarantee immediate cleanup?

If youâ€™d like, I can now:

* Give you memory leak examples (very common question)
* Explain Stop-The-World clearly
* Simulate a rapid-fire GC interview round

Your call.


---
---
_________________________________________________________________________________________________________



